// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package makers_token_v2

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = abi.U256
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// AddressUtilsABI is the input ABI used to generate the binding from.
const AddressUtilsABI = "[]"

// AddressUtilsBin is the compiled bytecode used for deploying new contracts.
var AddressUtilsBin = "0x604c602c600b82828239805160001a60731460008114601c57601e565bfe5b5030600052607381538281f30073000000000000000000000000000000000000000030146080604052600080fd00a165627a7a7230582066211259b3f13452232f796ed1368324af034fa52533b356dff105d3032f80340029"

// DeployAddressUtils deploys a new Ethereum contract, binding an instance of AddressUtils to it.
func DeployAddressUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *AddressUtils, error) {
	parsed, err := abi.JSON(strings.NewReader(AddressUtilsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(AddressUtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &AddressUtils{AddressUtilsCaller: AddressUtilsCaller{contract: contract}, AddressUtilsTransactor: AddressUtilsTransactor{contract: contract}, AddressUtilsFilterer: AddressUtilsFilterer{contract: contract}}, nil
}

// AddressUtils is an auto generated Go binding around an Ethereum contract.
type AddressUtils struct {
	AddressUtilsCaller     // Read-only binding to the contract
	AddressUtilsTransactor // Write-only binding to the contract
	AddressUtilsFilterer   // Log filterer for contract events
}

// AddressUtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type AddressUtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressUtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AddressUtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressUtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AddressUtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressUtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AddressUtilsSession struct {
	Contract     *AddressUtils     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AddressUtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AddressUtilsCallerSession struct {
	Contract *AddressUtilsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// AddressUtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AddressUtilsTransactorSession struct {
	Contract     *AddressUtilsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// AddressUtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type AddressUtilsRaw struct {
	Contract *AddressUtils // Generic contract binding to access the raw methods on
}

// AddressUtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AddressUtilsCallerRaw struct {
	Contract *AddressUtilsCaller // Generic read-only contract binding to access the raw methods on
}

// AddressUtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AddressUtilsTransactorRaw struct {
	Contract *AddressUtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAddressUtils creates a new instance of AddressUtils, bound to a specific deployed contract.
func NewAddressUtils(address common.Address, backend bind.ContractBackend) (*AddressUtils, error) {
	contract, err := bindAddressUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AddressUtils{AddressUtilsCaller: AddressUtilsCaller{contract: contract}, AddressUtilsTransactor: AddressUtilsTransactor{contract: contract}, AddressUtilsFilterer: AddressUtilsFilterer{contract: contract}}, nil
}

// NewAddressUtilsCaller creates a new read-only instance of AddressUtils, bound to a specific deployed contract.
func NewAddressUtilsCaller(address common.Address, caller bind.ContractCaller) (*AddressUtilsCaller, error) {
	contract, err := bindAddressUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AddressUtilsCaller{contract: contract}, nil
}

// NewAddressUtilsTransactor creates a new write-only instance of AddressUtils, bound to a specific deployed contract.
func NewAddressUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*AddressUtilsTransactor, error) {
	contract, err := bindAddressUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AddressUtilsTransactor{contract: contract}, nil
}

// NewAddressUtilsFilterer creates a new log filterer instance of AddressUtils, bound to a specific deployed contract.
func NewAddressUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*AddressUtilsFilterer, error) {
	contract, err := bindAddressUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AddressUtilsFilterer{contract: contract}, nil
}

// bindAddressUtils binds a generic wrapper to an already deployed contract.
func bindAddressUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(AddressUtilsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AddressUtils *AddressUtilsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _AddressUtils.Contract.AddressUtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AddressUtils *AddressUtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AddressUtils.Contract.AddressUtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AddressUtils *AddressUtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AddressUtils.Contract.AddressUtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AddressUtils *AddressUtilsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _AddressUtils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AddressUtils *AddressUtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AddressUtils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AddressUtils *AddressUtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AddressUtils.Contract.contract.Transact(opts, method, params...)
}

// ApprovedCreatorRegistryInterfaceABI is the input ABI used to generate the binding from.
const ApprovedCreatorRegistryInterfaceABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_custodialAddress\",\"type\":\"address\"}],\"name\":\"isOperatorApprovedForCustodialAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"typeOfContract\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]"

// ApprovedCreatorRegistryInterfaceFuncSigs maps the 4-byte function signature to its string representation.
var ApprovedCreatorRegistryInterfaceFuncSigs = map[string]string{
	"0d8e6e2c": "getVersion()",
	"67d6a7dc": "isOperatorApprovedForCustodialAccount(address,address)",
	"c20a0382": "typeOfContract()",
}

// ApprovedCreatorRegistryInterface is an auto generated Go binding around an Ethereum contract.
type ApprovedCreatorRegistryInterface struct {
	ApprovedCreatorRegistryInterfaceCaller     // Read-only binding to the contract
	ApprovedCreatorRegistryInterfaceTransactor // Write-only binding to the contract
	ApprovedCreatorRegistryInterfaceFilterer   // Log filterer for contract events
}

// ApprovedCreatorRegistryInterfaceCaller is an auto generated read-only Go binding around an Ethereum contract.
type ApprovedCreatorRegistryInterfaceCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ApprovedCreatorRegistryInterfaceTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ApprovedCreatorRegistryInterfaceTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ApprovedCreatorRegistryInterfaceFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ApprovedCreatorRegistryInterfaceFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ApprovedCreatorRegistryInterfaceSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ApprovedCreatorRegistryInterfaceSession struct {
	Contract     *ApprovedCreatorRegistryInterface // Generic contract binding to set the session for
	CallOpts     bind.CallOpts                     // Call options to use throughout this session
	TransactOpts bind.TransactOpts                 // Transaction auth options to use throughout this session
}

// ApprovedCreatorRegistryInterfaceCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ApprovedCreatorRegistryInterfaceCallerSession struct {
	Contract *ApprovedCreatorRegistryInterfaceCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                           // Call options to use throughout this session
}

// ApprovedCreatorRegistryInterfaceTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ApprovedCreatorRegistryInterfaceTransactorSession struct {
	Contract     *ApprovedCreatorRegistryInterfaceTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                           // Transaction auth options to use throughout this session
}

// ApprovedCreatorRegistryInterfaceRaw is an auto generated low-level Go binding around an Ethereum contract.
type ApprovedCreatorRegistryInterfaceRaw struct {
	Contract *ApprovedCreatorRegistryInterface // Generic contract binding to access the raw methods on
}

// ApprovedCreatorRegistryInterfaceCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ApprovedCreatorRegistryInterfaceCallerRaw struct {
	Contract *ApprovedCreatorRegistryInterfaceCaller // Generic read-only contract binding to access the raw methods on
}

// ApprovedCreatorRegistryInterfaceTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ApprovedCreatorRegistryInterfaceTransactorRaw struct {
	Contract *ApprovedCreatorRegistryInterfaceTransactor // Generic write-only contract binding to access the raw methods on
}

// NewApprovedCreatorRegistryInterface creates a new instance of ApprovedCreatorRegistryInterface, bound to a specific deployed contract.
func NewApprovedCreatorRegistryInterface(address common.Address, backend bind.ContractBackend) (*ApprovedCreatorRegistryInterface, error) {
	contract, err := bindApprovedCreatorRegistryInterface(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ApprovedCreatorRegistryInterface{ApprovedCreatorRegistryInterfaceCaller: ApprovedCreatorRegistryInterfaceCaller{contract: contract}, ApprovedCreatorRegistryInterfaceTransactor: ApprovedCreatorRegistryInterfaceTransactor{contract: contract}, ApprovedCreatorRegistryInterfaceFilterer: ApprovedCreatorRegistryInterfaceFilterer{contract: contract}}, nil
}

// NewApprovedCreatorRegistryInterfaceCaller creates a new read-only instance of ApprovedCreatorRegistryInterface, bound to a specific deployed contract.
func NewApprovedCreatorRegistryInterfaceCaller(address common.Address, caller bind.ContractCaller) (*ApprovedCreatorRegistryInterfaceCaller, error) {
	contract, err := bindApprovedCreatorRegistryInterface(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ApprovedCreatorRegistryInterfaceCaller{contract: contract}, nil
}

// NewApprovedCreatorRegistryInterfaceTransactor creates a new write-only instance of ApprovedCreatorRegistryInterface, bound to a specific deployed contract.
func NewApprovedCreatorRegistryInterfaceTransactor(address common.Address, transactor bind.ContractTransactor) (*ApprovedCreatorRegistryInterfaceTransactor, error) {
	contract, err := bindApprovedCreatorRegistryInterface(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ApprovedCreatorRegistryInterfaceTransactor{contract: contract}, nil
}

// NewApprovedCreatorRegistryInterfaceFilterer creates a new log filterer instance of ApprovedCreatorRegistryInterface, bound to a specific deployed contract.
func NewApprovedCreatorRegistryInterfaceFilterer(address common.Address, filterer bind.ContractFilterer) (*ApprovedCreatorRegistryInterfaceFilterer, error) {
	contract, err := bindApprovedCreatorRegistryInterface(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ApprovedCreatorRegistryInterfaceFilterer{contract: contract}, nil
}

// bindApprovedCreatorRegistryInterface binds a generic wrapper to an already deployed contract.
func bindApprovedCreatorRegistryInterface(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ApprovedCreatorRegistryInterfaceABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ApprovedCreatorRegistryInterface.Contract.ApprovedCreatorRegistryInterfaceCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ApprovedCreatorRegistryInterface.Contract.ApprovedCreatorRegistryInterfaceTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ApprovedCreatorRegistryInterface.Contract.ApprovedCreatorRegistryInterfaceTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ApprovedCreatorRegistryInterface.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ApprovedCreatorRegistryInterface.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ApprovedCreatorRegistryInterface.Contract.contract.Transact(opts, method, params...)
}

// GetVersion is a free data retrieval call binding the contract method 0x0d8e6e2c.
//
// Solidity: function getVersion() constant returns(uint256)
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceCaller) GetVersion(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ApprovedCreatorRegistryInterface.contract.Call(opts, out, "getVersion")
	return *ret0, err
}

// GetVersion is a free data retrieval call binding the contract method 0x0d8e6e2c.
//
// Solidity: function getVersion() constant returns(uint256)
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceSession) GetVersion() (*big.Int, error) {
	return _ApprovedCreatorRegistryInterface.Contract.GetVersion(&_ApprovedCreatorRegistryInterface.CallOpts)
}

// GetVersion is a free data retrieval call binding the contract method 0x0d8e6e2c.
//
// Solidity: function getVersion() constant returns(uint256)
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceCallerSession) GetVersion() (*big.Int, error) {
	return _ApprovedCreatorRegistryInterface.Contract.GetVersion(&_ApprovedCreatorRegistryInterface.CallOpts)
}

// IsOperatorApprovedForCustodialAccount is a free data retrieval call binding the contract method 0x67d6a7dc.
//
// Solidity: function isOperatorApprovedForCustodialAccount(address _operator, address _custodialAddress) constant returns(bool)
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceCaller) IsOperatorApprovedForCustodialAccount(opts *bind.CallOpts, _operator common.Address, _custodialAddress common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ApprovedCreatorRegistryInterface.contract.Call(opts, out, "isOperatorApprovedForCustodialAccount", _operator, _custodialAddress)
	return *ret0, err
}

// IsOperatorApprovedForCustodialAccount is a free data retrieval call binding the contract method 0x67d6a7dc.
//
// Solidity: function isOperatorApprovedForCustodialAccount(address _operator, address _custodialAddress) constant returns(bool)
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceSession) IsOperatorApprovedForCustodialAccount(_operator common.Address, _custodialAddress common.Address) (bool, error) {
	return _ApprovedCreatorRegistryInterface.Contract.IsOperatorApprovedForCustodialAccount(&_ApprovedCreatorRegistryInterface.CallOpts, _operator, _custodialAddress)
}

// IsOperatorApprovedForCustodialAccount is a free data retrieval call binding the contract method 0x67d6a7dc.
//
// Solidity: function isOperatorApprovedForCustodialAccount(address _operator, address _custodialAddress) constant returns(bool)
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceCallerSession) IsOperatorApprovedForCustodialAccount(_operator common.Address, _custodialAddress common.Address) (bool, error) {
	return _ApprovedCreatorRegistryInterface.Contract.IsOperatorApprovedForCustodialAccount(&_ApprovedCreatorRegistryInterface.CallOpts, _operator, _custodialAddress)
}

// TypeOfContract is a free data retrieval call binding the contract method 0xc20a0382.
//
// Solidity: function typeOfContract() constant returns(string)
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceCaller) TypeOfContract(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ApprovedCreatorRegistryInterface.contract.Call(opts, out, "typeOfContract")
	return *ret0, err
}

// TypeOfContract is a free data retrieval call binding the contract method 0xc20a0382.
//
// Solidity: function typeOfContract() constant returns(string)
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceSession) TypeOfContract() (string, error) {
	return _ApprovedCreatorRegistryInterface.Contract.TypeOfContract(&_ApprovedCreatorRegistryInterface.CallOpts)
}

// TypeOfContract is a free data retrieval call binding the contract method 0xc20a0382.
//
// Solidity: function typeOfContract() constant returns(string)
func (_ApprovedCreatorRegistryInterface *ApprovedCreatorRegistryInterfaceCallerSession) TypeOfContract() (string, error) {
	return _ApprovedCreatorRegistryInterface.Contract.TypeOfContract(&_ApprovedCreatorRegistryInterface.CallOpts)
}

// DigitalMediaCoreABI is the input ABI used to generate the binding from.
const DigitalMediaCoreABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"currentStartingDigitalMediaId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_metadataPath\",\"type\":\"string\"}],\"name\":\"createCollection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_totalSupply\",\"type\":\"uint32\"},{\"name\":\"_digitalMediaMetadataPath\",\"type\":\"string\"},{\"name\":\"_collectionMetadataPath\",\"type\":\"string\"},{\"name\":\"_numReleases\",\"type\":\"uint32\"}],\"name\":\"oboCreateDigitalMediaAndReleasesInNewCollection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"singleCreatorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentDigitalMediaStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_digitalMediaId\",\"type\":\"uint256\"}],\"name\":\"burnDigitalMedia\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToDigitalMediaRelease\",\"outputs\":[{\"name\":\"printEdition\",\"type\":\"uint32\"},{\"name\":\"digitalMediaId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_creatorAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedTokenCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedCreators\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDigitalMedia\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"totalSupply\",\"type\":\"uint32\"},{\"name\":\"printIndex\",\"type\":\"uint32\"},{\"name\":\"collectionId\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"metadataPath\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getCollection\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"metadataPath\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_newCreator\",\"type\":\"address\"}],\"name\":\"changeCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint32\"},{\"name\":\"_collectionId\",\"type\":\"uint256\"},{\"name\":\"_metadataPath\",\"type\":\"string\"}],\"name\":\"createDigitalMedia\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_totalSupply\",\"type\":\"uint32\"},{\"name\":\"_collectionId\",\"type\":\"uint256\"},{\"name\":\"_metadataPath\",\"type\":\"string\"},{\"name\":\"_numReleases\",\"type\":\"uint32\"}],\"name\":\"oboCreateDigitalMediaAndReleases\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setOboApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burnToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_digitalMediaId\",\"type\":\"uint256\"},{\"name\":\"_numReleases\",\"type\":\"uint32\"}],\"name\":\"createDigitalMediaReleases\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDigitalMediaRelease\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"printEdition\",\"type\":\"uint32\"},{\"name\":\"digitalMediaId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint32\"},{\"name\":\"_digitalMediaMetadataPath\",\"type\":\"string\"},{\"name\":\"_collectionMetadataPath\",\"type\":\"string\"},{\"name\":\"_numReleases\",\"type\":\"uint32\"}],\"name\":\"createDigitalMediaAndReleasesInNewCollection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dmsAddress\",\"type\":\"address\"}],\"name\":\"setV1DigitalMediaStoreAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oboAddress\",\"type\":\"address\"}],\"name\":\"disableOboAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"v1DigitalMediaStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCreatorAddress\",\"type\":\"address\"}],\"name\":\"changeSingleCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_digitalMediaId\",\"type\":\"uint256\"},{\"name\":\"_numReleases\",\"type\":\"uint32\"}],\"name\":\"oboCreateDigitalMediaReleases\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creatorRegistryStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"resetApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedTokenCreators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"disabledOboOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint32\"},{\"name\":\"_collectionId\",\"type\":\"uint256\"},{\"name\":\"_metadataPath\",\"type\":\"string\"},{\"name\":\"_numReleases\",\"type\":\"uint32\"}],\"name\":\"createDigitalMediaAndReleases\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_creatorAddress\",\"type\":\"address\"}],\"name\":\"addApprovedTokenCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"name\":\"_tokenIdStartingCounter\",\"type\":\"uint256\"},{\"name\":\"_dmsAddress\",\"type\":\"address\"},{\"name\":\"_crsAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"OboApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"OboDisabledForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"printEdition\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"tokenURI\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"digitalMediaId\",\"type\":\"uint256\"}],\"name\":\"DigitalMediaReleaseCreateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"storeContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"printIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"collectionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"metadataPath\",\"type\":\"string\"}],\"name\":\"DigitalMediaCreateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"storeContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"metadataPath\",\"type\":\"string\"}],\"name\":\"DigitalMediaCollectionCreateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"storeContractAddress\",\"type\":\"address\"}],\"name\":\"DigitalMediaBurnEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"DigitalMediaReleaseBurnEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"digitalMediaId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"printEdition\",\"type\":\"uint32\"}],\"name\":\"UpdateDigitalMediaPrintIndexEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCreator\",\"type\":\"address\"}],\"name\":\"ChangedCreator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousCreatorAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newCreatorAddress\",\"type\":\"address\"}],\"name\":\"SingleCreatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]"

// DigitalMediaCoreFuncSigs maps the 4-byte function signature to its string representation.
var DigitalMediaCoreFuncSigs = map[string]string{
	"fafa8a4b": "addApprovedTokenCreator(address)",
	"095ea7b3": "approve(address,uint256)",
	"55232467": "approvedCreators(address)",
	"d70f575f": "approvedTokenCreators(address)",
	"70a08231": "balanceOf(address)",
	"42966c68": "burn(uint256)",
	"23077f58": "burnDigitalMedia(uint256)",
	"7b47ec1a": "burnToken(uint256)",
	"5cf09fee": "changeCreator(address,address)",
	"a7df572c": "changeSingleCreator(address)",
	"059dfe13": "createCollection(string)",
	"603417fb": "createDigitalMedia(uint32,uint256,string)",
	"eca211e3": "createDigitalMediaAndReleases(uint32,uint256,string,uint32)",
	"8b40e8aa": "createDigitalMediaAndReleasesInNewCollection(uint32,string,string,uint32)",
	"7fb08c9b": "createDigitalMediaReleases(uint256,uint32)",
	"b39ba60a": "creatorRegistryStore()",
	"1b284e75": "currentDigitalMediaStore()",
	"0154788d": "currentStartingDigitalMediaId()",
	"92b8bde1": "disableOboAddress(address)",
	"e158386d": "disabledOboOperators(address)",
	"4f558e79": "exists(uint256)",
	"081812fc": "getApproved(uint256)",
	"5a1f3c28": "getCollection(uint256)",
	"55df4275": "getDigitalMedia(uint256)",
	"8a603bdf": "getDigitalMediaRelease(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"06fdde03": "name()",
	"6ee17a78": "oboCreateDigitalMediaAndReleases(address,uint32,uint256,string,uint32)",
	"06a186d1": "oboCreateDigitalMediaAndReleasesInNewCollection(address,uint32,string,string,uint32)",
	"b36f0faa": "oboCreateDigitalMediaReleases(address,uint256,uint32)",
	"8da5cb5b": "owner()",
	"6352211e": "ownerOf(uint256)",
	"8456cb59": "pause()",
	"5c975abb": "paused()",
	"4751ae99": "removeApprovedTokenCreator(address)",
	"cf8dae05": "resetApproval(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"774f99d0": "setOboApprovalForAll(address,bool)",
	"91c60788": "setV1DigitalMediaStoreAddress(address)",
	"147ca2af": "singleCreatorAddress()",
	"01ffc9a7": "supportsInterface(bytes4)",
	"95d89b41": "symbol()",
	"4f6ccce7": "tokenByIndex(uint256)",
	"3db57cbe": "tokenIdToDigitalMediaRelease(uint256)",
	"2f745c59": "tokenOfOwnerByIndex(address,uint256)",
	"c87b56dd": "tokenURI(uint256)",
	"18160ddd": "totalSupply()",
	"23b872dd": "transferFrom(address,address,uint256)",
	"f2fde38b": "transferOwnership(address)",
	"3f4ba83a": "unpause()",
	"a0f01e08": "v1DigitalMediaStore()",
}

// DigitalMediaCoreBin is the compiled bytecode used for deploying new contracts.
var DigitalMediaCoreBin = "0x60806040526000805460a060020a60ff02191681556013553480156200002457600080fd5b5060405162004769380380620047698339810160409081528151602080840151928401516060850151608086015160008054600160a060020a0319163317905593860180519096959095019491939092909186918691869184918491620000919160099185019062000577565b508051620000a790600a90602084019062000577565b50505060135550506000805460a060020a60ff02191674010000000000000000000000000000000000000000179055620000ea8264010000000062000109810204565b620000fe8164010000000062000335810204565b50505050506200061c565b600081905080600160a060020a0316636c669f256040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1580156200016657600080fd5b505af11580156200017b573d6000803e3d6000fd5b505050506040513d60208110156200019257600080fd5b50516002146200020357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e636f72726563742076657273696f6e2e0000000000000000000000000000604482015290519081900360640190fd5b60028054600160a060020a031916600160a060020a038381169190911791829055604080517fa60800b80000000000000000000000000000000000000000000000000000000081529051929091169163a60800b89160048082019260009290919082900301818387803b1580156200027a57600080fd5b505af11580156200028f573d6000803e3d6000fd5b50505050600260009054906101000a9004600160a060020a0316600160a060020a031663b9905d116040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1580156200030057600080fd5b505af115801562000315573d6000803e3d6000fd5b505050506040513d60208110156200032c57600080fd5b50516003555050565b600081905080600160a060020a0316630d8e6e2c6040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b1580156200039257600080fd5b505af1158015620003a7573d6000803e3d6000fd5b505050506040513d6020811015620003be57600080fd5b5051600114620003cd57600080fd5b604080517f617070726f76656443726561746f725265676973747279000000000000000000815281519081900360170181207fc20a03820000000000000000000000000000000000000000000000000000000082529151600160a060020a0384169163c20a038291600480830192600092919082900301818387803b1580156200045657600080fd5b505af11580156200046b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405260208110156200049557600080fd5b810190808051640100000000811115620004ae57600080fd5b82016020810184811115620004c257600080fd5b8151640100000000811182820187101715620004dd57600080fd5b50509291905050506040518082805190602001908083835b60208310620005165780518252601f199092019160209182019101620004f5565b6001836020036101000a0380198251168184511680821785525050505050509050019150506040518091039020600019161415156200055457600080fd5b60048054600160a060020a031916600160a060020a039290921691909117905550565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10620005ba57805160ff1916838001178555620005ea565b82800160010185558215620005ea579182015b82811115620005ea578251825591602001919060010190620005cd565b50620005f8929150620005fc565b5090565b6200061991905b80821115620005f8576000815560010162000603565b90565b61413d806200062c6000396000f3006080604052600436106102635763ffffffff60e060020a6000350416630154788d811461026857806301ffc9a71461028f578063059dfe13146102c557806306a186d1146102e757806306fdde0314610333578063081812fc146103bd578063095ea7b3146103f1578063147ca2af1461041557806318160ddd1461042a5780631b284e751461043f57806323077f581461045457806323b872dd1461046c5780632f745c59146104965780633db57cbe146104ba5780633f4ba83a146104f257806342842e0e1461050757806342966c68146105315780634751ae99146105495780634f558e791461056a5780634f6ccce714610582578063552324671461059a57806355df4275146105bb5780635a1f3c28146106985780635c975abb146107485780635cf09fee1461075d578063603417fb146107845780636352211e146107b25780636ee17a78146107ca57806370a082311461080d578063774f99d01461082e5780637b47ec1a146105315780637fb08c9b146108545780638456cb59146108755780638a603bdf1461088a5780638b40e8aa146108c55780638da5cb5b1461090257806391c607881461091757806392b8bde11461093857806395d89b4114610959578063a0f01e081461096e578063a22cb46514610983578063a7df572c146109a9578063b36f0faa146109ca578063b39ba60a146109f7578063b88d4fde14610a0c578063c87b56dd14610a7b578063cf8dae0514610a93578063d70f575f14610aab578063e158386d14610acc578063e985e9c514610aed578063eca211e314610b14578063f2fde38b14610b49578063fafa8a4b14610b6a575b600080fd5b34801561027457600080fd5b5061027d610b8b565b60408051918252519081900360200190f35b34801561029b57600080fd5b506102b1600160e060020a031960043516610b91565b604080519115158252519081900360200190f35b3480156102d157600080fd5b506102e56004803560248101910135610d6d565b005b3480156102f357600080fd5b506102e5600160a060020a0360048035919091169063ffffffff602480358216926044358083019390820135926064359081019201359060843516610dc3565b34801561033f57600080fd5b50610348610efc565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561038257818101518382015260200161036a565b50505050905090810190601f1680156103af5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156103c957600080fd5b506103d5600435610f93565b60408051600160a060020a039092168252519081900360200190f35b3480156103fd57600080fd5b506102e5600160a060020a0360043516602435610fae565b34801561042157600080fd5b506103d5611092565b34801561043657600080fd5b5061027d6110a1565b34801561044b57600080fd5b506103d56110a7565b34801561046057600080fd5b506102e56004356110b6565b34801561047857600080fd5b506102e5600160a060020a03600435811690602435166044356110da565b3480156104a257600080fd5b5061027d600160a060020a0360043516602435611189565b3480156104c657600080fd5b506104d26004356111d7565b6040805163ffffffff909316835260208301919091528051918290030190f35b3480156104fe57600080fd5b506102e56111f9565b34801561051357600080fd5b506102e5600160a060020a036004358116906024351660443561126f565b34801561053d57600080fd5b506102e56004356112a7565b34801561055557600080fd5b506102e5600160a060020a03600435166112b1565b34801561057657600080fd5b506102b16004356112e9565b34801561058e57600080fd5b5061027d600435611306565b3480156105a657600080fd5b506103d5600160a060020a036004351661133b565b3480156105c757600080fd5b506105d3600435611356565b604051808781526020018663ffffffff1663ffffffff1681526020018563ffffffff1663ffffffff16815260200184815260200183600160a060020a0316600160a060020a0316815260200180602001828103825283818151815260200191508051906020019080838360005b83811015610658578181015183820152602001610640565b50505050905090810190601f1680156106855780820380516001836020036101000a031916815260200191505b5097505050505050505060405180910390f35b3480156106a457600080fd5b506106b0600435611406565b6040518084815260200183600160a060020a0316600160a060020a0316815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561070b5781810151838201526020016106f3565b50505050905090810190601f1680156107385780820380516001836020036101000a031916815260200191505b5094505050505060405180910390f35b34801561075457600080fd5b506102b1611499565b34801561076957600080fd5b506102e5600160a060020a03600435811690602435166114a9565b34801561079057600080fd5b506102e56004803563ffffffff169060248035916044359182019101356114b8565b3480156107be57600080fd5b506103d5600435611512565b3480156107d657600080fd5b506102e560048035600160a060020a0316906024803563ffffffff9081169260443592606435908101929101359060843516611536565b34801561081957600080fd5b5061027d600160a060020a036004351661162f565b34801561083a57600080fd5b506102e5600160a060020a03600435166024351515611662565b34801561086057600080fd5b506102e560043563ffffffff60243516611846565b34801561088157600080fd5b506102e5611868565b34801561089657600080fd5b506108a26004356118e3565b6040805193845263ffffffff909216602084015282820152519081900360600190f35b3480156108d157600080fd5b506102e56004803563ffffffff90811691602480358082019390830135926044359283019201359060643516611925565b34801561090e57600080fd5b506103d56119ce565b34801561092357600080fd5b506102e5600160a060020a03600435166119dd565b34801561094457600080fd5b506102e5600160a060020a0360043516611bac565b34801561096557600080fd5b50610348611ca2565b34801561097a57600080fd5b506103d5611d03565b34801561098f57600080fd5b506102e5600160a060020a03600435166024351515611d12565b3480156109b557600080fd5b506102e5600160a060020a0360043516611d96565b3480156109d657600080fd5b506102e5600160a060020a036004351660243563ffffffff60443516611e83565b348015610a0357600080fd5b506103d5611f34565b348015610a1857600080fd5b50604080516020601f6064356004818101359283018490048402850184019095528184526102e594600160a060020a038135811695602480359092169560443595369560849401918190840183828082843750949750611f439650505050505050565b348015610a8757600080fd5b50610348600435611f7b565b348015610a9f57600080fd5b506102e5600435612030565b348015610ab757600080fd5b506102b1600160a060020a036004351661203a565b348015610ad857600080fd5b506102b1600160a060020a036004351661204f565b348015610af957600080fd5b506102b1600160a060020a0360043581169060243516612064565b348015610b2057600080fd5b506102e563ffffffff6004803582169160248035926044359182019291013590606435166120f5565b348015610b5557600080fd5b506102e5600160a060020a0360043516612156565b348015610b7657600080fd5b506102e5600160a060020a03600435166121dd565b60035481565b604080517f737570706f727473496e7465726661636528627974657334290000000000000081529051908190036019019020600090600160e060020a031983811691161480610d655750604080517f736166655472616e7366657246726f6d28616464726573732c6164647265737381527f2c75696e74323536290000000000000000000000000000000000000000000000602082015281519081900360290181207f617070726f766528616464726573732c75696e74323536290000000000000000825282519182900360180182207f6f776e65724f662875696e743235362900000000000000000000000000000000835283519283900360100183207f62616c616e63654f662861646472657373290000000000000000000000000000845284519384900360120184207f746f74616c537570706c792829000000000000000000000000000000000000008552855194859003600d0185207f73796d626f6c2829000000000000000000000000000000000000000000000000865286519586900360080186207f6e616d65282900000000000000000000000000000000000000000000000000008752965195869003600601909520600160e060020a0319898116919097189095181818181891909116145b90505b919050565b60005460a060020a900460ff1615610d8457600080fd5b610dbe3383838080601f0160208091040260200160405190810160405280939291908181526020018383808284375061228e945050505050565b505050565b60008054819060a060020a900460ff1615610ddd57600080fd5b3360009081526014602052604090205460ff1615156001148015610e1657503360009081526016602052604090205460ff161515600114155b1515610e6c576040805160e560020a62461bcd02815260206004820152601760248201527f556e617070726f766564204f424f20616464726573732e000000000000000000604482015290519081900360640190fd5b610ea68986868080601f0160208091040260200160405190810160405280939291908181526020018383808284375061228e945050505050565b9150610ee48989848a8a8080601f01602080910402602001604051908101604052809392919081815260200183838082843750612466945050505050565b9050610ef189828561270d565b505050505050505050565b60098054604080516020601f6002600019610100600188161502019095169490940493840181900481028201810190925282815260609390929091830182828015610f885780601f10610f5d57610100808354040283529160200191610f88565b820191906000526020600020905b815481529060010190602001808311610f6b57829003601f168201915b505050505090505b90565b600090815260066020526040902054600160a060020a031690565b6000610fb982611512565b9050600160a060020a038381169082161415610fd457600080fd5b33600160a060020a0382161480610ff05750610ff08133612064565b1515610ffb57600080fd5b600061100683610f93565b600160a060020a03161415806110245750600160a060020a03831615155b15610dbe576000828152600660209081526040918290208054600160a060020a031916600160a060020a03878116918217909255835186815293519093918516927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a3505050565b601054600160a060020a031681565b600d5490565b600254600160a060020a031681565b60005460a060020a900460ff16156110cd57600080fd5b6110d78133612bcf565b50565b806110e53382612cf9565b15156110f057600080fd5b600160a060020a038416151561110557600080fd5b600160a060020a038316151561111a57600080fd5b6111248483612d58565b61112e8483612df8565b6111388383612f31565b82600160a060020a031684600160a060020a03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a350505050565b60006111948361162f565b821061119f57600080fd5b600160a060020a0383166000908152600b602052604090208054839081106111c357fe5b906000526020600020015490505b92915050565b6011602052600090815260409020805460019091015463ffffffff9091169082565b600054600160a060020a0316331461121057600080fd5b60005460a060020a900460ff16151561122857600080fd5b6000805474ff0000000000000000000000000000000000000000191681556040517f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b339190a1565b8061127a3382612cf9565b151561128557600080fd5b6112a18484846020604051908101604052806000815250611f43565b50505050565b6110d78133612f7a565b600054600160a060020a031633146112c857600080fd5b600160a060020a03166000908152601460205260409020805460ff19169055565b600090815260056020526040902054600160a060020a0316151590565b60006113106110a1565b821061131b57600080fd5b600d80548390811061132957fe5b90600052602060002001549050919050565b601260205260009081526040902054600160a060020a031681565b60008060008060006060611368613f93565b611371886130c1565b6080810151909150600160a060020a031615156113d8576040805160e560020a62461bcd02815260206004820152601760248201527f4469676974616c4d65646961206e6f7420666f756e642e000000000000000000604482015290519081900360640190fd5b602081015160408201516060830151608084015160a0909401519a9b929a9199509750919550909350915050565b6000806060611413613fdf565b61141c85613257565b6020810151909150600160a060020a03161515611483576040805160e560020a62461bcd02815260206004820152601560248201527f436f6c6c656374696f6e206e6f7420666f756e642e0000000000000000000000604482015290519081900360640190fd5b6020810151604090910151949590949350915050565b60005460a060020a900460ff1681565b6114b43383836133c5565b5050565b60005460a060020a900460ff16156114cf57600080fd5b61150b33858585858080601f01602080910402602001604051908101604052809392919081815260200183838082843750612466945050505050565b5050505050565b600081815260056020526040812054600160a060020a03168015156111d157600080fd5b6000805460a060020a900460ff161561154e57600080fd5b3360009081526014602052604090205460ff161515600114801561158757503360009081526016602052604090205460ff161515600114155b15156115dd576040805160e560020a62461bcd02815260206004820152601760248201527f556e617070726f766564204f424f20616464726573732e000000000000000000604482015290519081900360640190fd5b61161987878787878080601f01602080910402602001604051908101604052809392919081815260200183838082843750612466945050505050565b905061162687828461270d565b50505050505050565b6000600160a060020a038216151561164657600080fd5b50600160a060020a031660009081526007602052604090205490565b600160a060020a0382163314156116e9576040805160e560020a62461bcd02815260206004820152602560248201527f417070726f76616c20616464726573732069732073616d65206173206170707260448201527f6f7665722e000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600160a060020a03821660009081526014602052604090205460ff16151561175b576040805160e560020a62461bcd02815260206004820152601960248201527f556e7265636f676e697a6564204f424f20616464726573732e00000000000000604482015290519081900360640190fd5b600160a060020a03821660009081526016602052604090205460ff161515600114156117d1576040805160e560020a62461bcd02815260206004820152601d60248201527f417070726f76616c20616464726573732069732064697361626c65642e000000604482015290519081900360640190fd5b336000818152601560209081526040808320600160a060020a03871680855290835292819020805486151560ff19909116811790915581519485529184019290925282820152517f017e8a478826a4348bfb695968246edfab885f8a76b03279cf4630ac073945c99181900360600190a15050565b60005460a060020a900460ff161561185d57600080fd5b6114b433838361270d565b600054600160a060020a0316331461187f57600080fd5b60005460a060020a900460ff161561189657600080fd5b6000805474ff0000000000000000000000000000000000000000191660a060020a1781556040517f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff6259190a1565b6000806000806118f2856112e9565b15156118fd57600080fd5b50505060008281526011602052604090208054600190910154929363ffffffff909116929150565b60008054819060a060020a900460ff161561193f57600080fd5b6119793386868080601f0160208091040260200160405190810160405280939291908181526020018383808284375061228e945050505050565b91506119b73389848a8a8080601f01602080910402602001604051908101604052809392919081815260200183838082843750612466945050505050565b90506119c433828561270d565b5050505050505050565b600054600160a060020a031681565b60008054600160a060020a031633146119f557600080fd5b600154600160a060020a031615611a56576040805160e560020a62461bcd02815260206004820152601b60248201527f5631206d656469612073746f726520616c7265616479207365742e0000000000604482015290519081900360640190fd5b81905080600160a060020a0316636c669f256040518163ffffffff1660e060020a028152600401602060405180830381600087803b158015611a9757600080fd5b505af1158015611aab573d6000803e3d6000fd5b505050506040513d6020811015611ac157600080fd5b5051600114611b1a576040805160e560020a62461bcd02815260206004820152601260248201527f496e636f72726563742076657273696f6e2e0000000000000000000000000000604482015290519081900360640190fd5b60018054600160a060020a031916600160a060020a038381169190911791829055604080517fa60800b80000000000000000000000000000000000000000000000000000000081529051929091169163a60800b89160048082019260009290919082900301818387803b158015611b9057600080fd5b505af1158015611ba4573d6000803e3d6000fd5b505050505050565b600054600160a060020a03163314611bc357600080fd5b600160a060020a03811660009081526014602052604090205460ff161515611c35576040805160e560020a62461bcd02815260206004820152601960248201527f556e7265636f676e697a6564204f424f20616464726573732e00000000000000604482015290519081900360640190fd5b600160a060020a0381166000818152601660209081526040808320805460ff1990811660011790915560148352928190208054909316909255815192835290517ffd0e0c743dbdd84ef4e7c513db9b7e085970164787288791343fda28575652dd9281900390910190a150565b600a8054604080516020601f6002600019610100600188161502019095169490940493840181900481028201810190925282815260609390929091830182828015610f885780601f10610f5d57610100808354040283529160200191610f88565b600154600160a060020a031681565b600160a060020a038216331415611d2857600080fd5b336000818152600860209081526040808320600160a060020a03871680855290835292819020805460ff1916861515908117909155815190815290519293927f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31929181900390910190a35050565b600160a060020a0381161515611dab57600080fd5b601054600160a060020a03163314611e33576040805160e560020a62461bcd02815260206004820152602660248201527f4e6f7420617070726f76656420746f206368616e67652073696e676c6520637260448201527f6561746f722e0000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b60108054600160a060020a031916600160a060020a0383811691821792839055604051919216907f384c948063df3740539b4b000658c1a22348e7f18c87f808085662e461e48e7190600090a350565b60005460a060020a900460ff1615611e9a57600080fd5b3360009081526014602052604090205460ff1615156001148015611ed357503360009081526016602052604090205460ff161515600114155b1515611f29576040805160e560020a62461bcd02815260206004820152601760248201527f556e617070726f766564204f424f20616464726573732e000000000000000000604482015290519081900360640190fd5b610dbe83838361270d565b600454600160a060020a031681565b81611f4e3382612cf9565b1515611f5957600080fd5b611f648585856110da565b611f708585858561361d565b151561150b57600080fd5b6060611f86826112e9565b1515611f9157600080fd5b6000828152600f602090815260409182902080548351601f6002600019610100600186161502019093169290920491820184900484028101840190945280845290918301828280156120245780601f10611ff957610100808354040283529160200191612024565b820191906000526020600020905b81548152906001019060200180831161200757829003601f168201915b50505050509050919050565b6110d73382612d58565b60146020526000908152604090205460ff1681565b60166020526000908152604090205460ff1681565b600160a060020a03811660009081526016602052604081205460ff16151560011415612092575060006111d1565b61209c8284613770565b1515600114156120ae575060016111d1565b600160a060020a0380841660009081526015602090815260408083209386168352929052205460ff16156120e4575060016111d1565b6120ee8383613831565b90506111d1565b6000805460a060020a900460ff161561210d57600080fd5b61214933878787878080601f01602080910402602001604051908101604052809392919081815260200183838082843750612466945050505050565b9050611ba433828461270d565b600054600160a060020a0316331461216d57600080fd5b600160a060020a038116151561218257600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a360008054600160a060020a031916600160a060020a0392909216919091179055565b600054600160a060020a031633146121f457600080fd5b600160a060020a03811660009081526016602052604090205460ff1615156001141561226a576040805160e560020a62461bcd02815260206004820152601160248201527f416464726573732064697361626c65642e000000000000000000000000000000604482015290519081900360640190fd5b600160a060020a03166000908152601460205260409020805460ff19166001179055565b600254604080517fb577fd73000000000000000000000000000000000000000000000000000000008152600160a060020a038581166004830190815260248301938452855160448401528551600095869593169363b577fd73938993899390926064019060208501908083838c5b838110156123145781810151838201526020016122fc565b50505050905090810190601f1680156123415780820380516001836020036101000a031916815260200191505b509350505050602060405180830381600087803b15801561236157600080fd5b505af1158015612375573d6000803e3d6000fd5b505050506040513d602081101561238b57600080fd5b505160025460408051838152600160a060020a0392831660208281018290529389169282019290925260806060820181815288519183019190915287519495507f01e2312dcdafe7cd3f82579d8c121fdb930d46ef2eb231953a521ac62093e2779486948a938a939092909160a08401919085019080838360005b8381101561241e578181015183820152602001612406565b50505050905090810190601f16801561244b5780820380516001836020036101000a031916815260200191505b509550505050505060405180910390a18091505b5092915050565b600080612473848761385f565b15156124ee576040805160e560020a62461bcd028152602060048201526024808201527f43726561746f7220666f7220636f6c6c656374696f6e206e6f7420617070726f60448201527f7665642e00000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b6002546040517f09242ba2000000000000000000000000000000000000000000000000000000008152600160a060020a038881166004830190815260006024840181905263ffffffff8a1660448501526064840189905260a060848501908152885160a4860152885193909516946309242ba2948c9492938c938c938c93909160c49091019060208501908083838b5b8381101561259657818101518382015260200161257e565b50505050905090810190601f1680156125c35780820380516001836020036101000a031916815260200191505b509650505050505050602060405180830381600087803b1580156125e657600080fd5b505af11580156125fa573d6000803e3d6000fd5b505050506040513d602081101561261057600080fd5b505160025460408051838152600160a060020a039283166020828101829052938b169282019290925263ffffffff8916606082015260006080820181905260a0820189905260e060c0830181815289519184019190915288519596507f794c5cd70604d9d8dc2cbca1f8be65f167e4147b6512541d41e8e410594098a09587958d948d94938d938d93610100840191908501908083838a5b838110156126c05781810151838201526020016126a8565b50505050905090810190601f1680156126ed5780820380516001836020036101000a031916815260200191505b509850505050505050505060405180910390a18091505b50949350505050565b612715613f93565b60006060600080612724613ffe565b600063ffffffff881681106127a9576040805160e560020a62461bcd02815260206004820152603260248201527f4661696c6564207072696e742065646974696f6e2e20204372656174696f6e2060448201527f636f756e74206d757374206265203e20302e0000000000000000000000000000606482015290519081900360840190fd5b61271063ffffffff89161061282e576040805160e560020a62461bcd02815260206004820152602960248201527f43616e6e6f74207072696e74206d6f7265207468616e2031304b20746f6b656e60448201527f73206174206f6e63650000000000000000000000000000000000000000000000606482015290519081900360840190fd5b612837896130c1565b96508660400151955061284e87608001518b61388e565b15156128a4576040805160e560020a62461bcd02815260206004820152601560248201527f43726561746f72206e6f7420617070726f7665642e0000000000000000000000604482015290519081900360640190fd5b6128ad8a6138e9565b1515612929576040805160e560020a62461bcd02815260206004820152602a60248201527f43726561746f72206d757374206d617463682073696e676c652063726561746f60448201527f7220616464726573732e00000000000000000000000000000000000000000000606482015290519081900360840190fd5b866020015163ffffffff1686890163ffffffff1611151515612995576040805160e560020a62461bcd02815260206004820152601660248201527f546f74616c20737570706c792065786365656465642e00000000000000000000604482015290519081900360640190fd5b6129d86040805190810160405280600c81526020017f697066733a2f2f697066732f00000000000000000000000000000000000000008152508860a00151613999565b9450600093505b8763ffffffff168463ffffffff161015612b7757838660010101925060408051908101604052808463ffffffff1681526020018a8152509150612a20613ae8565b9050816011600083815260200190815260200160002060008201518160000160006101000a81548163ffffffff021916908363ffffffff160217905550602082015181600101559050507f775f53e4c75ce0c74e611f7f0bb660e4cd647e0522ef0f8aefd4ecef373c5df9818b85888d6040518086815260200185600160a060020a0316600160a060020a031681526020018463ffffffff1663ffffffff16815260200180602001838152602001828103825284818151815260200191508051906020019080838360005b83811015612b03578181015183820152602001612aeb565b50505050905090810190601f168015612b305780820380516001836020036101000a031916815260200191505b50965050505050505060405180910390a1612b4b8a82613b04565b612b558186613b53565b601354612b6990600163ffffffff613b8616565b6013556001909301926129df565b612b818789613b93565b604080518a815263ffffffff888b0116602082015281517f12d99f5e49ef761c52953e4f9a109827fc3540292ba88c10d309fef470685259929181900390910190a150505050505050505050565b612bd7613f93565b600080612be3856130c1565b9250612bf383608001518561388e565b80612c075750612c07836080015185612064565b1515612c83576040805160e560020a62461bcd02815260206004820152603060248201527f4661696c6564206469676974616c206d65646961206275726e2e202043616c6c60448201527f6572206e6f7420617070726f7665642e00000000000000000000000000000000606482015290519081900360840190fd5b82604001518360200151039150612c9a8383613b93565b8251612ca590613c56565b60408051878152600160a060020a03808816602083015283168183015290519192507f327ecc068f1b41267f69376098f6a50da487e4a4d762d53c01197d6a2f294b3e919081900360600190a15050505050565b600080612d0583611512565b905080600160a060020a031684600160a060020a03161480612d40575083600160a060020a0316612d3584610f93565b600160a060020a0316145b80612d505750612d508185612064565b949350505050565b81600160a060020a0316612d6b82611512565b600160a060020a031614612d7e57600080fd5b600081815260066020526040902054600160a060020a0316156114b45760008181526006602090815260408083208054600160a060020a031916905580518481529051600160a060020a038616927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a35050565b6000806000612e078585613cb5565b6000848152600c6020908152604080832054600160a060020a0389168452600b90925290912054909350612e4290600163ffffffff613d3e16565b600160a060020a0386166000908152600b6020526040902080549193509083908110612e6a57fe5b9060005260206000200154905080600b600087600160a060020a0316600160a060020a0316815260200190815260200160002084815481101515612eaa57fe5b6000918252602080832090910192909255600160a060020a0387168152600b90915260408120805484908110612edc57fe5b6000918252602080832090910192909255600160a060020a0387168152600b90915260409020805490612f13906000198301614015565b506000938452600c6020526040808520859055908452909220555050565b6000612f3d8383613d50565b50600160a060020a039091166000908152600b6020908152604080832080546001810182559084528284208101859055938352600c909152902055565b6000612f8583611512565b905080600160a060020a031682600160a060020a03161480612fc0575081600160a060020a0316612fb584610f93565b600160a060020a0316145b80612fd05750612fd08183612064565b151561304c576040805160e560020a62461bcd02815260206004820152602b60248201527f4661696c656420746f6b656e206275726e2e202043616c6c6572206973206e6f60448201527f7420617070726f7665642e000000000000000000000000000000000000000000606482015290519081900360840190fd5b6130568184613dd4565b6000838152601160209081526040808320805463ffffffff19168155600101929092558151858152600160a060020a0384169181019190915281517f1e8df141f42ed659a8fe7e7c5966cbdf2d240d0c45f4c30cbe02526c618075ef929181900390910190a1505050565b6130c9613f93565b6000806000806000606060006130dd613f93565b600154600160a060020a031615156130f457600080fd5b600254600160a060020a0316151561310b57600080fd5b6131148a613c56565b915081600160a060020a03166355df42758b6040518263ffffffff1660e060020a02815260040180828152602001915050600060405180830381600087803b15801561315f57600080fd5b505af1158015613173573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405260c081101561319c57600080fd5b8151602083015160408401516060850151608086015160a087018051959794969395929491938201926401000000008111156131d757600080fd5b820160208101848111156131ea57600080fd5b815164010000000081118282018710171561320457600080fd5b50506040805160c081018252998a5263ffffffff98891660208b0152979096169688019690965250506060850191909152600160a060020a0316608084015260a0830152509a9950505050505050505050565b61325f613fdf565b600080606061326c613fdf565b600154600160a060020a0316151561328357600080fd5b600254600160a060020a0316151561329a57600080fd5b600254604080517f5a1f3c28000000000000000000000000000000000000000000000000000000008152600481018990529051600160a060020a0390921691635a1f3c289160248082019260009290919082900301818387803b15801561330057600080fd5b505af1158015613314573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052606081101561333d57600080fd5b815160208301516040840180519294919382019264010000000081111561336357600080fd5b8201602081018481111561337657600080fd5b815164010000000081118282018710171561339057600080fd5b505060408051606081018252968752600160a060020a0395909516602087015293850193909352509198975050505050505050565b600160a060020a038083166000908152601260205260409020548116908416158015906133fa5750600160a060020a03831615155b1515613476576040805160e560020a62461bcd02815260206004820152602660248201527f43726561746f72206d7573742062652076616c6964206e6f6e2030783020616460448201527f64726573732e0000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b82600160a060020a031684600160a060020a031614806134a7575080600160a060020a031684600160a060020a0316145b15156134fd576040805160e560020a62461bcd02815260206004820152601460248201527f556e617574686f72697a65642063616c6c65722e000000000000000000000000604482015290519081900360640190fd5b600160a060020a038116151561354057600160a060020a0384811660009081526012602052604090208054600160a060020a0319169184169190911790556135d2565b600160a060020a03848116908216146135a3576040805160e560020a62461bcd02815260206004820152601460248201527f556e617574686f72697a65642063616c6c65722e000000000000000000000000604482015290519081900360640190fd5b600160a060020a0383811660009081526012602052604090208054600160a060020a0319169184169190911790555b60408051600160a060020a0380861682528416602082015281517fde6cfdf21fe76bcb45258138e27bcd332b76941b24d226b5da8dc5f9cd531c3e929181900390910190a150505050565b60008061363285600160a060020a0316613ece565b15156136415760019150612704565b84600160a060020a031663f0b9e5ba8786866040518463ffffffff1660e060020a0281526004018084600160a060020a0316600160a060020a0316815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b838110156136c05781810151838201526020016136a8565b50505050905090810190601f1680156136ed5780820380516001836020036101000a031916815260200191505b50945050505050602060405180830381600087803b15801561370e57600080fd5b505af1158015613722573d6000803e3d6000fd5b505050506040513d602081101561373857600080fd5b5051600160e060020a0319167ff0b9e5ba00000000000000000000000000000000000000000000000000000000149695505050505050565b600454600090600160a060020a0316151561378a57600080fd5b60048054604080517f67d6a7dc000000000000000000000000000000000000000000000000000000008152600160a060020a03878116948201949094528584166024820152905192909116916367d6a7dc916044808201926020929091908290030181600087803b1580156137fe57600080fd5b505af1158015613812573d6000803e3d6000fd5b505050506040513d602081101561382857600080fd5b50519392505050565b600160a060020a03918216600090815260086020908152604080832093909416825291909152205460ff1690565b6000613869613fdf565b831515613879576001915061245f565b61388284613257565b9050612d508160200151845b600160a060020a0380831660009081526012602052604081205490911680156138cd5782600160a060020a031681600160a060020a031614915061245f565b82600160a060020a031684600160a060020a031614915061245f565b6000600160a060020a0382161515613971576040805160e560020a62461bcd02815260206004820152602660248201527f3078302063726561746f722061646472657373657320617265206e6f7420616c60448201527f6c6f7765642e0000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b601054600160a060020a03161580610d65575050601054600160a060020a0391821691161490565b606080606080606060008088955087945084518651016040519080825280601f01601f1916602001820160405280156139dc578160200160208202803883390190505b50935083925060009150600090505b8551811015613a61578581815181101515613a0257fe5b90602001015160f860020a900460f860020a028383806001019450815181101515613a2957fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506001016139eb565b5060005b8451811015613adb578481815181101515613a7c57fe5b90602001015160f860020a900460f860020a028383806001019450815181101515613aa357fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600101613a65565b5090979650505050505050565b601354600090613aff90600163ffffffff613b8616565b905090565b613b0e8282613ed6565b600d80546000838152600e60205260408120829055600182018355919091527fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5015550565b613b5c826112e9565b1515613b6757600080fd5b6000828152600f602090815260409091208251610dbe92840190614039565b818101828110156111d157fe5b600154600090600160a060020a03161515613bad57600080fd5b600254600160a060020a03161515613bc457600080fd5b8251613bcf90613c56565b8351604080517f5160a124000000000000000000000000000000000000000000000000000000008152600481019290925263ffffffff8516602483015251919250600160a060020a03831691635160a1249160448082019260009290919082900301818387803b158015613c4257600080fd5b505af1158015611626573d6000803e3d6000fd5b600154600090600160a060020a03161515613c7057600080fd5b600254600160a060020a03161515613c8757600080fd5b600354821015613ca35750600154600160a060020a0316610d68565b50600254600160a060020a0316610d68565b81600160a060020a0316613cc882611512565b600160a060020a031614613cdb57600080fd5b600160a060020a038216600090815260076020526040902054613d0590600163ffffffff613d3e16565b600160a060020a039092166000908152600760209081526040808320949094559181526005909152208054600160a060020a0319169055565b600082821115613d4a57fe5b50900390565b600081815260056020526040902054600160a060020a031615613d7257600080fd5b60008181526005602090815260408083208054600160a060020a031916600160a060020a03871690811790915583526007909152902054613db4906001613b86565b600160a060020a0390921660009081526007602052604090209190915550565b6000806000613de38585613f3a565b6000848152600f60205260409020546002600019610100600184161502019091160415613e21576000848152600f60205260408120613e21916140b7565b6000848152600e6020526040902054600d54909350613e4790600163ffffffff613d3e16565b9150600d82815481101515613e5857fe5b9060005260206000200154905080600d84815481101515613e7557fe5b6000918252602082200191909155600d805484908110613e9157fe5b600091825260209091200155600d805490613eb0906000198301614015565b506000938452600e6020526040808520859055908452909220555050565b6000903b1190565b600160a060020a0382161515613eeb57600080fd5b613ef58282612f31565b604080518281529051600160a060020a038416916000917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9181900360200190a35050565b613f448282612d58565b613f4e8282612df8565b604080518281529051600091600160a060020a038516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9181900360200190a35050565b60c06040519081016040528060008152602001600063ffffffff168152602001600063ffffffff168152602001600081526020016000600160a060020a03168152602001606081525090565b6040805160608181018352600080835260208301529181019190915290565b604080518082019091526000808252602082015290565b815481835581811115610dbe57600083815260209020610dbe9181019083016140f7565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061407a57805160ff19168380011785556140a7565b828001600101855582156140a7579182015b828111156140a757825182559160200191906001019061408c565b506140b39291506140f7565b5090565b50805460018160011615610100020316600290046000825580601f106140dd57506110d7565b601f0160209004906000526020600020908101906110d791905b610f9091905b808211156140b357600081556001016140fd5600a165627a7a7230582062b54530f53f624d5d4235eb682b3583d6891bfa3d29a91400dfbfe18040c85e0029"

// DeployDigitalMediaCore deploys a new Ethereum contract, binding an instance of DigitalMediaCore to it.
func DeployDigitalMediaCore(auth *bind.TransactOpts, backend bind.ContractBackend, _tokenName string, _tokenSymbol string, _tokenIdStartingCounter *big.Int, _dmsAddress common.Address, _crsAddress common.Address) (common.Address, *types.Transaction, *DigitalMediaCore, error) {
	parsed, err := abi.JSON(strings.NewReader(DigitalMediaCoreABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(DigitalMediaCoreBin), backend, _tokenName, _tokenSymbol, _tokenIdStartingCounter, _dmsAddress, _crsAddress)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &DigitalMediaCore{DigitalMediaCoreCaller: DigitalMediaCoreCaller{contract: contract}, DigitalMediaCoreTransactor: DigitalMediaCoreTransactor{contract: contract}, DigitalMediaCoreFilterer: DigitalMediaCoreFilterer{contract: contract}}, nil
}

// DigitalMediaCore is an auto generated Go binding around an Ethereum contract.
type DigitalMediaCore struct {
	DigitalMediaCoreCaller     // Read-only binding to the contract
	DigitalMediaCoreTransactor // Write-only binding to the contract
	DigitalMediaCoreFilterer   // Log filterer for contract events
}

// DigitalMediaCoreCaller is an auto generated read-only Go binding around an Ethereum contract.
type DigitalMediaCoreCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaCoreTransactor is an auto generated write-only Go binding around an Ethereum contract.
type DigitalMediaCoreTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaCoreFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type DigitalMediaCoreFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaCoreSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type DigitalMediaCoreSession struct {
	Contract     *DigitalMediaCore // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// DigitalMediaCoreCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type DigitalMediaCoreCallerSession struct {
	Contract *DigitalMediaCoreCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// DigitalMediaCoreTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type DigitalMediaCoreTransactorSession struct {
	Contract     *DigitalMediaCoreTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// DigitalMediaCoreRaw is an auto generated low-level Go binding around an Ethereum contract.
type DigitalMediaCoreRaw struct {
	Contract *DigitalMediaCore // Generic contract binding to access the raw methods on
}

// DigitalMediaCoreCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type DigitalMediaCoreCallerRaw struct {
	Contract *DigitalMediaCoreCaller // Generic read-only contract binding to access the raw methods on
}

// DigitalMediaCoreTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type DigitalMediaCoreTransactorRaw struct {
	Contract *DigitalMediaCoreTransactor // Generic write-only contract binding to access the raw methods on
}

// NewDigitalMediaCore creates a new instance of DigitalMediaCore, bound to a specific deployed contract.
func NewDigitalMediaCore(address common.Address, backend bind.ContractBackend) (*DigitalMediaCore, error) {
	contract, err := bindDigitalMediaCore(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCore{DigitalMediaCoreCaller: DigitalMediaCoreCaller{contract: contract}, DigitalMediaCoreTransactor: DigitalMediaCoreTransactor{contract: contract}, DigitalMediaCoreFilterer: DigitalMediaCoreFilterer{contract: contract}}, nil
}

// NewDigitalMediaCoreCaller creates a new read-only instance of DigitalMediaCore, bound to a specific deployed contract.
func NewDigitalMediaCoreCaller(address common.Address, caller bind.ContractCaller) (*DigitalMediaCoreCaller, error) {
	contract, err := bindDigitalMediaCore(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreCaller{contract: contract}, nil
}

// NewDigitalMediaCoreTransactor creates a new write-only instance of DigitalMediaCore, bound to a specific deployed contract.
func NewDigitalMediaCoreTransactor(address common.Address, transactor bind.ContractTransactor) (*DigitalMediaCoreTransactor, error) {
	contract, err := bindDigitalMediaCore(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreTransactor{contract: contract}, nil
}

// NewDigitalMediaCoreFilterer creates a new log filterer instance of DigitalMediaCore, bound to a specific deployed contract.
func NewDigitalMediaCoreFilterer(address common.Address, filterer bind.ContractFilterer) (*DigitalMediaCoreFilterer, error) {
	contract, err := bindDigitalMediaCore(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreFilterer{contract: contract}, nil
}

// bindDigitalMediaCore binds a generic wrapper to an already deployed contract.
func bindDigitalMediaCore(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(DigitalMediaCoreABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DigitalMediaCore *DigitalMediaCoreRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _DigitalMediaCore.Contract.DigitalMediaCoreCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DigitalMediaCore *DigitalMediaCoreRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.DigitalMediaCoreTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DigitalMediaCore *DigitalMediaCoreRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.DigitalMediaCoreTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DigitalMediaCore *DigitalMediaCoreCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _DigitalMediaCore.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DigitalMediaCore *DigitalMediaCoreTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DigitalMediaCore *DigitalMediaCoreTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.contract.Transact(opts, method, params...)
}

// ApprovedCreators is a free data retrieval call binding the contract method 0x55232467.
//
// Solidity: function approvedCreators(address ) constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCaller) ApprovedCreators(opts *bind.CallOpts, arg0 common.Address) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "approvedCreators", arg0)
	return *ret0, err
}

// ApprovedCreators is a free data retrieval call binding the contract method 0x55232467.
//
// Solidity: function approvedCreators(address ) constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreSession) ApprovedCreators(arg0 common.Address) (common.Address, error) {
	return _DigitalMediaCore.Contract.ApprovedCreators(&_DigitalMediaCore.CallOpts, arg0)
}

// ApprovedCreators is a free data retrieval call binding the contract method 0x55232467.
//
// Solidity: function approvedCreators(address ) constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) ApprovedCreators(arg0 common.Address) (common.Address, error) {
	return _DigitalMediaCore.Contract.ApprovedCreators(&_DigitalMediaCore.CallOpts, arg0)
}

// ApprovedTokenCreators is a free data retrieval call binding the contract method 0xd70f575f.
//
// Solidity: function approvedTokenCreators(address ) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreCaller) ApprovedTokenCreators(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "approvedTokenCreators", arg0)
	return *ret0, err
}

// ApprovedTokenCreators is a free data retrieval call binding the contract method 0xd70f575f.
//
// Solidity: function approvedTokenCreators(address ) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreSession) ApprovedTokenCreators(arg0 common.Address) (bool, error) {
	return _DigitalMediaCore.Contract.ApprovedTokenCreators(&_DigitalMediaCore.CallOpts, arg0)
}

// ApprovedTokenCreators is a free data retrieval call binding the contract method 0xd70f575f.
//
// Solidity: function approvedTokenCreators(address ) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) ApprovedTokenCreators(arg0 common.Address) (bool, error) {
	return _DigitalMediaCore.Contract.ApprovedTokenCreators(&_DigitalMediaCore.CallOpts, arg0)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreCaller) BalanceOf(opts *bind.CallOpts, _owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "balanceOf", _owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _DigitalMediaCore.Contract.BalanceOf(&_DigitalMediaCore.CallOpts, _owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _DigitalMediaCore.Contract.BalanceOf(&_DigitalMediaCore.CallOpts, _owner)
}

// CreatorRegistryStore is a free data retrieval call binding the contract method 0xb39ba60a.
//
// Solidity: function creatorRegistryStore() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCaller) CreatorRegistryStore(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "creatorRegistryStore")
	return *ret0, err
}

// CreatorRegistryStore is a free data retrieval call binding the contract method 0xb39ba60a.
//
// Solidity: function creatorRegistryStore() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreSession) CreatorRegistryStore() (common.Address, error) {
	return _DigitalMediaCore.Contract.CreatorRegistryStore(&_DigitalMediaCore.CallOpts)
}

// CreatorRegistryStore is a free data retrieval call binding the contract method 0xb39ba60a.
//
// Solidity: function creatorRegistryStore() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) CreatorRegistryStore() (common.Address, error) {
	return _DigitalMediaCore.Contract.CreatorRegistryStore(&_DigitalMediaCore.CallOpts)
}

// CurrentDigitalMediaStore is a free data retrieval call binding the contract method 0x1b284e75.
//
// Solidity: function currentDigitalMediaStore() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCaller) CurrentDigitalMediaStore(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "currentDigitalMediaStore")
	return *ret0, err
}

// CurrentDigitalMediaStore is a free data retrieval call binding the contract method 0x1b284e75.
//
// Solidity: function currentDigitalMediaStore() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreSession) CurrentDigitalMediaStore() (common.Address, error) {
	return _DigitalMediaCore.Contract.CurrentDigitalMediaStore(&_DigitalMediaCore.CallOpts)
}

// CurrentDigitalMediaStore is a free data retrieval call binding the contract method 0x1b284e75.
//
// Solidity: function currentDigitalMediaStore() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) CurrentDigitalMediaStore() (common.Address, error) {
	return _DigitalMediaCore.Contract.CurrentDigitalMediaStore(&_DigitalMediaCore.CallOpts)
}

// CurrentStartingDigitalMediaId is a free data retrieval call binding the contract method 0x0154788d.
//
// Solidity: function currentStartingDigitalMediaId() constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreCaller) CurrentStartingDigitalMediaId(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "currentStartingDigitalMediaId")
	return *ret0, err
}

// CurrentStartingDigitalMediaId is a free data retrieval call binding the contract method 0x0154788d.
//
// Solidity: function currentStartingDigitalMediaId() constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreSession) CurrentStartingDigitalMediaId() (*big.Int, error) {
	return _DigitalMediaCore.Contract.CurrentStartingDigitalMediaId(&_DigitalMediaCore.CallOpts)
}

// CurrentStartingDigitalMediaId is a free data retrieval call binding the contract method 0x0154788d.
//
// Solidity: function currentStartingDigitalMediaId() constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) CurrentStartingDigitalMediaId() (*big.Int, error) {
	return _DigitalMediaCore.Contract.CurrentStartingDigitalMediaId(&_DigitalMediaCore.CallOpts)
}

// DisabledOboOperators is a free data retrieval call binding the contract method 0xe158386d.
//
// Solidity: function disabledOboOperators(address ) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreCaller) DisabledOboOperators(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "disabledOboOperators", arg0)
	return *ret0, err
}

// DisabledOboOperators is a free data retrieval call binding the contract method 0xe158386d.
//
// Solidity: function disabledOboOperators(address ) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreSession) DisabledOboOperators(arg0 common.Address) (bool, error) {
	return _DigitalMediaCore.Contract.DisabledOboOperators(&_DigitalMediaCore.CallOpts, arg0)
}

// DisabledOboOperators is a free data retrieval call binding the contract method 0xe158386d.
//
// Solidity: function disabledOboOperators(address ) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) DisabledOboOperators(arg0 common.Address) (bool, error) {
	return _DigitalMediaCore.Contract.DisabledOboOperators(&_DigitalMediaCore.CallOpts, arg0)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreCaller) Exists(opts *bind.CallOpts, _tokenId *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "exists", _tokenId)
	return *ret0, err
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreSession) Exists(_tokenId *big.Int) (bool, error) {
	return _DigitalMediaCore.Contract.Exists(&_DigitalMediaCore.CallOpts, _tokenId)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) Exists(_tokenId *big.Int) (bool, error) {
	return _DigitalMediaCore.Contract.Exists(&_DigitalMediaCore.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCaller) GetApproved(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "getApproved", _tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _DigitalMediaCore.Contract.GetApproved(&_DigitalMediaCore.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _DigitalMediaCore.Contract.GetApproved(&_DigitalMediaCore.CallOpts, _tokenId)
}

// GetCollection is a free data retrieval call binding the contract method 0x5a1f3c28.
//
// Solidity: function getCollection(uint256 _id) constant returns(uint256 id, address creator, string metadataPath)
func (_DigitalMediaCore *DigitalMediaCoreCaller) GetCollection(opts *bind.CallOpts, _id *big.Int) (struct {
	Id           *big.Int
	Creator      common.Address
	MetadataPath string
}, error) {
	ret := new(struct {
		Id           *big.Int
		Creator      common.Address
		MetadataPath string
	})
	out := ret
	err := _DigitalMediaCore.contract.Call(opts, out, "getCollection", _id)
	return *ret, err
}

// GetCollection is a free data retrieval call binding the contract method 0x5a1f3c28.
//
// Solidity: function getCollection(uint256 _id) constant returns(uint256 id, address creator, string metadataPath)
func (_DigitalMediaCore *DigitalMediaCoreSession) GetCollection(_id *big.Int) (struct {
	Id           *big.Int
	Creator      common.Address
	MetadataPath string
}, error) {
	return _DigitalMediaCore.Contract.GetCollection(&_DigitalMediaCore.CallOpts, _id)
}

// GetCollection is a free data retrieval call binding the contract method 0x5a1f3c28.
//
// Solidity: function getCollection(uint256 _id) constant returns(uint256 id, address creator, string metadataPath)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) GetCollection(_id *big.Int) (struct {
	Id           *big.Int
	Creator      common.Address
	MetadataPath string
}, error) {
	return _DigitalMediaCore.Contract.GetCollection(&_DigitalMediaCore.CallOpts, _id)
}

// GetDigitalMedia is a free data retrieval call binding the contract method 0x55df4275.
//
// Solidity: function getDigitalMedia(uint256 _id) constant returns(uint256 id, uint32 totalSupply, uint32 printIndex, uint256 collectionId, address creator, string metadataPath)
func (_DigitalMediaCore *DigitalMediaCoreCaller) GetDigitalMedia(opts *bind.CallOpts, _id *big.Int) (struct {
	Id           *big.Int
	TotalSupply  uint32
	PrintIndex   uint32
	CollectionId *big.Int
	Creator      common.Address
	MetadataPath string
}, error) {
	ret := new(struct {
		Id           *big.Int
		TotalSupply  uint32
		PrintIndex   uint32
		CollectionId *big.Int
		Creator      common.Address
		MetadataPath string
	})
	out := ret
	err := _DigitalMediaCore.contract.Call(opts, out, "getDigitalMedia", _id)
	return *ret, err
}

// GetDigitalMedia is a free data retrieval call binding the contract method 0x55df4275.
//
// Solidity: function getDigitalMedia(uint256 _id) constant returns(uint256 id, uint32 totalSupply, uint32 printIndex, uint256 collectionId, address creator, string metadataPath)
func (_DigitalMediaCore *DigitalMediaCoreSession) GetDigitalMedia(_id *big.Int) (struct {
	Id           *big.Int
	TotalSupply  uint32
	PrintIndex   uint32
	CollectionId *big.Int
	Creator      common.Address
	MetadataPath string
}, error) {
	return _DigitalMediaCore.Contract.GetDigitalMedia(&_DigitalMediaCore.CallOpts, _id)
}

// GetDigitalMedia is a free data retrieval call binding the contract method 0x55df4275.
//
// Solidity: function getDigitalMedia(uint256 _id) constant returns(uint256 id, uint32 totalSupply, uint32 printIndex, uint256 collectionId, address creator, string metadataPath)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) GetDigitalMedia(_id *big.Int) (struct {
	Id           *big.Int
	TotalSupply  uint32
	PrintIndex   uint32
	CollectionId *big.Int
	Creator      common.Address
	MetadataPath string
}, error) {
	return _DigitalMediaCore.Contract.GetDigitalMedia(&_DigitalMediaCore.CallOpts, _id)
}

// GetDigitalMediaRelease is a free data retrieval call binding the contract method 0x8a603bdf.
//
// Solidity: function getDigitalMediaRelease(uint256 _id) constant returns(uint256 id, uint32 printEdition, uint256 digitalMediaId)
func (_DigitalMediaCore *DigitalMediaCoreCaller) GetDigitalMediaRelease(opts *bind.CallOpts, _id *big.Int) (struct {
	Id             *big.Int
	PrintEdition   uint32
	DigitalMediaId *big.Int
}, error) {
	ret := new(struct {
		Id             *big.Int
		PrintEdition   uint32
		DigitalMediaId *big.Int
	})
	out := ret
	err := _DigitalMediaCore.contract.Call(opts, out, "getDigitalMediaRelease", _id)
	return *ret, err
}

// GetDigitalMediaRelease is a free data retrieval call binding the contract method 0x8a603bdf.
//
// Solidity: function getDigitalMediaRelease(uint256 _id) constant returns(uint256 id, uint32 printEdition, uint256 digitalMediaId)
func (_DigitalMediaCore *DigitalMediaCoreSession) GetDigitalMediaRelease(_id *big.Int) (struct {
	Id             *big.Int
	PrintEdition   uint32
	DigitalMediaId *big.Int
}, error) {
	return _DigitalMediaCore.Contract.GetDigitalMediaRelease(&_DigitalMediaCore.CallOpts, _id)
}

// GetDigitalMediaRelease is a free data retrieval call binding the contract method 0x8a603bdf.
//
// Solidity: function getDigitalMediaRelease(uint256 _id) constant returns(uint256 id, uint32 printEdition, uint256 digitalMediaId)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) GetDigitalMediaRelease(_id *big.Int) (struct {
	Id             *big.Int
	PrintEdition   uint32
	DigitalMediaId *big.Int
}, error) {
	return _DigitalMediaCore.Contract.GetDigitalMediaRelease(&_DigitalMediaCore.CallOpts, _id)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreCaller) IsApprovedForAll(opts *bind.CallOpts, _owner common.Address, _operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "isApprovedForAll", _owner, _operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _DigitalMediaCore.Contract.IsApprovedForAll(&_DigitalMediaCore.CallOpts, _owner, _operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _DigitalMediaCore.Contract.IsApprovedForAll(&_DigitalMediaCore.CallOpts, _owner, _operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_DigitalMediaCore *DigitalMediaCoreCaller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_DigitalMediaCore *DigitalMediaCoreSession) Name() (string, error) {
	return _DigitalMediaCore.Contract.Name(&_DigitalMediaCore.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) Name() (string, error) {
	return _DigitalMediaCore.Contract.Name(&_DigitalMediaCore.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreSession) Owner() (common.Address, error) {
	return _DigitalMediaCore.Contract.Owner(&_DigitalMediaCore.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) Owner() (common.Address, error) {
	return _DigitalMediaCore.Contract.Owner(&_DigitalMediaCore.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCaller) OwnerOf(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "ownerOf", _tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _DigitalMediaCore.Contract.OwnerOf(&_DigitalMediaCore.CallOpts, _tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _DigitalMediaCore.Contract.OwnerOf(&_DigitalMediaCore.CallOpts, _tokenId)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "paused")
	return *ret0, err
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreSession) Paused() (bool, error) {
	return _DigitalMediaCore.Contract.Paused(&_DigitalMediaCore.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) Paused() (bool, error) {
	return _DigitalMediaCore.Contract.Paused(&_DigitalMediaCore.CallOpts)
}

// SingleCreatorAddress is a free data retrieval call binding the contract method 0x147ca2af.
//
// Solidity: function singleCreatorAddress() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCaller) SingleCreatorAddress(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "singleCreatorAddress")
	return *ret0, err
}

// SingleCreatorAddress is a free data retrieval call binding the contract method 0x147ca2af.
//
// Solidity: function singleCreatorAddress() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreSession) SingleCreatorAddress() (common.Address, error) {
	return _DigitalMediaCore.Contract.SingleCreatorAddress(&_DigitalMediaCore.CallOpts)
}

// SingleCreatorAddress is a free data retrieval call binding the contract method 0x147ca2af.
//
// Solidity: function singleCreatorAddress() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) SingleCreatorAddress() (common.Address, error) {
	return _DigitalMediaCore.Contract.SingleCreatorAddress(&_DigitalMediaCore.CallOpts)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 _interfaceID) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreCaller) SupportsInterface(opts *bind.CallOpts, _interfaceID [4]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "supportsInterface", _interfaceID)
	return *ret0, err
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 _interfaceID) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreSession) SupportsInterface(_interfaceID [4]byte) (bool, error) {
	return _DigitalMediaCore.Contract.SupportsInterface(&_DigitalMediaCore.CallOpts, _interfaceID)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 _interfaceID) constant returns(bool)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) SupportsInterface(_interfaceID [4]byte) (bool, error) {
	return _DigitalMediaCore.Contract.SupportsInterface(&_DigitalMediaCore.CallOpts, _interfaceID)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_DigitalMediaCore *DigitalMediaCoreCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_DigitalMediaCore *DigitalMediaCoreSession) Symbol() (string, error) {
	return _DigitalMediaCore.Contract.Symbol(&_DigitalMediaCore.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) Symbol() (string, error) {
	return _DigitalMediaCore.Contract.Symbol(&_DigitalMediaCore.CallOpts)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreCaller) TokenByIndex(opts *bind.CallOpts, _index *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "tokenByIndex", _index)
	return *ret0, err
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreSession) TokenByIndex(_index *big.Int) (*big.Int, error) {
	return _DigitalMediaCore.Contract.TokenByIndex(&_DigitalMediaCore.CallOpts, _index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) TokenByIndex(_index *big.Int) (*big.Int, error) {
	return _DigitalMediaCore.Contract.TokenByIndex(&_DigitalMediaCore.CallOpts, _index)
}

// TokenIdToDigitalMediaRelease is a free data retrieval call binding the contract method 0x3db57cbe.
//
// Solidity: function tokenIdToDigitalMediaRelease(uint256 ) constant returns(uint32 printEdition, uint256 digitalMediaId)
func (_DigitalMediaCore *DigitalMediaCoreCaller) TokenIdToDigitalMediaRelease(opts *bind.CallOpts, arg0 *big.Int) (struct {
	PrintEdition   uint32
	DigitalMediaId *big.Int
}, error) {
	ret := new(struct {
		PrintEdition   uint32
		DigitalMediaId *big.Int
	})
	out := ret
	err := _DigitalMediaCore.contract.Call(opts, out, "tokenIdToDigitalMediaRelease", arg0)
	return *ret, err
}

// TokenIdToDigitalMediaRelease is a free data retrieval call binding the contract method 0x3db57cbe.
//
// Solidity: function tokenIdToDigitalMediaRelease(uint256 ) constant returns(uint32 printEdition, uint256 digitalMediaId)
func (_DigitalMediaCore *DigitalMediaCoreSession) TokenIdToDigitalMediaRelease(arg0 *big.Int) (struct {
	PrintEdition   uint32
	DigitalMediaId *big.Int
}, error) {
	return _DigitalMediaCore.Contract.TokenIdToDigitalMediaRelease(&_DigitalMediaCore.CallOpts, arg0)
}

// TokenIdToDigitalMediaRelease is a free data retrieval call binding the contract method 0x3db57cbe.
//
// Solidity: function tokenIdToDigitalMediaRelease(uint256 ) constant returns(uint32 printEdition, uint256 digitalMediaId)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) TokenIdToDigitalMediaRelease(arg0 *big.Int) (struct {
	PrintEdition   uint32
	DigitalMediaId *big.Int
}, error) {
	return _DigitalMediaCore.Contract.TokenIdToDigitalMediaRelease(&_DigitalMediaCore.CallOpts, arg0)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, _owner common.Address, _index *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "tokenOfOwnerByIndex", _owner, _index)
	return *ret0, err
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreSession) TokenOfOwnerByIndex(_owner common.Address, _index *big.Int) (*big.Int, error) {
	return _DigitalMediaCore.Contract.TokenOfOwnerByIndex(&_DigitalMediaCore.CallOpts, _owner, _index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) TokenOfOwnerByIndex(_owner common.Address, _index *big.Int) (*big.Int, error) {
	return _DigitalMediaCore.Contract.TokenOfOwnerByIndex(&_DigitalMediaCore.CallOpts, _owner, _index)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_DigitalMediaCore *DigitalMediaCoreCaller) TokenURI(opts *bind.CallOpts, _tokenId *big.Int) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "tokenURI", _tokenId)
	return *ret0, err
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_DigitalMediaCore *DigitalMediaCoreSession) TokenURI(_tokenId *big.Int) (string, error) {
	return _DigitalMediaCore.Contract.TokenURI(&_DigitalMediaCore.CallOpts, _tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) TokenURI(_tokenId *big.Int) (string, error) {
	return _DigitalMediaCore.Contract.TokenURI(&_DigitalMediaCore.CallOpts, _tokenId)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreSession) TotalSupply() (*big.Int, error) {
	return _DigitalMediaCore.Contract.TotalSupply(&_DigitalMediaCore.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) TotalSupply() (*big.Int, error) {
	return _DigitalMediaCore.Contract.TotalSupply(&_DigitalMediaCore.CallOpts)
}

// V1DigitalMediaStore is a free data retrieval call binding the contract method 0xa0f01e08.
//
// Solidity: function v1DigitalMediaStore() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCaller) V1DigitalMediaStore(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaCore.contract.Call(opts, out, "v1DigitalMediaStore")
	return *ret0, err
}

// V1DigitalMediaStore is a free data retrieval call binding the contract method 0xa0f01e08.
//
// Solidity: function v1DigitalMediaStore() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreSession) V1DigitalMediaStore() (common.Address, error) {
	return _DigitalMediaCore.Contract.V1DigitalMediaStore(&_DigitalMediaCore.CallOpts)
}

// V1DigitalMediaStore is a free data retrieval call binding the contract method 0xa0f01e08.
//
// Solidity: function v1DigitalMediaStore() constant returns(address)
func (_DigitalMediaCore *DigitalMediaCoreCallerSession) V1DigitalMediaStore() (common.Address, error) {
	return _DigitalMediaCore.Contract.V1DigitalMediaStore(&_DigitalMediaCore.CallOpts)
}

// AddApprovedTokenCreator is a paid mutator transaction binding the contract method 0xfafa8a4b.
//
// Solidity: function addApprovedTokenCreator(address _creatorAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) AddApprovedTokenCreator(opts *bind.TransactOpts, _creatorAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "addApprovedTokenCreator", _creatorAddress)
}

// AddApprovedTokenCreator is a paid mutator transaction binding the contract method 0xfafa8a4b.
//
// Solidity: function addApprovedTokenCreator(address _creatorAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) AddApprovedTokenCreator(_creatorAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.AddApprovedTokenCreator(&_DigitalMediaCore.TransactOpts, _creatorAddress)
}

// AddApprovedTokenCreator is a paid mutator transaction binding the contract method 0xfafa8a4b.
//
// Solidity: function addApprovedTokenCreator(address _creatorAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) AddApprovedTokenCreator(_creatorAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.AddApprovedTokenCreator(&_DigitalMediaCore.TransactOpts, _creatorAddress)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) Approve(opts *bind.TransactOpts, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "approve", _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.Approve(&_DigitalMediaCore.TransactOpts, _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.Approve(&_DigitalMediaCore.TransactOpts, _to, _tokenId)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) Burn(opts *bind.TransactOpts, tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "burn", tokenId)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) Burn(tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.Burn(&_DigitalMediaCore.TransactOpts, tokenId)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) Burn(tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.Burn(&_DigitalMediaCore.TransactOpts, tokenId)
}

// BurnDigitalMedia is a paid mutator transaction binding the contract method 0x23077f58.
//
// Solidity: function burnDigitalMedia(uint256 _digitalMediaId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) BurnDigitalMedia(opts *bind.TransactOpts, _digitalMediaId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "burnDigitalMedia", _digitalMediaId)
}

// BurnDigitalMedia is a paid mutator transaction binding the contract method 0x23077f58.
//
// Solidity: function burnDigitalMedia(uint256 _digitalMediaId) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) BurnDigitalMedia(_digitalMediaId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.BurnDigitalMedia(&_DigitalMediaCore.TransactOpts, _digitalMediaId)
}

// BurnDigitalMedia is a paid mutator transaction binding the contract method 0x23077f58.
//
// Solidity: function burnDigitalMedia(uint256 _digitalMediaId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) BurnDigitalMedia(_digitalMediaId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.BurnDigitalMedia(&_DigitalMediaCore.TransactOpts, _digitalMediaId)
}

// BurnToken is a paid mutator transaction binding the contract method 0x7b47ec1a.
//
// Solidity: function burnToken(uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) BurnToken(opts *bind.TransactOpts, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "burnToken", _tokenId)
}

// BurnToken is a paid mutator transaction binding the contract method 0x7b47ec1a.
//
// Solidity: function burnToken(uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) BurnToken(_tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.BurnToken(&_DigitalMediaCore.TransactOpts, _tokenId)
}

// BurnToken is a paid mutator transaction binding the contract method 0x7b47ec1a.
//
// Solidity: function burnToken(uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) BurnToken(_tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.BurnToken(&_DigitalMediaCore.TransactOpts, _tokenId)
}

// ChangeCreator is a paid mutator transaction binding the contract method 0x5cf09fee.
//
// Solidity: function changeCreator(address _creator, address _newCreator) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) ChangeCreator(opts *bind.TransactOpts, _creator common.Address, _newCreator common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "changeCreator", _creator, _newCreator)
}

// ChangeCreator is a paid mutator transaction binding the contract method 0x5cf09fee.
//
// Solidity: function changeCreator(address _creator, address _newCreator) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) ChangeCreator(_creator common.Address, _newCreator common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.ChangeCreator(&_DigitalMediaCore.TransactOpts, _creator, _newCreator)
}

// ChangeCreator is a paid mutator transaction binding the contract method 0x5cf09fee.
//
// Solidity: function changeCreator(address _creator, address _newCreator) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) ChangeCreator(_creator common.Address, _newCreator common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.ChangeCreator(&_DigitalMediaCore.TransactOpts, _creator, _newCreator)
}

// ChangeSingleCreator is a paid mutator transaction binding the contract method 0xa7df572c.
//
// Solidity: function changeSingleCreator(address _newCreatorAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) ChangeSingleCreator(opts *bind.TransactOpts, _newCreatorAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "changeSingleCreator", _newCreatorAddress)
}

// ChangeSingleCreator is a paid mutator transaction binding the contract method 0xa7df572c.
//
// Solidity: function changeSingleCreator(address _newCreatorAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) ChangeSingleCreator(_newCreatorAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.ChangeSingleCreator(&_DigitalMediaCore.TransactOpts, _newCreatorAddress)
}

// ChangeSingleCreator is a paid mutator transaction binding the contract method 0xa7df572c.
//
// Solidity: function changeSingleCreator(address _newCreatorAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) ChangeSingleCreator(_newCreatorAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.ChangeSingleCreator(&_DigitalMediaCore.TransactOpts, _newCreatorAddress)
}

// CreateCollection is a paid mutator transaction binding the contract method 0x059dfe13.
//
// Solidity: function createCollection(string _metadataPath) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) CreateCollection(opts *bind.TransactOpts, _metadataPath string) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "createCollection", _metadataPath)
}

// CreateCollection is a paid mutator transaction binding the contract method 0x059dfe13.
//
// Solidity: function createCollection(string _metadataPath) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) CreateCollection(_metadataPath string) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.CreateCollection(&_DigitalMediaCore.TransactOpts, _metadataPath)
}

// CreateCollection is a paid mutator transaction binding the contract method 0x059dfe13.
//
// Solidity: function createCollection(string _metadataPath) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) CreateCollection(_metadataPath string) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.CreateCollection(&_DigitalMediaCore.TransactOpts, _metadataPath)
}

// CreateDigitalMedia is a paid mutator transaction binding the contract method 0x603417fb.
//
// Solidity: function createDigitalMedia(uint32 _totalSupply, uint256 _collectionId, string _metadataPath) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) CreateDigitalMedia(opts *bind.TransactOpts, _totalSupply uint32, _collectionId *big.Int, _metadataPath string) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "createDigitalMedia", _totalSupply, _collectionId, _metadataPath)
}

// CreateDigitalMedia is a paid mutator transaction binding the contract method 0x603417fb.
//
// Solidity: function createDigitalMedia(uint32 _totalSupply, uint256 _collectionId, string _metadataPath) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) CreateDigitalMedia(_totalSupply uint32, _collectionId *big.Int, _metadataPath string) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.CreateDigitalMedia(&_DigitalMediaCore.TransactOpts, _totalSupply, _collectionId, _metadataPath)
}

// CreateDigitalMedia is a paid mutator transaction binding the contract method 0x603417fb.
//
// Solidity: function createDigitalMedia(uint32 _totalSupply, uint256 _collectionId, string _metadataPath) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) CreateDigitalMedia(_totalSupply uint32, _collectionId *big.Int, _metadataPath string) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.CreateDigitalMedia(&_DigitalMediaCore.TransactOpts, _totalSupply, _collectionId, _metadataPath)
}

// CreateDigitalMediaAndReleases is a paid mutator transaction binding the contract method 0xeca211e3.
//
// Solidity: function createDigitalMediaAndReleases(uint32 _totalSupply, uint256 _collectionId, string _metadataPath, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) CreateDigitalMediaAndReleases(opts *bind.TransactOpts, _totalSupply uint32, _collectionId *big.Int, _metadataPath string, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "createDigitalMediaAndReleases", _totalSupply, _collectionId, _metadataPath, _numReleases)
}

// CreateDigitalMediaAndReleases is a paid mutator transaction binding the contract method 0xeca211e3.
//
// Solidity: function createDigitalMediaAndReleases(uint32 _totalSupply, uint256 _collectionId, string _metadataPath, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) CreateDigitalMediaAndReleases(_totalSupply uint32, _collectionId *big.Int, _metadataPath string, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.CreateDigitalMediaAndReleases(&_DigitalMediaCore.TransactOpts, _totalSupply, _collectionId, _metadataPath, _numReleases)
}

// CreateDigitalMediaAndReleases is a paid mutator transaction binding the contract method 0xeca211e3.
//
// Solidity: function createDigitalMediaAndReleases(uint32 _totalSupply, uint256 _collectionId, string _metadataPath, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) CreateDigitalMediaAndReleases(_totalSupply uint32, _collectionId *big.Int, _metadataPath string, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.CreateDigitalMediaAndReleases(&_DigitalMediaCore.TransactOpts, _totalSupply, _collectionId, _metadataPath, _numReleases)
}

// CreateDigitalMediaAndReleasesInNewCollection is a paid mutator transaction binding the contract method 0x8b40e8aa.
//
// Solidity: function createDigitalMediaAndReleasesInNewCollection(uint32 _totalSupply, string _digitalMediaMetadataPath, string _collectionMetadataPath, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) CreateDigitalMediaAndReleasesInNewCollection(opts *bind.TransactOpts, _totalSupply uint32, _digitalMediaMetadataPath string, _collectionMetadataPath string, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "createDigitalMediaAndReleasesInNewCollection", _totalSupply, _digitalMediaMetadataPath, _collectionMetadataPath, _numReleases)
}

// CreateDigitalMediaAndReleasesInNewCollection is a paid mutator transaction binding the contract method 0x8b40e8aa.
//
// Solidity: function createDigitalMediaAndReleasesInNewCollection(uint32 _totalSupply, string _digitalMediaMetadataPath, string _collectionMetadataPath, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) CreateDigitalMediaAndReleasesInNewCollection(_totalSupply uint32, _digitalMediaMetadataPath string, _collectionMetadataPath string, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.CreateDigitalMediaAndReleasesInNewCollection(&_DigitalMediaCore.TransactOpts, _totalSupply, _digitalMediaMetadataPath, _collectionMetadataPath, _numReleases)
}

// CreateDigitalMediaAndReleasesInNewCollection is a paid mutator transaction binding the contract method 0x8b40e8aa.
//
// Solidity: function createDigitalMediaAndReleasesInNewCollection(uint32 _totalSupply, string _digitalMediaMetadataPath, string _collectionMetadataPath, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) CreateDigitalMediaAndReleasesInNewCollection(_totalSupply uint32, _digitalMediaMetadataPath string, _collectionMetadataPath string, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.CreateDigitalMediaAndReleasesInNewCollection(&_DigitalMediaCore.TransactOpts, _totalSupply, _digitalMediaMetadataPath, _collectionMetadataPath, _numReleases)
}

// CreateDigitalMediaReleases is a paid mutator transaction binding the contract method 0x7fb08c9b.
//
// Solidity: function createDigitalMediaReleases(uint256 _digitalMediaId, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) CreateDigitalMediaReleases(opts *bind.TransactOpts, _digitalMediaId *big.Int, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "createDigitalMediaReleases", _digitalMediaId, _numReleases)
}

// CreateDigitalMediaReleases is a paid mutator transaction binding the contract method 0x7fb08c9b.
//
// Solidity: function createDigitalMediaReleases(uint256 _digitalMediaId, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) CreateDigitalMediaReleases(_digitalMediaId *big.Int, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.CreateDigitalMediaReleases(&_DigitalMediaCore.TransactOpts, _digitalMediaId, _numReleases)
}

// CreateDigitalMediaReleases is a paid mutator transaction binding the contract method 0x7fb08c9b.
//
// Solidity: function createDigitalMediaReleases(uint256 _digitalMediaId, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) CreateDigitalMediaReleases(_digitalMediaId *big.Int, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.CreateDigitalMediaReleases(&_DigitalMediaCore.TransactOpts, _digitalMediaId, _numReleases)
}

// DisableOboAddress is a paid mutator transaction binding the contract method 0x92b8bde1.
//
// Solidity: function disableOboAddress(address _oboAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) DisableOboAddress(opts *bind.TransactOpts, _oboAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "disableOboAddress", _oboAddress)
}

// DisableOboAddress is a paid mutator transaction binding the contract method 0x92b8bde1.
//
// Solidity: function disableOboAddress(address _oboAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) DisableOboAddress(_oboAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.DisableOboAddress(&_DigitalMediaCore.TransactOpts, _oboAddress)
}

// DisableOboAddress is a paid mutator transaction binding the contract method 0x92b8bde1.
//
// Solidity: function disableOboAddress(address _oboAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) DisableOboAddress(_oboAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.DisableOboAddress(&_DigitalMediaCore.TransactOpts, _oboAddress)
}

// OboCreateDigitalMediaAndReleases is a paid mutator transaction binding the contract method 0x6ee17a78.
//
// Solidity: function oboCreateDigitalMediaAndReleases(address _owner, uint32 _totalSupply, uint256 _collectionId, string _metadataPath, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) OboCreateDigitalMediaAndReleases(opts *bind.TransactOpts, _owner common.Address, _totalSupply uint32, _collectionId *big.Int, _metadataPath string, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "oboCreateDigitalMediaAndReleases", _owner, _totalSupply, _collectionId, _metadataPath, _numReleases)
}

// OboCreateDigitalMediaAndReleases is a paid mutator transaction binding the contract method 0x6ee17a78.
//
// Solidity: function oboCreateDigitalMediaAndReleases(address _owner, uint32 _totalSupply, uint256 _collectionId, string _metadataPath, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) OboCreateDigitalMediaAndReleases(_owner common.Address, _totalSupply uint32, _collectionId *big.Int, _metadataPath string, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.OboCreateDigitalMediaAndReleases(&_DigitalMediaCore.TransactOpts, _owner, _totalSupply, _collectionId, _metadataPath, _numReleases)
}

// OboCreateDigitalMediaAndReleases is a paid mutator transaction binding the contract method 0x6ee17a78.
//
// Solidity: function oboCreateDigitalMediaAndReleases(address _owner, uint32 _totalSupply, uint256 _collectionId, string _metadataPath, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) OboCreateDigitalMediaAndReleases(_owner common.Address, _totalSupply uint32, _collectionId *big.Int, _metadataPath string, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.OboCreateDigitalMediaAndReleases(&_DigitalMediaCore.TransactOpts, _owner, _totalSupply, _collectionId, _metadataPath, _numReleases)
}

// OboCreateDigitalMediaAndReleasesInNewCollection is a paid mutator transaction binding the contract method 0x06a186d1.
//
// Solidity: function oboCreateDigitalMediaAndReleasesInNewCollection(address _owner, uint32 _totalSupply, string _digitalMediaMetadataPath, string _collectionMetadataPath, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) OboCreateDigitalMediaAndReleasesInNewCollection(opts *bind.TransactOpts, _owner common.Address, _totalSupply uint32, _digitalMediaMetadataPath string, _collectionMetadataPath string, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "oboCreateDigitalMediaAndReleasesInNewCollection", _owner, _totalSupply, _digitalMediaMetadataPath, _collectionMetadataPath, _numReleases)
}

// OboCreateDigitalMediaAndReleasesInNewCollection is a paid mutator transaction binding the contract method 0x06a186d1.
//
// Solidity: function oboCreateDigitalMediaAndReleasesInNewCollection(address _owner, uint32 _totalSupply, string _digitalMediaMetadataPath, string _collectionMetadataPath, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) OboCreateDigitalMediaAndReleasesInNewCollection(_owner common.Address, _totalSupply uint32, _digitalMediaMetadataPath string, _collectionMetadataPath string, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.OboCreateDigitalMediaAndReleasesInNewCollection(&_DigitalMediaCore.TransactOpts, _owner, _totalSupply, _digitalMediaMetadataPath, _collectionMetadataPath, _numReleases)
}

// OboCreateDigitalMediaAndReleasesInNewCollection is a paid mutator transaction binding the contract method 0x06a186d1.
//
// Solidity: function oboCreateDigitalMediaAndReleasesInNewCollection(address _owner, uint32 _totalSupply, string _digitalMediaMetadataPath, string _collectionMetadataPath, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) OboCreateDigitalMediaAndReleasesInNewCollection(_owner common.Address, _totalSupply uint32, _digitalMediaMetadataPath string, _collectionMetadataPath string, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.OboCreateDigitalMediaAndReleasesInNewCollection(&_DigitalMediaCore.TransactOpts, _owner, _totalSupply, _digitalMediaMetadataPath, _collectionMetadataPath, _numReleases)
}

// OboCreateDigitalMediaReleases is a paid mutator transaction binding the contract method 0xb36f0faa.
//
// Solidity: function oboCreateDigitalMediaReleases(address _owner, uint256 _digitalMediaId, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) OboCreateDigitalMediaReleases(opts *bind.TransactOpts, _owner common.Address, _digitalMediaId *big.Int, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "oboCreateDigitalMediaReleases", _owner, _digitalMediaId, _numReleases)
}

// OboCreateDigitalMediaReleases is a paid mutator transaction binding the contract method 0xb36f0faa.
//
// Solidity: function oboCreateDigitalMediaReleases(address _owner, uint256 _digitalMediaId, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) OboCreateDigitalMediaReleases(_owner common.Address, _digitalMediaId *big.Int, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.OboCreateDigitalMediaReleases(&_DigitalMediaCore.TransactOpts, _owner, _digitalMediaId, _numReleases)
}

// OboCreateDigitalMediaReleases is a paid mutator transaction binding the contract method 0xb36f0faa.
//
// Solidity: function oboCreateDigitalMediaReleases(address _owner, uint256 _digitalMediaId, uint32 _numReleases) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) OboCreateDigitalMediaReleases(_owner common.Address, _digitalMediaId *big.Int, _numReleases uint32) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.OboCreateDigitalMediaReleases(&_DigitalMediaCore.TransactOpts, _owner, _digitalMediaId, _numReleases)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) Pause() (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.Pause(&_DigitalMediaCore.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) Pause() (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.Pause(&_DigitalMediaCore.TransactOpts)
}

// RemoveApprovedTokenCreator is a paid mutator transaction binding the contract method 0x4751ae99.
//
// Solidity: function removeApprovedTokenCreator(address _creatorAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) RemoveApprovedTokenCreator(opts *bind.TransactOpts, _creatorAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "removeApprovedTokenCreator", _creatorAddress)
}

// RemoveApprovedTokenCreator is a paid mutator transaction binding the contract method 0x4751ae99.
//
// Solidity: function removeApprovedTokenCreator(address _creatorAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) RemoveApprovedTokenCreator(_creatorAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.RemoveApprovedTokenCreator(&_DigitalMediaCore.TransactOpts, _creatorAddress)
}

// RemoveApprovedTokenCreator is a paid mutator transaction binding the contract method 0x4751ae99.
//
// Solidity: function removeApprovedTokenCreator(address _creatorAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) RemoveApprovedTokenCreator(_creatorAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.RemoveApprovedTokenCreator(&_DigitalMediaCore.TransactOpts, _creatorAddress)
}

// ResetApproval is a paid mutator transaction binding the contract method 0xcf8dae05.
//
// Solidity: function resetApproval(uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) ResetApproval(opts *bind.TransactOpts, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "resetApproval", _tokenId)
}

// ResetApproval is a paid mutator transaction binding the contract method 0xcf8dae05.
//
// Solidity: function resetApproval(uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) ResetApproval(_tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.ResetApproval(&_DigitalMediaCore.TransactOpts, _tokenId)
}

// ResetApproval is a paid mutator transaction binding the contract method 0xcf8dae05.
//
// Solidity: function resetApproval(uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) ResetApproval(_tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.ResetApproval(&_DigitalMediaCore.TransactOpts, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) SafeTransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "safeTransferFrom", _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.SafeTransferFrom(&_DigitalMediaCore.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.SafeTransferFrom(&_DigitalMediaCore.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) SafeTransferFrom0(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "safeTransferFrom0", _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.SafeTransferFrom0(&_DigitalMediaCore.TransactOpts, _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.SafeTransferFrom0(&_DigitalMediaCore.TransactOpts, _from, _to, _tokenId, _data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) SetApprovalForAll(opts *bind.TransactOpts, _to common.Address, _approved bool) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "setApprovalForAll", _to, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) SetApprovalForAll(_to common.Address, _approved bool) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.SetApprovalForAll(&_DigitalMediaCore.TransactOpts, _to, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) SetApprovalForAll(_to common.Address, _approved bool) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.SetApprovalForAll(&_DigitalMediaCore.TransactOpts, _to, _approved)
}

// SetOboApprovalForAll is a paid mutator transaction binding the contract method 0x774f99d0.
//
// Solidity: function setOboApprovalForAll(address _to, bool _approved) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) SetOboApprovalForAll(opts *bind.TransactOpts, _to common.Address, _approved bool) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "setOboApprovalForAll", _to, _approved)
}

// SetOboApprovalForAll is a paid mutator transaction binding the contract method 0x774f99d0.
//
// Solidity: function setOboApprovalForAll(address _to, bool _approved) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) SetOboApprovalForAll(_to common.Address, _approved bool) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.SetOboApprovalForAll(&_DigitalMediaCore.TransactOpts, _to, _approved)
}

// SetOboApprovalForAll is a paid mutator transaction binding the contract method 0x774f99d0.
//
// Solidity: function setOboApprovalForAll(address _to, bool _approved) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) SetOboApprovalForAll(_to common.Address, _approved bool) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.SetOboApprovalForAll(&_DigitalMediaCore.TransactOpts, _to, _approved)
}

// SetV1DigitalMediaStoreAddress is a paid mutator transaction binding the contract method 0x91c60788.
//
// Solidity: function setV1DigitalMediaStoreAddress(address _dmsAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) SetV1DigitalMediaStoreAddress(opts *bind.TransactOpts, _dmsAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "setV1DigitalMediaStoreAddress", _dmsAddress)
}

// SetV1DigitalMediaStoreAddress is a paid mutator transaction binding the contract method 0x91c60788.
//
// Solidity: function setV1DigitalMediaStoreAddress(address _dmsAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) SetV1DigitalMediaStoreAddress(_dmsAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.SetV1DigitalMediaStoreAddress(&_DigitalMediaCore.TransactOpts, _dmsAddress)
}

// SetV1DigitalMediaStoreAddress is a paid mutator transaction binding the contract method 0x91c60788.
//
// Solidity: function setV1DigitalMediaStoreAddress(address _dmsAddress) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) SetV1DigitalMediaStoreAddress(_dmsAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.SetV1DigitalMediaStoreAddress(&_DigitalMediaCore.TransactOpts, _dmsAddress)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) TransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "transferFrom", _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.TransferFrom(&_DigitalMediaCore.TransactOpts, _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.TransferFrom(&_DigitalMediaCore.TransactOpts, _from, _to, _tokenId)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.TransferOwnership(&_DigitalMediaCore.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.TransferOwnership(&_DigitalMediaCore.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaCore.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_DigitalMediaCore *DigitalMediaCoreSession) Unpause() (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.Unpause(&_DigitalMediaCore.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_DigitalMediaCore *DigitalMediaCoreTransactorSession) Unpause() (*types.Transaction, error) {
	return _DigitalMediaCore.Contract.Unpause(&_DigitalMediaCore.TransactOpts)
}

// DigitalMediaCoreApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the DigitalMediaCore contract.
type DigitalMediaCoreApprovalIterator struct {
	Event *DigitalMediaCoreApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreApproval represents a Approval event raised by the DigitalMediaCore contract.
type DigitalMediaCoreApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterApproval(opts *bind.FilterOpts, _owner []common.Address, _approved []common.Address) (*DigitalMediaCoreApprovalIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreApprovalIterator{contract: _DigitalMediaCore.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreApproval, _owner []common.Address, _approved []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreApproval)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseApproval(log types.Log) (*DigitalMediaCoreApproval, error) {
	event := new(DigitalMediaCoreApproval)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the DigitalMediaCore contract.
type DigitalMediaCoreApprovalForAllIterator struct {
	Event *DigitalMediaCoreApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreApprovalForAll represents a ApprovalForAll event raised by the DigitalMediaCore contract.
type DigitalMediaCoreApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterApprovalForAll(opts *bind.FilterOpts, _owner []common.Address, _operator []common.Address) (*DigitalMediaCoreApprovalForAllIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreApprovalForAllIterator{contract: _DigitalMediaCore.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreApprovalForAll, _owner []common.Address, _operator []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreApprovalForAll)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseApprovalForAll(log types.Log) (*DigitalMediaCoreApprovalForAll, error) {
	event := new(DigitalMediaCoreApprovalForAll)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreChangedCreatorIterator is returned from FilterChangedCreator and is used to iterate over the raw logs and unpacked data for ChangedCreator events raised by the DigitalMediaCore contract.
type DigitalMediaCoreChangedCreatorIterator struct {
	Event *DigitalMediaCoreChangedCreator // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreChangedCreatorIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreChangedCreator)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreChangedCreator)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreChangedCreatorIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreChangedCreatorIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreChangedCreator represents a ChangedCreator event raised by the DigitalMediaCore contract.
type DigitalMediaCoreChangedCreator struct {
	Creator    common.Address
	NewCreator common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterChangedCreator is a free log retrieval operation binding the contract event 0xde6cfdf21fe76bcb45258138e27bcd332b76941b24d226b5da8dc5f9cd531c3e.
//
// Solidity: event ChangedCreator(address creator, address newCreator)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterChangedCreator(opts *bind.FilterOpts) (*DigitalMediaCoreChangedCreatorIterator, error) {

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "ChangedCreator")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreChangedCreatorIterator{contract: _DigitalMediaCore.contract, event: "ChangedCreator", logs: logs, sub: sub}, nil
}

// WatchChangedCreator is a free log subscription operation binding the contract event 0xde6cfdf21fe76bcb45258138e27bcd332b76941b24d226b5da8dc5f9cd531c3e.
//
// Solidity: event ChangedCreator(address creator, address newCreator)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchChangedCreator(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreChangedCreator) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "ChangedCreator")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreChangedCreator)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "ChangedCreator", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangedCreator is a log parse operation binding the contract event 0xde6cfdf21fe76bcb45258138e27bcd332b76941b24d226b5da8dc5f9cd531c3e.
//
// Solidity: event ChangedCreator(address creator, address newCreator)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseChangedCreator(log types.Log) (*DigitalMediaCoreChangedCreator, error) {
	event := new(DigitalMediaCoreChangedCreator)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "ChangedCreator", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreDigitalMediaBurnEventIterator is returned from FilterDigitalMediaBurnEvent and is used to iterate over the raw logs and unpacked data for DigitalMediaBurnEvent events raised by the DigitalMediaCore contract.
type DigitalMediaCoreDigitalMediaBurnEventIterator struct {
	Event *DigitalMediaCoreDigitalMediaBurnEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreDigitalMediaBurnEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreDigitalMediaBurnEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreDigitalMediaBurnEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreDigitalMediaBurnEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreDigitalMediaBurnEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreDigitalMediaBurnEvent represents a DigitalMediaBurnEvent event raised by the DigitalMediaCore contract.
type DigitalMediaCoreDigitalMediaBurnEvent struct {
	Id                   *big.Int
	Caller               common.Address
	StoreContractAddress common.Address
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterDigitalMediaBurnEvent is a free log retrieval operation binding the contract event 0x327ecc068f1b41267f69376098f6a50da487e4a4d762d53c01197d6a2f294b3e.
//
// Solidity: event DigitalMediaBurnEvent(uint256 id, address caller, address storeContractAddress)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterDigitalMediaBurnEvent(opts *bind.FilterOpts) (*DigitalMediaCoreDigitalMediaBurnEventIterator, error) {

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "DigitalMediaBurnEvent")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreDigitalMediaBurnEventIterator{contract: _DigitalMediaCore.contract, event: "DigitalMediaBurnEvent", logs: logs, sub: sub}, nil
}

// WatchDigitalMediaBurnEvent is a free log subscription operation binding the contract event 0x327ecc068f1b41267f69376098f6a50da487e4a4d762d53c01197d6a2f294b3e.
//
// Solidity: event DigitalMediaBurnEvent(uint256 id, address caller, address storeContractAddress)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchDigitalMediaBurnEvent(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreDigitalMediaBurnEvent) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "DigitalMediaBurnEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreDigitalMediaBurnEvent)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "DigitalMediaBurnEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDigitalMediaBurnEvent is a log parse operation binding the contract event 0x327ecc068f1b41267f69376098f6a50da487e4a4d762d53c01197d6a2f294b3e.
//
// Solidity: event DigitalMediaBurnEvent(uint256 id, address caller, address storeContractAddress)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseDigitalMediaBurnEvent(log types.Log) (*DigitalMediaCoreDigitalMediaBurnEvent, error) {
	event := new(DigitalMediaCoreDigitalMediaBurnEvent)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "DigitalMediaBurnEvent", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreDigitalMediaCollectionCreateEventIterator is returned from FilterDigitalMediaCollectionCreateEvent and is used to iterate over the raw logs and unpacked data for DigitalMediaCollectionCreateEvent events raised by the DigitalMediaCore contract.
type DigitalMediaCoreDigitalMediaCollectionCreateEventIterator struct {
	Event *DigitalMediaCoreDigitalMediaCollectionCreateEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreDigitalMediaCollectionCreateEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreDigitalMediaCollectionCreateEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreDigitalMediaCollectionCreateEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreDigitalMediaCollectionCreateEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreDigitalMediaCollectionCreateEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreDigitalMediaCollectionCreateEvent represents a DigitalMediaCollectionCreateEvent event raised by the DigitalMediaCore contract.
type DigitalMediaCoreDigitalMediaCollectionCreateEvent struct {
	Id                   *big.Int
	StoreContractAddress common.Address
	Creator              common.Address
	MetadataPath         string
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterDigitalMediaCollectionCreateEvent is a free log retrieval operation binding the contract event 0x01e2312dcdafe7cd3f82579d8c121fdb930d46ef2eb231953a521ac62093e277.
//
// Solidity: event DigitalMediaCollectionCreateEvent(uint256 id, address storeContractAddress, address creator, string metadataPath)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterDigitalMediaCollectionCreateEvent(opts *bind.FilterOpts) (*DigitalMediaCoreDigitalMediaCollectionCreateEventIterator, error) {

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "DigitalMediaCollectionCreateEvent")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreDigitalMediaCollectionCreateEventIterator{contract: _DigitalMediaCore.contract, event: "DigitalMediaCollectionCreateEvent", logs: logs, sub: sub}, nil
}

// WatchDigitalMediaCollectionCreateEvent is a free log subscription operation binding the contract event 0x01e2312dcdafe7cd3f82579d8c121fdb930d46ef2eb231953a521ac62093e277.
//
// Solidity: event DigitalMediaCollectionCreateEvent(uint256 id, address storeContractAddress, address creator, string metadataPath)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchDigitalMediaCollectionCreateEvent(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreDigitalMediaCollectionCreateEvent) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "DigitalMediaCollectionCreateEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreDigitalMediaCollectionCreateEvent)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "DigitalMediaCollectionCreateEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDigitalMediaCollectionCreateEvent is a log parse operation binding the contract event 0x01e2312dcdafe7cd3f82579d8c121fdb930d46ef2eb231953a521ac62093e277.
//
// Solidity: event DigitalMediaCollectionCreateEvent(uint256 id, address storeContractAddress, address creator, string metadataPath)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseDigitalMediaCollectionCreateEvent(log types.Log) (*DigitalMediaCoreDigitalMediaCollectionCreateEvent, error) {
	event := new(DigitalMediaCoreDigitalMediaCollectionCreateEvent)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "DigitalMediaCollectionCreateEvent", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreDigitalMediaCreateEventIterator is returned from FilterDigitalMediaCreateEvent and is used to iterate over the raw logs and unpacked data for DigitalMediaCreateEvent events raised by the DigitalMediaCore contract.
type DigitalMediaCoreDigitalMediaCreateEventIterator struct {
	Event *DigitalMediaCoreDigitalMediaCreateEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreDigitalMediaCreateEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreDigitalMediaCreateEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreDigitalMediaCreateEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreDigitalMediaCreateEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreDigitalMediaCreateEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreDigitalMediaCreateEvent represents a DigitalMediaCreateEvent event raised by the DigitalMediaCore contract.
type DigitalMediaCoreDigitalMediaCreateEvent struct {
	Id                   *big.Int
	StoreContractAddress common.Address
	Creator              common.Address
	TotalSupply          uint32
	PrintIndex           uint32
	CollectionId         *big.Int
	MetadataPath         string
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterDigitalMediaCreateEvent is a free log retrieval operation binding the contract event 0x794c5cd70604d9d8dc2cbca1f8be65f167e4147b6512541d41e8e410594098a0.
//
// Solidity: event DigitalMediaCreateEvent(uint256 id, address storeContractAddress, address creator, uint32 totalSupply, uint32 printIndex, uint256 collectionId, string metadataPath)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterDigitalMediaCreateEvent(opts *bind.FilterOpts) (*DigitalMediaCoreDigitalMediaCreateEventIterator, error) {

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "DigitalMediaCreateEvent")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreDigitalMediaCreateEventIterator{contract: _DigitalMediaCore.contract, event: "DigitalMediaCreateEvent", logs: logs, sub: sub}, nil
}

// WatchDigitalMediaCreateEvent is a free log subscription operation binding the contract event 0x794c5cd70604d9d8dc2cbca1f8be65f167e4147b6512541d41e8e410594098a0.
//
// Solidity: event DigitalMediaCreateEvent(uint256 id, address storeContractAddress, address creator, uint32 totalSupply, uint32 printIndex, uint256 collectionId, string metadataPath)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchDigitalMediaCreateEvent(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreDigitalMediaCreateEvent) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "DigitalMediaCreateEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreDigitalMediaCreateEvent)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "DigitalMediaCreateEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDigitalMediaCreateEvent is a log parse operation binding the contract event 0x794c5cd70604d9d8dc2cbca1f8be65f167e4147b6512541d41e8e410594098a0.
//
// Solidity: event DigitalMediaCreateEvent(uint256 id, address storeContractAddress, address creator, uint32 totalSupply, uint32 printIndex, uint256 collectionId, string metadataPath)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseDigitalMediaCreateEvent(log types.Log) (*DigitalMediaCoreDigitalMediaCreateEvent, error) {
	event := new(DigitalMediaCoreDigitalMediaCreateEvent)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "DigitalMediaCreateEvent", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreDigitalMediaReleaseBurnEventIterator is returned from FilterDigitalMediaReleaseBurnEvent and is used to iterate over the raw logs and unpacked data for DigitalMediaReleaseBurnEvent events raised by the DigitalMediaCore contract.
type DigitalMediaCoreDigitalMediaReleaseBurnEventIterator struct {
	Event *DigitalMediaCoreDigitalMediaReleaseBurnEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreDigitalMediaReleaseBurnEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreDigitalMediaReleaseBurnEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreDigitalMediaReleaseBurnEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreDigitalMediaReleaseBurnEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreDigitalMediaReleaseBurnEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreDigitalMediaReleaseBurnEvent represents a DigitalMediaReleaseBurnEvent event raised by the DigitalMediaCore contract.
type DigitalMediaCoreDigitalMediaReleaseBurnEvent struct {
	TokenId *big.Int
	Owner   common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterDigitalMediaReleaseBurnEvent is a free log retrieval operation binding the contract event 0x1e8df141f42ed659a8fe7e7c5966cbdf2d240d0c45f4c30cbe02526c618075ef.
//
// Solidity: event DigitalMediaReleaseBurnEvent(uint256 tokenId, address owner)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterDigitalMediaReleaseBurnEvent(opts *bind.FilterOpts) (*DigitalMediaCoreDigitalMediaReleaseBurnEventIterator, error) {

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "DigitalMediaReleaseBurnEvent")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreDigitalMediaReleaseBurnEventIterator{contract: _DigitalMediaCore.contract, event: "DigitalMediaReleaseBurnEvent", logs: logs, sub: sub}, nil
}

// WatchDigitalMediaReleaseBurnEvent is a free log subscription operation binding the contract event 0x1e8df141f42ed659a8fe7e7c5966cbdf2d240d0c45f4c30cbe02526c618075ef.
//
// Solidity: event DigitalMediaReleaseBurnEvent(uint256 tokenId, address owner)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchDigitalMediaReleaseBurnEvent(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreDigitalMediaReleaseBurnEvent) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "DigitalMediaReleaseBurnEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreDigitalMediaReleaseBurnEvent)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "DigitalMediaReleaseBurnEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDigitalMediaReleaseBurnEvent is a log parse operation binding the contract event 0x1e8df141f42ed659a8fe7e7c5966cbdf2d240d0c45f4c30cbe02526c618075ef.
//
// Solidity: event DigitalMediaReleaseBurnEvent(uint256 tokenId, address owner)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseDigitalMediaReleaseBurnEvent(log types.Log) (*DigitalMediaCoreDigitalMediaReleaseBurnEvent, error) {
	event := new(DigitalMediaCoreDigitalMediaReleaseBurnEvent)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "DigitalMediaReleaseBurnEvent", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreDigitalMediaReleaseCreateEventIterator is returned from FilterDigitalMediaReleaseCreateEvent and is used to iterate over the raw logs and unpacked data for DigitalMediaReleaseCreateEvent events raised by the DigitalMediaCore contract.
type DigitalMediaCoreDigitalMediaReleaseCreateEventIterator struct {
	Event *DigitalMediaCoreDigitalMediaReleaseCreateEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreDigitalMediaReleaseCreateEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreDigitalMediaReleaseCreateEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreDigitalMediaReleaseCreateEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreDigitalMediaReleaseCreateEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreDigitalMediaReleaseCreateEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreDigitalMediaReleaseCreateEvent represents a DigitalMediaReleaseCreateEvent event raised by the DigitalMediaCore contract.
type DigitalMediaCoreDigitalMediaReleaseCreateEvent struct {
	Id             *big.Int
	Owner          common.Address
	PrintEdition   uint32
	TokenURI       string
	DigitalMediaId *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterDigitalMediaReleaseCreateEvent is a free log retrieval operation binding the contract event 0x775f53e4c75ce0c74e611f7f0bb660e4cd647e0522ef0f8aefd4ecef373c5df9.
//
// Solidity: event DigitalMediaReleaseCreateEvent(uint256 id, address owner, uint32 printEdition, string tokenURI, uint256 digitalMediaId)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterDigitalMediaReleaseCreateEvent(opts *bind.FilterOpts) (*DigitalMediaCoreDigitalMediaReleaseCreateEventIterator, error) {

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "DigitalMediaReleaseCreateEvent")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreDigitalMediaReleaseCreateEventIterator{contract: _DigitalMediaCore.contract, event: "DigitalMediaReleaseCreateEvent", logs: logs, sub: sub}, nil
}

// WatchDigitalMediaReleaseCreateEvent is a free log subscription operation binding the contract event 0x775f53e4c75ce0c74e611f7f0bb660e4cd647e0522ef0f8aefd4ecef373c5df9.
//
// Solidity: event DigitalMediaReleaseCreateEvent(uint256 id, address owner, uint32 printEdition, string tokenURI, uint256 digitalMediaId)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchDigitalMediaReleaseCreateEvent(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreDigitalMediaReleaseCreateEvent) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "DigitalMediaReleaseCreateEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreDigitalMediaReleaseCreateEvent)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "DigitalMediaReleaseCreateEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDigitalMediaReleaseCreateEvent is a log parse operation binding the contract event 0x775f53e4c75ce0c74e611f7f0bb660e4cd647e0522ef0f8aefd4ecef373c5df9.
//
// Solidity: event DigitalMediaReleaseCreateEvent(uint256 id, address owner, uint32 printEdition, string tokenURI, uint256 digitalMediaId)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseDigitalMediaReleaseCreateEvent(log types.Log) (*DigitalMediaCoreDigitalMediaReleaseCreateEvent, error) {
	event := new(DigitalMediaCoreDigitalMediaReleaseCreateEvent)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "DigitalMediaReleaseCreateEvent", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreOboApprovalForAllIterator is returned from FilterOboApprovalForAll and is used to iterate over the raw logs and unpacked data for OboApprovalForAll events raised by the DigitalMediaCore contract.
type DigitalMediaCoreOboApprovalForAllIterator struct {
	Event *DigitalMediaCoreOboApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreOboApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreOboApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreOboApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreOboApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreOboApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreOboApprovalForAll represents a OboApprovalForAll event raised by the DigitalMediaCore contract.
type DigitalMediaCoreOboApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOboApprovalForAll is a free log retrieval operation binding the contract event 0x017e8a478826a4348bfb695968246edfab885f8a76b03279cf4630ac073945c9.
//
// Solidity: event OboApprovalForAll(address _owner, address _operator, bool _approved)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterOboApprovalForAll(opts *bind.FilterOpts) (*DigitalMediaCoreOboApprovalForAllIterator, error) {

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "OboApprovalForAll")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreOboApprovalForAllIterator{contract: _DigitalMediaCore.contract, event: "OboApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchOboApprovalForAll is a free log subscription operation binding the contract event 0x017e8a478826a4348bfb695968246edfab885f8a76b03279cf4630ac073945c9.
//
// Solidity: event OboApprovalForAll(address _owner, address _operator, bool _approved)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchOboApprovalForAll(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreOboApprovalForAll) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "OboApprovalForAll")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreOboApprovalForAll)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "OboApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOboApprovalForAll is a log parse operation binding the contract event 0x017e8a478826a4348bfb695968246edfab885f8a76b03279cf4630ac073945c9.
//
// Solidity: event OboApprovalForAll(address _owner, address _operator, bool _approved)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseOboApprovalForAll(log types.Log) (*DigitalMediaCoreOboApprovalForAll, error) {
	event := new(DigitalMediaCoreOboApprovalForAll)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "OboApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreOboDisabledForAllIterator is returned from FilterOboDisabledForAll and is used to iterate over the raw logs and unpacked data for OboDisabledForAll events raised by the DigitalMediaCore contract.
type DigitalMediaCoreOboDisabledForAllIterator struct {
	Event *DigitalMediaCoreOboDisabledForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreOboDisabledForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreOboDisabledForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreOboDisabledForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreOboDisabledForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreOboDisabledForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreOboDisabledForAll represents a OboDisabledForAll event raised by the DigitalMediaCore contract.
type DigitalMediaCoreOboDisabledForAll struct {
	Operator common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOboDisabledForAll is a free log retrieval operation binding the contract event 0xfd0e0c743dbdd84ef4e7c513db9b7e085970164787288791343fda28575652dd.
//
// Solidity: event OboDisabledForAll(address _operator)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterOboDisabledForAll(opts *bind.FilterOpts) (*DigitalMediaCoreOboDisabledForAllIterator, error) {

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "OboDisabledForAll")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreOboDisabledForAllIterator{contract: _DigitalMediaCore.contract, event: "OboDisabledForAll", logs: logs, sub: sub}, nil
}

// WatchOboDisabledForAll is a free log subscription operation binding the contract event 0xfd0e0c743dbdd84ef4e7c513db9b7e085970164787288791343fda28575652dd.
//
// Solidity: event OboDisabledForAll(address _operator)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchOboDisabledForAll(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreOboDisabledForAll) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "OboDisabledForAll")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreOboDisabledForAll)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "OboDisabledForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOboDisabledForAll is a log parse operation binding the contract event 0xfd0e0c743dbdd84ef4e7c513db9b7e085970164787288791343fda28575652dd.
//
// Solidity: event OboDisabledForAll(address _operator)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseOboDisabledForAll(log types.Log) (*DigitalMediaCoreOboDisabledForAll, error) {
	event := new(DigitalMediaCoreOboDisabledForAll)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "OboDisabledForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the DigitalMediaCore contract.
type DigitalMediaCoreOwnershipTransferredIterator struct {
	Event *DigitalMediaCoreOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreOwnershipTransferred represents a OwnershipTransferred event raised by the DigitalMediaCore contract.
type DigitalMediaCoreOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*DigitalMediaCoreOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreOwnershipTransferredIterator{contract: _DigitalMediaCore.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreOwnershipTransferred)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseOwnershipTransferred(log types.Log) (*DigitalMediaCoreOwnershipTransferred, error) {
	event := new(DigitalMediaCoreOwnershipTransferred)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCorePauseIterator is returned from FilterPause and is used to iterate over the raw logs and unpacked data for Pause events raised by the DigitalMediaCore contract.
type DigitalMediaCorePauseIterator struct {
	Event *DigitalMediaCorePause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCorePauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCorePause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCorePause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCorePauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCorePauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCorePause represents a Pause event raised by the DigitalMediaCore contract.
type DigitalMediaCorePause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPause is a free log retrieval operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterPause(opts *bind.FilterOpts) (*DigitalMediaCorePauseIterator, error) {

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCorePauseIterator{contract: _DigitalMediaCore.contract, event: "Pause", logs: logs, sub: sub}, nil
}

// WatchPause is a free log subscription operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchPause(opts *bind.WatchOpts, sink chan<- *DigitalMediaCorePause) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCorePause)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "Pause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePause is a log parse operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParsePause(log types.Log) (*DigitalMediaCorePause, error) {
	event := new(DigitalMediaCorePause)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "Pause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreSingleCreatorChangedIterator is returned from FilterSingleCreatorChanged and is used to iterate over the raw logs and unpacked data for SingleCreatorChanged events raised by the DigitalMediaCore contract.
type DigitalMediaCoreSingleCreatorChangedIterator struct {
	Event *DigitalMediaCoreSingleCreatorChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreSingleCreatorChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreSingleCreatorChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreSingleCreatorChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreSingleCreatorChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreSingleCreatorChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreSingleCreatorChanged represents a SingleCreatorChanged event raised by the DigitalMediaCore contract.
type DigitalMediaCoreSingleCreatorChanged struct {
	PreviousCreatorAddress common.Address
	NewCreatorAddress      common.Address
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterSingleCreatorChanged is a free log retrieval operation binding the contract event 0x384c948063df3740539b4b000658c1a22348e7f18c87f808085662e461e48e71.
//
// Solidity: event SingleCreatorChanged(address indexed previousCreatorAddress, address indexed newCreatorAddress)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterSingleCreatorChanged(opts *bind.FilterOpts, previousCreatorAddress []common.Address, newCreatorAddress []common.Address) (*DigitalMediaCoreSingleCreatorChangedIterator, error) {

	var previousCreatorAddressRule []interface{}
	for _, previousCreatorAddressItem := range previousCreatorAddress {
		previousCreatorAddressRule = append(previousCreatorAddressRule, previousCreatorAddressItem)
	}
	var newCreatorAddressRule []interface{}
	for _, newCreatorAddressItem := range newCreatorAddress {
		newCreatorAddressRule = append(newCreatorAddressRule, newCreatorAddressItem)
	}

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "SingleCreatorChanged", previousCreatorAddressRule, newCreatorAddressRule)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreSingleCreatorChangedIterator{contract: _DigitalMediaCore.contract, event: "SingleCreatorChanged", logs: logs, sub: sub}, nil
}

// WatchSingleCreatorChanged is a free log subscription operation binding the contract event 0x384c948063df3740539b4b000658c1a22348e7f18c87f808085662e461e48e71.
//
// Solidity: event SingleCreatorChanged(address indexed previousCreatorAddress, address indexed newCreatorAddress)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchSingleCreatorChanged(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreSingleCreatorChanged, previousCreatorAddress []common.Address, newCreatorAddress []common.Address) (event.Subscription, error) {

	var previousCreatorAddressRule []interface{}
	for _, previousCreatorAddressItem := range previousCreatorAddress {
		previousCreatorAddressRule = append(previousCreatorAddressRule, previousCreatorAddressItem)
	}
	var newCreatorAddressRule []interface{}
	for _, newCreatorAddressItem := range newCreatorAddress {
		newCreatorAddressRule = append(newCreatorAddressRule, newCreatorAddressItem)
	}

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "SingleCreatorChanged", previousCreatorAddressRule, newCreatorAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreSingleCreatorChanged)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "SingleCreatorChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSingleCreatorChanged is a log parse operation binding the contract event 0x384c948063df3740539b4b000658c1a22348e7f18c87f808085662e461e48e71.
//
// Solidity: event SingleCreatorChanged(address indexed previousCreatorAddress, address indexed newCreatorAddress)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseSingleCreatorChanged(log types.Log) (*DigitalMediaCoreSingleCreatorChanged, error) {
	event := new(DigitalMediaCoreSingleCreatorChanged)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "SingleCreatorChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the DigitalMediaCore contract.
type DigitalMediaCoreTransferIterator struct {
	Event *DigitalMediaCoreTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreTransfer represents a Transfer event raised by the DigitalMediaCore contract.
type DigitalMediaCoreTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterTransfer(opts *bind.FilterOpts, _from []common.Address, _to []common.Address) (*DigitalMediaCoreTransferIterator, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreTransferIterator{contract: _DigitalMediaCore.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreTransfer, _from []common.Address, _to []common.Address) (event.Subscription, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreTransfer)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseTransfer(log types.Log) (*DigitalMediaCoreTransfer, error) {
	event := new(DigitalMediaCoreTransfer)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreUnpauseIterator is returned from FilterUnpause and is used to iterate over the raw logs and unpacked data for Unpause events raised by the DigitalMediaCore contract.
type DigitalMediaCoreUnpauseIterator struct {
	Event *DigitalMediaCoreUnpause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreUnpauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreUnpause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreUnpause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreUnpauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreUnpauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreUnpause represents a Unpause event raised by the DigitalMediaCore contract.
type DigitalMediaCoreUnpause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUnpause is a free log retrieval operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterUnpause(opts *bind.FilterOpts) (*DigitalMediaCoreUnpauseIterator, error) {

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreUnpauseIterator{contract: _DigitalMediaCore.contract, event: "Unpause", logs: logs, sub: sub}, nil
}

// WatchUnpause is a free log subscription operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchUnpause(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreUnpause) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreUnpause)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "Unpause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpause is a log parse operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseUnpause(log types.Log) (*DigitalMediaCoreUnpause, error) {
	event := new(DigitalMediaCoreUnpause)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "Unpause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaCoreUpdateDigitalMediaPrintIndexEventIterator is returned from FilterUpdateDigitalMediaPrintIndexEvent and is used to iterate over the raw logs and unpacked data for UpdateDigitalMediaPrintIndexEvent events raised by the DigitalMediaCore contract.
type DigitalMediaCoreUpdateDigitalMediaPrintIndexEventIterator struct {
	Event *DigitalMediaCoreUpdateDigitalMediaPrintIndexEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaCoreUpdateDigitalMediaPrintIndexEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaCoreUpdateDigitalMediaPrintIndexEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaCoreUpdateDigitalMediaPrintIndexEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaCoreUpdateDigitalMediaPrintIndexEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaCoreUpdateDigitalMediaPrintIndexEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaCoreUpdateDigitalMediaPrintIndexEvent represents a UpdateDigitalMediaPrintIndexEvent event raised by the DigitalMediaCore contract.
type DigitalMediaCoreUpdateDigitalMediaPrintIndexEvent struct {
	DigitalMediaId *big.Int
	PrintEdition   uint32
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterUpdateDigitalMediaPrintIndexEvent is a free log retrieval operation binding the contract event 0x12d99f5e49ef761c52953e4f9a109827fc3540292ba88c10d309fef470685259.
//
// Solidity: event UpdateDigitalMediaPrintIndexEvent(uint256 digitalMediaId, uint32 printEdition)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) FilterUpdateDigitalMediaPrintIndexEvent(opts *bind.FilterOpts) (*DigitalMediaCoreUpdateDigitalMediaPrintIndexEventIterator, error) {

	logs, sub, err := _DigitalMediaCore.contract.FilterLogs(opts, "UpdateDigitalMediaPrintIndexEvent")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaCoreUpdateDigitalMediaPrintIndexEventIterator{contract: _DigitalMediaCore.contract, event: "UpdateDigitalMediaPrintIndexEvent", logs: logs, sub: sub}, nil
}

// WatchUpdateDigitalMediaPrintIndexEvent is a free log subscription operation binding the contract event 0x12d99f5e49ef761c52953e4f9a109827fc3540292ba88c10d309fef470685259.
//
// Solidity: event UpdateDigitalMediaPrintIndexEvent(uint256 digitalMediaId, uint32 printEdition)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) WatchUpdateDigitalMediaPrintIndexEvent(opts *bind.WatchOpts, sink chan<- *DigitalMediaCoreUpdateDigitalMediaPrintIndexEvent) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaCore.contract.WatchLogs(opts, "UpdateDigitalMediaPrintIndexEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaCoreUpdateDigitalMediaPrintIndexEvent)
				if err := _DigitalMediaCore.contract.UnpackLog(event, "UpdateDigitalMediaPrintIndexEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateDigitalMediaPrintIndexEvent is a log parse operation binding the contract event 0x12d99f5e49ef761c52953e4f9a109827fc3540292ba88c10d309fef470685259.
//
// Solidity: event UpdateDigitalMediaPrintIndexEvent(uint256 digitalMediaId, uint32 printEdition)
func (_DigitalMediaCore *DigitalMediaCoreFilterer) ParseUpdateDigitalMediaPrintIndexEvent(log types.Log) (*DigitalMediaCoreUpdateDigitalMediaPrintIndexEvent, error) {
	event := new(DigitalMediaCoreUpdateDigitalMediaPrintIndexEvent)
	if err := _DigitalMediaCore.contract.UnpackLog(event, "UpdateDigitalMediaPrintIndexEvent", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaManagerABI is the input ABI used to generate the binding from.
const DigitalMediaManagerABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"currentStartingDigitalMediaId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentDigitalMediaStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dmsAddress\",\"type\":\"address\"}],\"name\":\"setV1DigitalMediaStoreAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"v1DigitalMediaStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creatorRegistryStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]"

// DigitalMediaManagerFuncSigs maps the 4-byte function signature to its string representation.
var DigitalMediaManagerFuncSigs = map[string]string{
	"b39ba60a": "creatorRegistryStore()",
	"1b284e75": "currentDigitalMediaStore()",
	"0154788d": "currentStartingDigitalMediaId()",
	"8da5cb5b": "owner()",
	"8456cb59": "pause()",
	"5c975abb": "paused()",
	"91c60788": "setV1DigitalMediaStoreAddress(address)",
	"f2fde38b": "transferOwnership(address)",
	"3f4ba83a": "unpause()",
	"a0f01e08": "v1DigitalMediaStore()",
}

// DigitalMediaManagerBin is the compiled bytecode used for deploying new contracts.
var DigitalMediaManagerBin = "0x608060405260008054600160a860020a03191633179055610640806100256000396000f3006080604052600436106100a35763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630154788d81146100a85780631b284e75146100cf5780633f4ba83a146101005780635c975abb146101175780638456cb59146101405780638da5cb5b1461015557806391c607881461016a578063a0f01e081461018b578063b39ba60a146101a0578063f2fde38b146101b5575b600080fd5b3480156100b457600080fd5b506100bd6101d6565b60408051918252519081900360200190f35b3480156100db57600080fd5b506100e46101dc565b60408051600160a060020a039092168252519081900360200190f35b34801561010c57600080fd5b506101156101eb565b005b34801561012357600080fd5b5061012c610272565b604080519115158252519081900360200190f35b34801561014c57600080fd5b50610115610293565b34801561016157600080fd5b506100e4610330565b34801561017657600080fd5b50610115600160a060020a036004351661033f565b34801561019757600080fd5b506100e4610562565b3480156101ac57600080fd5b506100e4610571565b3480156101c157600080fd5b50610115600160a060020a0360043516610580565b60035481565b600254600160a060020a031681565b600054600160a060020a0316331461020257600080fd5b60005474010000000000000000000000000000000000000000900460ff16151561022b57600080fd5b6000805474ff0000000000000000000000000000000000000000191681556040517f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b339190a1565b60005474010000000000000000000000000000000000000000900460ff1681565b600054600160a060020a031633146102aa57600080fd5b60005474010000000000000000000000000000000000000000900460ff16156102d257600080fd5b6000805474ff00000000000000000000000000000000000000001916740100000000000000000000000000000000000000001781556040517f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff6259190a1565b600054600160a060020a031681565b60008054600160a060020a0316331461035757600080fd5b600154600160a060020a0316156103cf57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f5631206d656469612073746f726520616c7265616479207365742e0000000000604482015290519081900360640190fd5b81905080600160a060020a0316636c669f256040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15801561042957600080fd5b505af115801561043d573d6000803e3d6000fd5b505050506040513d602081101561045357600080fd5b50516001146104c357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e636f72726563742076657273696f6e2e0000000000000000000000000000604482015290519081900360640190fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038381169190911791829055604080517fa60800b80000000000000000000000000000000000000000000000000000000081529051929091169163a60800b89160048082019260009290919082900301818387803b15801561054657600080fd5b505af115801561055a573d6000803e3d6000fd5b505050505050565b600154600160a060020a031681565b600454600160a060020a031681565b600054600160a060020a0316331461059757600080fd5b600160a060020a03811615156105ac57600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790555600a165627a7a72305820d4f3bfb53153264417dccb16da78f063c94a8dcd4a6f483263be88991820a8e50029"

// DeployDigitalMediaManager deploys a new Ethereum contract, binding an instance of DigitalMediaManager to it.
func DeployDigitalMediaManager(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *DigitalMediaManager, error) {
	parsed, err := abi.JSON(strings.NewReader(DigitalMediaManagerABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(DigitalMediaManagerBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &DigitalMediaManager{DigitalMediaManagerCaller: DigitalMediaManagerCaller{contract: contract}, DigitalMediaManagerTransactor: DigitalMediaManagerTransactor{contract: contract}, DigitalMediaManagerFilterer: DigitalMediaManagerFilterer{contract: contract}}, nil
}

// DigitalMediaManager is an auto generated Go binding around an Ethereum contract.
type DigitalMediaManager struct {
	DigitalMediaManagerCaller     // Read-only binding to the contract
	DigitalMediaManagerTransactor // Write-only binding to the contract
	DigitalMediaManagerFilterer   // Log filterer for contract events
}

// DigitalMediaManagerCaller is an auto generated read-only Go binding around an Ethereum contract.
type DigitalMediaManagerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaManagerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type DigitalMediaManagerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaManagerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type DigitalMediaManagerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaManagerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type DigitalMediaManagerSession struct {
	Contract     *DigitalMediaManager // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// DigitalMediaManagerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type DigitalMediaManagerCallerSession struct {
	Contract *DigitalMediaManagerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// DigitalMediaManagerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type DigitalMediaManagerTransactorSession struct {
	Contract     *DigitalMediaManagerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// DigitalMediaManagerRaw is an auto generated low-level Go binding around an Ethereum contract.
type DigitalMediaManagerRaw struct {
	Contract *DigitalMediaManager // Generic contract binding to access the raw methods on
}

// DigitalMediaManagerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type DigitalMediaManagerCallerRaw struct {
	Contract *DigitalMediaManagerCaller // Generic read-only contract binding to access the raw methods on
}

// DigitalMediaManagerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type DigitalMediaManagerTransactorRaw struct {
	Contract *DigitalMediaManagerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewDigitalMediaManager creates a new instance of DigitalMediaManager, bound to a specific deployed contract.
func NewDigitalMediaManager(address common.Address, backend bind.ContractBackend) (*DigitalMediaManager, error) {
	contract, err := bindDigitalMediaManager(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaManager{DigitalMediaManagerCaller: DigitalMediaManagerCaller{contract: contract}, DigitalMediaManagerTransactor: DigitalMediaManagerTransactor{contract: contract}, DigitalMediaManagerFilterer: DigitalMediaManagerFilterer{contract: contract}}, nil
}

// NewDigitalMediaManagerCaller creates a new read-only instance of DigitalMediaManager, bound to a specific deployed contract.
func NewDigitalMediaManagerCaller(address common.Address, caller bind.ContractCaller) (*DigitalMediaManagerCaller, error) {
	contract, err := bindDigitalMediaManager(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaManagerCaller{contract: contract}, nil
}

// NewDigitalMediaManagerTransactor creates a new write-only instance of DigitalMediaManager, bound to a specific deployed contract.
func NewDigitalMediaManagerTransactor(address common.Address, transactor bind.ContractTransactor) (*DigitalMediaManagerTransactor, error) {
	contract, err := bindDigitalMediaManager(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaManagerTransactor{contract: contract}, nil
}

// NewDigitalMediaManagerFilterer creates a new log filterer instance of DigitalMediaManager, bound to a specific deployed contract.
func NewDigitalMediaManagerFilterer(address common.Address, filterer bind.ContractFilterer) (*DigitalMediaManagerFilterer, error) {
	contract, err := bindDigitalMediaManager(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaManagerFilterer{contract: contract}, nil
}

// bindDigitalMediaManager binds a generic wrapper to an already deployed contract.
func bindDigitalMediaManager(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(DigitalMediaManagerABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DigitalMediaManager *DigitalMediaManagerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _DigitalMediaManager.Contract.DigitalMediaManagerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DigitalMediaManager *DigitalMediaManagerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaManager.Contract.DigitalMediaManagerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DigitalMediaManager *DigitalMediaManagerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DigitalMediaManager.Contract.DigitalMediaManagerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DigitalMediaManager *DigitalMediaManagerCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _DigitalMediaManager.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DigitalMediaManager *DigitalMediaManagerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaManager.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DigitalMediaManager *DigitalMediaManagerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DigitalMediaManager.Contract.contract.Transact(opts, method, params...)
}

// CreatorRegistryStore is a free data retrieval call binding the contract method 0xb39ba60a.
//
// Solidity: function creatorRegistryStore() constant returns(address)
func (_DigitalMediaManager *DigitalMediaManagerCaller) CreatorRegistryStore(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaManager.contract.Call(opts, out, "creatorRegistryStore")
	return *ret0, err
}

// CreatorRegistryStore is a free data retrieval call binding the contract method 0xb39ba60a.
//
// Solidity: function creatorRegistryStore() constant returns(address)
func (_DigitalMediaManager *DigitalMediaManagerSession) CreatorRegistryStore() (common.Address, error) {
	return _DigitalMediaManager.Contract.CreatorRegistryStore(&_DigitalMediaManager.CallOpts)
}

// CreatorRegistryStore is a free data retrieval call binding the contract method 0xb39ba60a.
//
// Solidity: function creatorRegistryStore() constant returns(address)
func (_DigitalMediaManager *DigitalMediaManagerCallerSession) CreatorRegistryStore() (common.Address, error) {
	return _DigitalMediaManager.Contract.CreatorRegistryStore(&_DigitalMediaManager.CallOpts)
}

// CurrentDigitalMediaStore is a free data retrieval call binding the contract method 0x1b284e75.
//
// Solidity: function currentDigitalMediaStore() constant returns(address)
func (_DigitalMediaManager *DigitalMediaManagerCaller) CurrentDigitalMediaStore(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaManager.contract.Call(opts, out, "currentDigitalMediaStore")
	return *ret0, err
}

// CurrentDigitalMediaStore is a free data retrieval call binding the contract method 0x1b284e75.
//
// Solidity: function currentDigitalMediaStore() constant returns(address)
func (_DigitalMediaManager *DigitalMediaManagerSession) CurrentDigitalMediaStore() (common.Address, error) {
	return _DigitalMediaManager.Contract.CurrentDigitalMediaStore(&_DigitalMediaManager.CallOpts)
}

// CurrentDigitalMediaStore is a free data retrieval call binding the contract method 0x1b284e75.
//
// Solidity: function currentDigitalMediaStore() constant returns(address)
func (_DigitalMediaManager *DigitalMediaManagerCallerSession) CurrentDigitalMediaStore() (common.Address, error) {
	return _DigitalMediaManager.Contract.CurrentDigitalMediaStore(&_DigitalMediaManager.CallOpts)
}

// CurrentStartingDigitalMediaId is a free data retrieval call binding the contract method 0x0154788d.
//
// Solidity: function currentStartingDigitalMediaId() constant returns(uint256)
func (_DigitalMediaManager *DigitalMediaManagerCaller) CurrentStartingDigitalMediaId(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaManager.contract.Call(opts, out, "currentStartingDigitalMediaId")
	return *ret0, err
}

// CurrentStartingDigitalMediaId is a free data retrieval call binding the contract method 0x0154788d.
//
// Solidity: function currentStartingDigitalMediaId() constant returns(uint256)
func (_DigitalMediaManager *DigitalMediaManagerSession) CurrentStartingDigitalMediaId() (*big.Int, error) {
	return _DigitalMediaManager.Contract.CurrentStartingDigitalMediaId(&_DigitalMediaManager.CallOpts)
}

// CurrentStartingDigitalMediaId is a free data retrieval call binding the contract method 0x0154788d.
//
// Solidity: function currentStartingDigitalMediaId() constant returns(uint256)
func (_DigitalMediaManager *DigitalMediaManagerCallerSession) CurrentStartingDigitalMediaId() (*big.Int, error) {
	return _DigitalMediaManager.Contract.CurrentStartingDigitalMediaId(&_DigitalMediaManager.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_DigitalMediaManager *DigitalMediaManagerCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaManager.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_DigitalMediaManager *DigitalMediaManagerSession) Owner() (common.Address, error) {
	return _DigitalMediaManager.Contract.Owner(&_DigitalMediaManager.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_DigitalMediaManager *DigitalMediaManagerCallerSession) Owner() (common.Address, error) {
	return _DigitalMediaManager.Contract.Owner(&_DigitalMediaManager.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_DigitalMediaManager *DigitalMediaManagerCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaManager.contract.Call(opts, out, "paused")
	return *ret0, err
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_DigitalMediaManager *DigitalMediaManagerSession) Paused() (bool, error) {
	return _DigitalMediaManager.Contract.Paused(&_DigitalMediaManager.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_DigitalMediaManager *DigitalMediaManagerCallerSession) Paused() (bool, error) {
	return _DigitalMediaManager.Contract.Paused(&_DigitalMediaManager.CallOpts)
}

// V1DigitalMediaStore is a free data retrieval call binding the contract method 0xa0f01e08.
//
// Solidity: function v1DigitalMediaStore() constant returns(address)
func (_DigitalMediaManager *DigitalMediaManagerCaller) V1DigitalMediaStore(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaManager.contract.Call(opts, out, "v1DigitalMediaStore")
	return *ret0, err
}

// V1DigitalMediaStore is a free data retrieval call binding the contract method 0xa0f01e08.
//
// Solidity: function v1DigitalMediaStore() constant returns(address)
func (_DigitalMediaManager *DigitalMediaManagerSession) V1DigitalMediaStore() (common.Address, error) {
	return _DigitalMediaManager.Contract.V1DigitalMediaStore(&_DigitalMediaManager.CallOpts)
}

// V1DigitalMediaStore is a free data retrieval call binding the contract method 0xa0f01e08.
//
// Solidity: function v1DigitalMediaStore() constant returns(address)
func (_DigitalMediaManager *DigitalMediaManagerCallerSession) V1DigitalMediaStore() (common.Address, error) {
	return _DigitalMediaManager.Contract.V1DigitalMediaStore(&_DigitalMediaManager.CallOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_DigitalMediaManager *DigitalMediaManagerTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaManager.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_DigitalMediaManager *DigitalMediaManagerSession) Pause() (*types.Transaction, error) {
	return _DigitalMediaManager.Contract.Pause(&_DigitalMediaManager.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_DigitalMediaManager *DigitalMediaManagerTransactorSession) Pause() (*types.Transaction, error) {
	return _DigitalMediaManager.Contract.Pause(&_DigitalMediaManager.TransactOpts)
}

// SetV1DigitalMediaStoreAddress is a paid mutator transaction binding the contract method 0x91c60788.
//
// Solidity: function setV1DigitalMediaStoreAddress(address _dmsAddress) returns()
func (_DigitalMediaManager *DigitalMediaManagerTransactor) SetV1DigitalMediaStoreAddress(opts *bind.TransactOpts, _dmsAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaManager.contract.Transact(opts, "setV1DigitalMediaStoreAddress", _dmsAddress)
}

// SetV1DigitalMediaStoreAddress is a paid mutator transaction binding the contract method 0x91c60788.
//
// Solidity: function setV1DigitalMediaStoreAddress(address _dmsAddress) returns()
func (_DigitalMediaManager *DigitalMediaManagerSession) SetV1DigitalMediaStoreAddress(_dmsAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaManager.Contract.SetV1DigitalMediaStoreAddress(&_DigitalMediaManager.TransactOpts, _dmsAddress)
}

// SetV1DigitalMediaStoreAddress is a paid mutator transaction binding the contract method 0x91c60788.
//
// Solidity: function setV1DigitalMediaStoreAddress(address _dmsAddress) returns()
func (_DigitalMediaManager *DigitalMediaManagerTransactorSession) SetV1DigitalMediaStoreAddress(_dmsAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaManager.Contract.SetV1DigitalMediaStoreAddress(&_DigitalMediaManager.TransactOpts, _dmsAddress)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_DigitalMediaManager *DigitalMediaManagerTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _DigitalMediaManager.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_DigitalMediaManager *DigitalMediaManagerSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _DigitalMediaManager.Contract.TransferOwnership(&_DigitalMediaManager.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_DigitalMediaManager *DigitalMediaManagerTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _DigitalMediaManager.Contract.TransferOwnership(&_DigitalMediaManager.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_DigitalMediaManager *DigitalMediaManagerTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaManager.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_DigitalMediaManager *DigitalMediaManagerSession) Unpause() (*types.Transaction, error) {
	return _DigitalMediaManager.Contract.Unpause(&_DigitalMediaManager.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_DigitalMediaManager *DigitalMediaManagerTransactorSession) Unpause() (*types.Transaction, error) {
	return _DigitalMediaManager.Contract.Unpause(&_DigitalMediaManager.TransactOpts)
}

// DigitalMediaManagerOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the DigitalMediaManager contract.
type DigitalMediaManagerOwnershipTransferredIterator struct {
	Event *DigitalMediaManagerOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaManagerOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaManagerOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaManagerOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaManagerOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaManagerOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaManagerOwnershipTransferred represents a OwnershipTransferred event raised by the DigitalMediaManager contract.
type DigitalMediaManagerOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_DigitalMediaManager *DigitalMediaManagerFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*DigitalMediaManagerOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _DigitalMediaManager.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaManagerOwnershipTransferredIterator{contract: _DigitalMediaManager.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_DigitalMediaManager *DigitalMediaManagerFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *DigitalMediaManagerOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _DigitalMediaManager.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaManagerOwnershipTransferred)
				if err := _DigitalMediaManager.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_DigitalMediaManager *DigitalMediaManagerFilterer) ParseOwnershipTransferred(log types.Log) (*DigitalMediaManagerOwnershipTransferred, error) {
	event := new(DigitalMediaManagerOwnershipTransferred)
	if err := _DigitalMediaManager.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaManagerPauseIterator is returned from FilterPause and is used to iterate over the raw logs and unpacked data for Pause events raised by the DigitalMediaManager contract.
type DigitalMediaManagerPauseIterator struct {
	Event *DigitalMediaManagerPause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaManagerPauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaManagerPause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaManagerPause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaManagerPauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaManagerPauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaManagerPause represents a Pause event raised by the DigitalMediaManager contract.
type DigitalMediaManagerPause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPause is a free log retrieval operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_DigitalMediaManager *DigitalMediaManagerFilterer) FilterPause(opts *bind.FilterOpts) (*DigitalMediaManagerPauseIterator, error) {

	logs, sub, err := _DigitalMediaManager.contract.FilterLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaManagerPauseIterator{contract: _DigitalMediaManager.contract, event: "Pause", logs: logs, sub: sub}, nil
}

// WatchPause is a free log subscription operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_DigitalMediaManager *DigitalMediaManagerFilterer) WatchPause(opts *bind.WatchOpts, sink chan<- *DigitalMediaManagerPause) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaManager.contract.WatchLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaManagerPause)
				if err := _DigitalMediaManager.contract.UnpackLog(event, "Pause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePause is a log parse operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_DigitalMediaManager *DigitalMediaManagerFilterer) ParsePause(log types.Log) (*DigitalMediaManagerPause, error) {
	event := new(DigitalMediaManagerPause)
	if err := _DigitalMediaManager.contract.UnpackLog(event, "Pause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaManagerUnpauseIterator is returned from FilterUnpause and is used to iterate over the raw logs and unpacked data for Unpause events raised by the DigitalMediaManager contract.
type DigitalMediaManagerUnpauseIterator struct {
	Event *DigitalMediaManagerUnpause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaManagerUnpauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaManagerUnpause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaManagerUnpause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaManagerUnpauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaManagerUnpauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaManagerUnpause represents a Unpause event raised by the DigitalMediaManager contract.
type DigitalMediaManagerUnpause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUnpause is a free log retrieval operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_DigitalMediaManager *DigitalMediaManagerFilterer) FilterUnpause(opts *bind.FilterOpts) (*DigitalMediaManagerUnpauseIterator, error) {

	logs, sub, err := _DigitalMediaManager.contract.FilterLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaManagerUnpauseIterator{contract: _DigitalMediaManager.contract, event: "Unpause", logs: logs, sub: sub}, nil
}

// WatchUnpause is a free log subscription operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_DigitalMediaManager *DigitalMediaManagerFilterer) WatchUnpause(opts *bind.WatchOpts, sink chan<- *DigitalMediaManagerUnpause) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaManager.contract.WatchLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaManagerUnpause)
				if err := _DigitalMediaManager.contract.UnpackLog(event, "Unpause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpause is a log parse operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_DigitalMediaManager *DigitalMediaManagerFilterer) ParseUnpause(log types.Log) (*DigitalMediaManagerUnpause, error) {
	event := new(DigitalMediaManagerUnpause)
	if err := _DigitalMediaManager.contract.UnpackLog(event, "Unpause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaSaleBaseABI is the input ABI used to generate the binding from.
const DigitalMediaSaleBaseABI = "[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"addApprovedTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawAddress\",\"type\":\"address\"}],\"name\":\"addApprovedWithdrawAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedOBOs\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawAddress\",\"type\":\"address\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oboAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedOBO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEscrowContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oboAddress\",\"type\":\"address\"}],\"name\":\"addApprovedOBO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedWithdrawAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedWithdrawAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedTokenContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"withdrawAddress\",\"type\":\"address\"}],\"name\":\"WithdrawAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"widthdrawAddress\",\"type\":\"address\"}],\"name\":\"WithdrawAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]"

// DigitalMediaSaleBaseFuncSigs maps the 4-byte function signature to its string representation.
var DigitalMediaSaleBaseFuncSigs = map[string]string{
	"cd161d2e": "addApprovedOBO(address)",
	"12c2fdfa": "addApprovedTokenContract(address)",
	"1a32de49": "addApprovedWithdrawAddress(address)",
	"1ad32562": "approvedOBOs(address)",
	"f0346c47": "approvedTokenContracts(address)",
	"ce2d29ac": "approvedWithdrawAddresses(address)",
	"bfc76209": "isEscrowContract()",
	"f0b9e5ba": "onERC721Received(address,uint256,bytes)",
	"8da5cb5b": "owner()",
	"8456cb59": "pause()",
	"5c975abb": "paused()",
	"7ff9f614": "removeApprovedOBO(address)",
	"d077fa5c": "removeApprovedTokenContract(address)",
	"e6ccc9bd": "removeApprovedWithdrawAddress(address)",
	"f2fde38b": "transferOwnership(address)",
	"3f4ba83a": "unpause()",
	"68742da6": "withdrawFunds(address)",
}

// DigitalMediaSaleBaseBin is the compiled bytecode used for deploying new contracts.
var DigitalMediaSaleBaseBin = "0x608060405260008054600160a860020a0319163317905561087f806100256000396000f3006080604052600436106100f05763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166312c2fdfa81146100f55780631a32de49146101185780631ad32562146101395780633f4ba83a1461016e5780635c975abb1461018357806368742da6146101985780637ff9f614146101b95780638456cb59146101da5780638da5cb5b146101ef578063bfc7620914610220578063cd161d2e14610235578063ce2d29ac14610256578063d077fa5c14610289578063e6ccc9bd146102aa578063f0346c47146102cb578063f0b9e5ba146102ec578063f2fde38b1461038a575b600080fd5b34801561010157600080fd5b50610116600160a060020a03600435166103ab565b005b34801561012457600080fd5b50610116600160a060020a03600435166103e6565b34801561014557600080fd5b5061015a600160a060020a0360043516610450565b604080519115158252519081900360200190f35b34801561017a57600080fd5b50610116610465565b34801561018f57600080fd5b5061015a6104ec565b3480156101a457600080fd5b50610116600160a060020a036004351661050d565b3480156101c557600080fd5b50610116600160a060020a0360043516610572565b3480156101e657600080fd5b506101166105aa565b3480156101fb57600080fd5b50610204610647565b60408051600160a060020a039092168252519081900360200190f35b34801561022c57600080fd5b5061015a610656565b34801561024157600080fd5b50610116600160a060020a036004351661065b565b34801561026257600080fd5b50610277600160a060020a0360043516610699565b60408051918252519081900360200190f35b34801561029557600080fd5b50610116600160a060020a03600435166106ab565b3480156102b657600080fd5b50610116600160a060020a03600435166106e3565b3480156102d757600080fd5b5061015a600160a060020a036004351661074d565b3480156102f857600080fd5b50604080516020600460443581810135601f8101849004840285018401909552848452610355948235600160a060020a03169460248035953695946064949201919081908401838280828437509497506107629650505050505050565b604080517fffffffff000000000000000000000000000000000000000000000000000000009092168252519081900360200190f35b34801561039657600080fd5b50610116600160a060020a036004351661078a565b600054600160a060020a031633146103c257600080fd5b600160a060020a03166000908152600360205260409020805460ff19166001179055565b600054600160a060020a031633146103fd57600080fd5b600160a060020a038116600081815260026020908152604091829020429055815192835290517fd3d6d317b22983ab294dbfe93460137c732b9644d637bfbb3258735daf17da899281900390910190a150565b60016020526000908152604090205460ff1681565b600054600160a060020a0316331461047c57600080fd5b60005474010000000000000000000000000000000000000000900460ff1615156104a557600080fd5b6000805474ff0000000000000000000000000000000000000000191681556040517f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b339190a1565b60005474010000000000000000000000000000000000000000900460ff1681565b600054600160a060020a0316331461052457600080fd5b61052d8161081e565b151561053857600080fd5b604051600160a060020a03821690303180156108fc02916000818181858888f1935050505015801561056e573d6000803e3d6000fd5b5050565b600054600160a060020a0316331461058957600080fd5b600160a060020a03166000908152600160205260409020805460ff19169055565b600054600160a060020a031633146105c157600080fd5b60005474010000000000000000000000000000000000000000900460ff16156105e957600080fd5b6000805474ff00000000000000000000000000000000000000001916740100000000000000000000000000000000000000001781556040517f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff6259190a1565b600054600160a060020a031681565b600190565b600054600160a060020a0316331461067257600080fd5b600160a060020a03166000908152600160208190526040909120805460ff19169091179055565b60026020526000908152604090205481565b600054600160a060020a031633146106c257600080fd5b600160a060020a03166000908152600360205260409020805460ff19169055565b600054600160a060020a031633146106fa57600080fd5b600160a060020a038116600081815260026020908152604080832092909255815192835290517fffdbac6a703f8c063588b1b434bac15231b40f4c20b16f797a989d47a56ae8b29281900390910190a150565b60036020526000908152604090205460ff1681565b7ff0b9e5ba000000000000000000000000000000000000000000000000000000009392505050565b600054600160a060020a031633146107a157600080fd5b600160a060020a03811615156107b657600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600160a060020a03811660009081526002602052604081205481811161084357600080fd5b62015180814203119150509190505600a165627a7a72305820429289826997990467d10d988ea77e6d96e6516e7085c8c3f8ed4f5ffda00aba0029"

// DeployDigitalMediaSaleBase deploys a new Ethereum contract, binding an instance of DigitalMediaSaleBase to it.
func DeployDigitalMediaSaleBase(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *DigitalMediaSaleBase, error) {
	parsed, err := abi.JSON(strings.NewReader(DigitalMediaSaleBaseABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(DigitalMediaSaleBaseBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &DigitalMediaSaleBase{DigitalMediaSaleBaseCaller: DigitalMediaSaleBaseCaller{contract: contract}, DigitalMediaSaleBaseTransactor: DigitalMediaSaleBaseTransactor{contract: contract}, DigitalMediaSaleBaseFilterer: DigitalMediaSaleBaseFilterer{contract: contract}}, nil
}

// DigitalMediaSaleBase is an auto generated Go binding around an Ethereum contract.
type DigitalMediaSaleBase struct {
	DigitalMediaSaleBaseCaller     // Read-only binding to the contract
	DigitalMediaSaleBaseTransactor // Write-only binding to the contract
	DigitalMediaSaleBaseFilterer   // Log filterer for contract events
}

// DigitalMediaSaleBaseCaller is an auto generated read-only Go binding around an Ethereum contract.
type DigitalMediaSaleBaseCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaSaleBaseTransactor is an auto generated write-only Go binding around an Ethereum contract.
type DigitalMediaSaleBaseTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaSaleBaseFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type DigitalMediaSaleBaseFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaSaleBaseSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type DigitalMediaSaleBaseSession struct {
	Contract     *DigitalMediaSaleBase // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// DigitalMediaSaleBaseCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type DigitalMediaSaleBaseCallerSession struct {
	Contract *DigitalMediaSaleBaseCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// DigitalMediaSaleBaseTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type DigitalMediaSaleBaseTransactorSession struct {
	Contract     *DigitalMediaSaleBaseTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// DigitalMediaSaleBaseRaw is an auto generated low-level Go binding around an Ethereum contract.
type DigitalMediaSaleBaseRaw struct {
	Contract *DigitalMediaSaleBase // Generic contract binding to access the raw methods on
}

// DigitalMediaSaleBaseCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type DigitalMediaSaleBaseCallerRaw struct {
	Contract *DigitalMediaSaleBaseCaller // Generic read-only contract binding to access the raw methods on
}

// DigitalMediaSaleBaseTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type DigitalMediaSaleBaseTransactorRaw struct {
	Contract *DigitalMediaSaleBaseTransactor // Generic write-only contract binding to access the raw methods on
}

// NewDigitalMediaSaleBase creates a new instance of DigitalMediaSaleBase, bound to a specific deployed contract.
func NewDigitalMediaSaleBase(address common.Address, backend bind.ContractBackend) (*DigitalMediaSaleBase, error) {
	contract, err := bindDigitalMediaSaleBase(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaSaleBase{DigitalMediaSaleBaseCaller: DigitalMediaSaleBaseCaller{contract: contract}, DigitalMediaSaleBaseTransactor: DigitalMediaSaleBaseTransactor{contract: contract}, DigitalMediaSaleBaseFilterer: DigitalMediaSaleBaseFilterer{contract: contract}}, nil
}

// NewDigitalMediaSaleBaseCaller creates a new read-only instance of DigitalMediaSaleBase, bound to a specific deployed contract.
func NewDigitalMediaSaleBaseCaller(address common.Address, caller bind.ContractCaller) (*DigitalMediaSaleBaseCaller, error) {
	contract, err := bindDigitalMediaSaleBase(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaSaleBaseCaller{contract: contract}, nil
}

// NewDigitalMediaSaleBaseTransactor creates a new write-only instance of DigitalMediaSaleBase, bound to a specific deployed contract.
func NewDigitalMediaSaleBaseTransactor(address common.Address, transactor bind.ContractTransactor) (*DigitalMediaSaleBaseTransactor, error) {
	contract, err := bindDigitalMediaSaleBase(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaSaleBaseTransactor{contract: contract}, nil
}

// NewDigitalMediaSaleBaseFilterer creates a new log filterer instance of DigitalMediaSaleBase, bound to a specific deployed contract.
func NewDigitalMediaSaleBaseFilterer(address common.Address, filterer bind.ContractFilterer) (*DigitalMediaSaleBaseFilterer, error) {
	contract, err := bindDigitalMediaSaleBase(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaSaleBaseFilterer{contract: contract}, nil
}

// bindDigitalMediaSaleBase binds a generic wrapper to an already deployed contract.
func bindDigitalMediaSaleBase(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(DigitalMediaSaleBaseABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _DigitalMediaSaleBase.Contract.DigitalMediaSaleBaseCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.DigitalMediaSaleBaseTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.DigitalMediaSaleBaseTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _DigitalMediaSaleBase.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.contract.Transact(opts, method, params...)
}

// ApprovedOBOs is a free data retrieval call binding the contract method 0x1ad32562.
//
// Solidity: function approvedOBOs(address ) constant returns(bool)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCaller) ApprovedOBOs(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaSaleBase.contract.Call(opts, out, "approvedOBOs", arg0)
	return *ret0, err
}

// ApprovedOBOs is a free data retrieval call binding the contract method 0x1ad32562.
//
// Solidity: function approvedOBOs(address ) constant returns(bool)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) ApprovedOBOs(arg0 common.Address) (bool, error) {
	return _DigitalMediaSaleBase.Contract.ApprovedOBOs(&_DigitalMediaSaleBase.CallOpts, arg0)
}

// ApprovedOBOs is a free data retrieval call binding the contract method 0x1ad32562.
//
// Solidity: function approvedOBOs(address ) constant returns(bool)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCallerSession) ApprovedOBOs(arg0 common.Address) (bool, error) {
	return _DigitalMediaSaleBase.Contract.ApprovedOBOs(&_DigitalMediaSaleBase.CallOpts, arg0)
}

// ApprovedTokenContracts is a free data retrieval call binding the contract method 0xf0346c47.
//
// Solidity: function approvedTokenContracts(address ) constant returns(bool)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCaller) ApprovedTokenContracts(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaSaleBase.contract.Call(opts, out, "approvedTokenContracts", arg0)
	return *ret0, err
}

// ApprovedTokenContracts is a free data retrieval call binding the contract method 0xf0346c47.
//
// Solidity: function approvedTokenContracts(address ) constant returns(bool)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) ApprovedTokenContracts(arg0 common.Address) (bool, error) {
	return _DigitalMediaSaleBase.Contract.ApprovedTokenContracts(&_DigitalMediaSaleBase.CallOpts, arg0)
}

// ApprovedTokenContracts is a free data retrieval call binding the contract method 0xf0346c47.
//
// Solidity: function approvedTokenContracts(address ) constant returns(bool)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCallerSession) ApprovedTokenContracts(arg0 common.Address) (bool, error) {
	return _DigitalMediaSaleBase.Contract.ApprovedTokenContracts(&_DigitalMediaSaleBase.CallOpts, arg0)
}

// ApprovedWithdrawAddresses is a free data retrieval call binding the contract method 0xce2d29ac.
//
// Solidity: function approvedWithdrawAddresses(address ) constant returns(uint256)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCaller) ApprovedWithdrawAddresses(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaSaleBase.contract.Call(opts, out, "approvedWithdrawAddresses", arg0)
	return *ret0, err
}

// ApprovedWithdrawAddresses is a free data retrieval call binding the contract method 0xce2d29ac.
//
// Solidity: function approvedWithdrawAddresses(address ) constant returns(uint256)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) ApprovedWithdrawAddresses(arg0 common.Address) (*big.Int, error) {
	return _DigitalMediaSaleBase.Contract.ApprovedWithdrawAddresses(&_DigitalMediaSaleBase.CallOpts, arg0)
}

// ApprovedWithdrawAddresses is a free data retrieval call binding the contract method 0xce2d29ac.
//
// Solidity: function approvedWithdrawAddresses(address ) constant returns(uint256)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCallerSession) ApprovedWithdrawAddresses(arg0 common.Address) (*big.Int, error) {
	return _DigitalMediaSaleBase.Contract.ApprovedWithdrawAddresses(&_DigitalMediaSaleBase.CallOpts, arg0)
}

// IsEscrowContract is a free data retrieval call binding the contract method 0xbfc76209.
//
// Solidity: function isEscrowContract() constant returns(bool)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCaller) IsEscrowContract(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaSaleBase.contract.Call(opts, out, "isEscrowContract")
	return *ret0, err
}

// IsEscrowContract is a free data retrieval call binding the contract method 0xbfc76209.
//
// Solidity: function isEscrowContract() constant returns(bool)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) IsEscrowContract() (bool, error) {
	return _DigitalMediaSaleBase.Contract.IsEscrowContract(&_DigitalMediaSaleBase.CallOpts)
}

// IsEscrowContract is a free data retrieval call binding the contract method 0xbfc76209.
//
// Solidity: function isEscrowContract() constant returns(bool)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCallerSession) IsEscrowContract() (bool, error) {
	return _DigitalMediaSaleBase.Contract.IsEscrowContract(&_DigitalMediaSaleBase.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaSaleBase.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) Owner() (common.Address, error) {
	return _DigitalMediaSaleBase.Contract.Owner(&_DigitalMediaSaleBase.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCallerSession) Owner() (common.Address, error) {
	return _DigitalMediaSaleBase.Contract.Owner(&_DigitalMediaSaleBase.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaSaleBase.contract.Call(opts, out, "paused")
	return *ret0, err
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) Paused() (bool, error) {
	return _DigitalMediaSaleBase.Contract.Paused(&_DigitalMediaSaleBase.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseCallerSession) Paused() (bool, error) {
	return _DigitalMediaSaleBase.Contract.Paused(&_DigitalMediaSaleBase.CallOpts)
}

// AddApprovedOBO is a paid mutator transaction binding the contract method 0xcd161d2e.
//
// Solidity: function addApprovedOBO(address _oboAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactor) AddApprovedOBO(opts *bind.TransactOpts, _oboAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.contract.Transact(opts, "addApprovedOBO", _oboAddress)
}

// AddApprovedOBO is a paid mutator transaction binding the contract method 0xcd161d2e.
//
// Solidity: function addApprovedOBO(address _oboAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) AddApprovedOBO(_oboAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.AddApprovedOBO(&_DigitalMediaSaleBase.TransactOpts, _oboAddress)
}

// AddApprovedOBO is a paid mutator transaction binding the contract method 0xcd161d2e.
//
// Solidity: function addApprovedOBO(address _oboAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorSession) AddApprovedOBO(_oboAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.AddApprovedOBO(&_DigitalMediaSaleBase.TransactOpts, _oboAddress)
}

// AddApprovedTokenContract is a paid mutator transaction binding the contract method 0x12c2fdfa.
//
// Solidity: function addApprovedTokenContract(address _tokenContractAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactor) AddApprovedTokenContract(opts *bind.TransactOpts, _tokenContractAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.contract.Transact(opts, "addApprovedTokenContract", _tokenContractAddress)
}

// AddApprovedTokenContract is a paid mutator transaction binding the contract method 0x12c2fdfa.
//
// Solidity: function addApprovedTokenContract(address _tokenContractAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) AddApprovedTokenContract(_tokenContractAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.AddApprovedTokenContract(&_DigitalMediaSaleBase.TransactOpts, _tokenContractAddress)
}

// AddApprovedTokenContract is a paid mutator transaction binding the contract method 0x12c2fdfa.
//
// Solidity: function addApprovedTokenContract(address _tokenContractAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorSession) AddApprovedTokenContract(_tokenContractAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.AddApprovedTokenContract(&_DigitalMediaSaleBase.TransactOpts, _tokenContractAddress)
}

// AddApprovedWithdrawAddress is a paid mutator transaction binding the contract method 0x1a32de49.
//
// Solidity: function addApprovedWithdrawAddress(address _withdrawAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactor) AddApprovedWithdrawAddress(opts *bind.TransactOpts, _withdrawAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.contract.Transact(opts, "addApprovedWithdrawAddress", _withdrawAddress)
}

// AddApprovedWithdrawAddress is a paid mutator transaction binding the contract method 0x1a32de49.
//
// Solidity: function addApprovedWithdrawAddress(address _withdrawAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) AddApprovedWithdrawAddress(_withdrawAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.AddApprovedWithdrawAddress(&_DigitalMediaSaleBase.TransactOpts, _withdrawAddress)
}

// AddApprovedWithdrawAddress is a paid mutator transaction binding the contract method 0x1a32de49.
//
// Solidity: function addApprovedWithdrawAddress(address _withdrawAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorSession) AddApprovedWithdrawAddress(_withdrawAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.AddApprovedWithdrawAddress(&_DigitalMediaSaleBase.TransactOpts, _withdrawAddress)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xf0b9e5ba.
//
// Solidity: function onERC721Received(address , uint256 , bytes ) returns(bytes4)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactor) OnERC721Received(opts *bind.TransactOpts, arg0 common.Address, arg1 *big.Int, arg2 []byte) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.contract.Transact(opts, "onERC721Received", arg0, arg1, arg2)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xf0b9e5ba.
//
// Solidity: function onERC721Received(address , uint256 , bytes ) returns(bytes4)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) OnERC721Received(arg0 common.Address, arg1 *big.Int, arg2 []byte) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.OnERC721Received(&_DigitalMediaSaleBase.TransactOpts, arg0, arg1, arg2)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xf0b9e5ba.
//
// Solidity: function onERC721Received(address , uint256 , bytes ) returns(bytes4)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorSession) OnERC721Received(arg0 common.Address, arg1 *big.Int, arg2 []byte) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.OnERC721Received(&_DigitalMediaSaleBase.TransactOpts, arg0, arg1, arg2)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) Pause() (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.Pause(&_DigitalMediaSaleBase.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorSession) Pause() (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.Pause(&_DigitalMediaSaleBase.TransactOpts)
}

// RemoveApprovedOBO is a paid mutator transaction binding the contract method 0x7ff9f614.
//
// Solidity: function removeApprovedOBO(address _oboAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactor) RemoveApprovedOBO(opts *bind.TransactOpts, _oboAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.contract.Transact(opts, "removeApprovedOBO", _oboAddress)
}

// RemoveApprovedOBO is a paid mutator transaction binding the contract method 0x7ff9f614.
//
// Solidity: function removeApprovedOBO(address _oboAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) RemoveApprovedOBO(_oboAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.RemoveApprovedOBO(&_DigitalMediaSaleBase.TransactOpts, _oboAddress)
}

// RemoveApprovedOBO is a paid mutator transaction binding the contract method 0x7ff9f614.
//
// Solidity: function removeApprovedOBO(address _oboAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorSession) RemoveApprovedOBO(_oboAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.RemoveApprovedOBO(&_DigitalMediaSaleBase.TransactOpts, _oboAddress)
}

// RemoveApprovedTokenContract is a paid mutator transaction binding the contract method 0xd077fa5c.
//
// Solidity: function removeApprovedTokenContract(address _tokenContractAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactor) RemoveApprovedTokenContract(opts *bind.TransactOpts, _tokenContractAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.contract.Transact(opts, "removeApprovedTokenContract", _tokenContractAddress)
}

// RemoveApprovedTokenContract is a paid mutator transaction binding the contract method 0xd077fa5c.
//
// Solidity: function removeApprovedTokenContract(address _tokenContractAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) RemoveApprovedTokenContract(_tokenContractAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.RemoveApprovedTokenContract(&_DigitalMediaSaleBase.TransactOpts, _tokenContractAddress)
}

// RemoveApprovedTokenContract is a paid mutator transaction binding the contract method 0xd077fa5c.
//
// Solidity: function removeApprovedTokenContract(address _tokenContractAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorSession) RemoveApprovedTokenContract(_tokenContractAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.RemoveApprovedTokenContract(&_DigitalMediaSaleBase.TransactOpts, _tokenContractAddress)
}

// RemoveApprovedWithdrawAddress is a paid mutator transaction binding the contract method 0xe6ccc9bd.
//
// Solidity: function removeApprovedWithdrawAddress(address _withdrawAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactor) RemoveApprovedWithdrawAddress(opts *bind.TransactOpts, _withdrawAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.contract.Transact(opts, "removeApprovedWithdrawAddress", _withdrawAddress)
}

// RemoveApprovedWithdrawAddress is a paid mutator transaction binding the contract method 0xe6ccc9bd.
//
// Solidity: function removeApprovedWithdrawAddress(address _withdrawAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) RemoveApprovedWithdrawAddress(_withdrawAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.RemoveApprovedWithdrawAddress(&_DigitalMediaSaleBase.TransactOpts, _withdrawAddress)
}

// RemoveApprovedWithdrawAddress is a paid mutator transaction binding the contract method 0xe6ccc9bd.
//
// Solidity: function removeApprovedWithdrawAddress(address _withdrawAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorSession) RemoveApprovedWithdrawAddress(_withdrawAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.RemoveApprovedWithdrawAddress(&_DigitalMediaSaleBase.TransactOpts, _withdrawAddress)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.TransferOwnership(&_DigitalMediaSaleBase.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.TransferOwnership(&_DigitalMediaSaleBase.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) Unpause() (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.Unpause(&_DigitalMediaSaleBase.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorSession) Unpause() (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.Unpause(&_DigitalMediaSaleBase.TransactOpts)
}

// WithdrawFunds is a paid mutator transaction binding the contract method 0x68742da6.
//
// Solidity: function withdrawFunds(address _withdrawAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactor) WithdrawFunds(opts *bind.TransactOpts, _withdrawAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.contract.Transact(opts, "withdrawFunds", _withdrawAddress)
}

// WithdrawFunds is a paid mutator transaction binding the contract method 0x68742da6.
//
// Solidity: function withdrawFunds(address _withdrawAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseSession) WithdrawFunds(_withdrawAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.WithdrawFunds(&_DigitalMediaSaleBase.TransactOpts, _withdrawAddress)
}

// WithdrawFunds is a paid mutator transaction binding the contract method 0x68742da6.
//
// Solidity: function withdrawFunds(address _withdrawAddress) returns()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseTransactorSession) WithdrawFunds(_withdrawAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaSaleBase.Contract.WithdrawFunds(&_DigitalMediaSaleBase.TransactOpts, _withdrawAddress)
}

// DigitalMediaSaleBaseOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the DigitalMediaSaleBase contract.
type DigitalMediaSaleBaseOwnershipTransferredIterator struct {
	Event *DigitalMediaSaleBaseOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaSaleBaseOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaSaleBaseOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaSaleBaseOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaSaleBaseOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaSaleBaseOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaSaleBaseOwnershipTransferred represents a OwnershipTransferred event raised by the DigitalMediaSaleBase contract.
type DigitalMediaSaleBaseOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*DigitalMediaSaleBaseOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _DigitalMediaSaleBase.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaSaleBaseOwnershipTransferredIterator{contract: _DigitalMediaSaleBase.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *DigitalMediaSaleBaseOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _DigitalMediaSaleBase.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaSaleBaseOwnershipTransferred)
				if err := _DigitalMediaSaleBase.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) ParseOwnershipTransferred(log types.Log) (*DigitalMediaSaleBaseOwnershipTransferred, error) {
	event := new(DigitalMediaSaleBaseOwnershipTransferred)
	if err := _DigitalMediaSaleBase.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaSaleBasePauseIterator is returned from FilterPause and is used to iterate over the raw logs and unpacked data for Pause events raised by the DigitalMediaSaleBase contract.
type DigitalMediaSaleBasePauseIterator struct {
	Event *DigitalMediaSaleBasePause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaSaleBasePauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaSaleBasePause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaSaleBasePause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaSaleBasePauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaSaleBasePauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaSaleBasePause represents a Pause event raised by the DigitalMediaSaleBase contract.
type DigitalMediaSaleBasePause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPause is a free log retrieval operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) FilterPause(opts *bind.FilterOpts) (*DigitalMediaSaleBasePauseIterator, error) {

	logs, sub, err := _DigitalMediaSaleBase.contract.FilterLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaSaleBasePauseIterator{contract: _DigitalMediaSaleBase.contract, event: "Pause", logs: logs, sub: sub}, nil
}

// WatchPause is a free log subscription operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) WatchPause(opts *bind.WatchOpts, sink chan<- *DigitalMediaSaleBasePause) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaSaleBase.contract.WatchLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaSaleBasePause)
				if err := _DigitalMediaSaleBase.contract.UnpackLog(event, "Pause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePause is a log parse operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) ParsePause(log types.Log) (*DigitalMediaSaleBasePause, error) {
	event := new(DigitalMediaSaleBasePause)
	if err := _DigitalMediaSaleBase.contract.UnpackLog(event, "Pause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaSaleBaseUnpauseIterator is returned from FilterUnpause and is used to iterate over the raw logs and unpacked data for Unpause events raised by the DigitalMediaSaleBase contract.
type DigitalMediaSaleBaseUnpauseIterator struct {
	Event *DigitalMediaSaleBaseUnpause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaSaleBaseUnpauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaSaleBaseUnpause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaSaleBaseUnpause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaSaleBaseUnpauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaSaleBaseUnpauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaSaleBaseUnpause represents a Unpause event raised by the DigitalMediaSaleBase contract.
type DigitalMediaSaleBaseUnpause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUnpause is a free log retrieval operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) FilterUnpause(opts *bind.FilterOpts) (*DigitalMediaSaleBaseUnpauseIterator, error) {

	logs, sub, err := _DigitalMediaSaleBase.contract.FilterLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaSaleBaseUnpauseIterator{contract: _DigitalMediaSaleBase.contract, event: "Unpause", logs: logs, sub: sub}, nil
}

// WatchUnpause is a free log subscription operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) WatchUnpause(opts *bind.WatchOpts, sink chan<- *DigitalMediaSaleBaseUnpause) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaSaleBase.contract.WatchLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaSaleBaseUnpause)
				if err := _DigitalMediaSaleBase.contract.UnpackLog(event, "Unpause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpause is a log parse operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) ParseUnpause(log types.Log) (*DigitalMediaSaleBaseUnpause, error) {
	event := new(DigitalMediaSaleBaseUnpause)
	if err := _DigitalMediaSaleBase.contract.UnpackLog(event, "Unpause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaSaleBaseWithdrawAddressAddedIterator is returned from FilterWithdrawAddressAdded and is used to iterate over the raw logs and unpacked data for WithdrawAddressAdded events raised by the DigitalMediaSaleBase contract.
type DigitalMediaSaleBaseWithdrawAddressAddedIterator struct {
	Event *DigitalMediaSaleBaseWithdrawAddressAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaSaleBaseWithdrawAddressAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaSaleBaseWithdrawAddressAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaSaleBaseWithdrawAddressAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaSaleBaseWithdrawAddressAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaSaleBaseWithdrawAddressAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaSaleBaseWithdrawAddressAdded represents a WithdrawAddressAdded event raised by the DigitalMediaSaleBase contract.
type DigitalMediaSaleBaseWithdrawAddressAdded struct {
	WithdrawAddress common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterWithdrawAddressAdded is a free log retrieval operation binding the contract event 0xd3d6d317b22983ab294dbfe93460137c732b9644d637bfbb3258735daf17da89.
//
// Solidity: event WithdrawAddressAdded(address withdrawAddress)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) FilterWithdrawAddressAdded(opts *bind.FilterOpts) (*DigitalMediaSaleBaseWithdrawAddressAddedIterator, error) {

	logs, sub, err := _DigitalMediaSaleBase.contract.FilterLogs(opts, "WithdrawAddressAdded")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaSaleBaseWithdrawAddressAddedIterator{contract: _DigitalMediaSaleBase.contract, event: "WithdrawAddressAdded", logs: logs, sub: sub}, nil
}

// WatchWithdrawAddressAdded is a free log subscription operation binding the contract event 0xd3d6d317b22983ab294dbfe93460137c732b9644d637bfbb3258735daf17da89.
//
// Solidity: event WithdrawAddressAdded(address withdrawAddress)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) WatchWithdrawAddressAdded(opts *bind.WatchOpts, sink chan<- *DigitalMediaSaleBaseWithdrawAddressAdded) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaSaleBase.contract.WatchLogs(opts, "WithdrawAddressAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaSaleBaseWithdrawAddressAdded)
				if err := _DigitalMediaSaleBase.contract.UnpackLog(event, "WithdrawAddressAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawAddressAdded is a log parse operation binding the contract event 0xd3d6d317b22983ab294dbfe93460137c732b9644d637bfbb3258735daf17da89.
//
// Solidity: event WithdrawAddressAdded(address withdrawAddress)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) ParseWithdrawAddressAdded(log types.Log) (*DigitalMediaSaleBaseWithdrawAddressAdded, error) {
	event := new(DigitalMediaSaleBaseWithdrawAddressAdded)
	if err := _DigitalMediaSaleBase.contract.UnpackLog(event, "WithdrawAddressAdded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaSaleBaseWithdrawAddressRemovedIterator is returned from FilterWithdrawAddressRemoved and is used to iterate over the raw logs and unpacked data for WithdrawAddressRemoved events raised by the DigitalMediaSaleBase contract.
type DigitalMediaSaleBaseWithdrawAddressRemovedIterator struct {
	Event *DigitalMediaSaleBaseWithdrawAddressRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaSaleBaseWithdrawAddressRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaSaleBaseWithdrawAddressRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaSaleBaseWithdrawAddressRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaSaleBaseWithdrawAddressRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaSaleBaseWithdrawAddressRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaSaleBaseWithdrawAddressRemoved represents a WithdrawAddressRemoved event raised by the DigitalMediaSaleBase contract.
type DigitalMediaSaleBaseWithdrawAddressRemoved struct {
	WidthdrawAddress common.Address
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterWithdrawAddressRemoved is a free log retrieval operation binding the contract event 0xffdbac6a703f8c063588b1b434bac15231b40f4c20b16f797a989d47a56ae8b2.
//
// Solidity: event WithdrawAddressRemoved(address widthdrawAddress)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) FilterWithdrawAddressRemoved(opts *bind.FilterOpts) (*DigitalMediaSaleBaseWithdrawAddressRemovedIterator, error) {

	logs, sub, err := _DigitalMediaSaleBase.contract.FilterLogs(opts, "WithdrawAddressRemoved")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaSaleBaseWithdrawAddressRemovedIterator{contract: _DigitalMediaSaleBase.contract, event: "WithdrawAddressRemoved", logs: logs, sub: sub}, nil
}

// WatchWithdrawAddressRemoved is a free log subscription operation binding the contract event 0xffdbac6a703f8c063588b1b434bac15231b40f4c20b16f797a989d47a56ae8b2.
//
// Solidity: event WithdrawAddressRemoved(address widthdrawAddress)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) WatchWithdrawAddressRemoved(opts *bind.WatchOpts, sink chan<- *DigitalMediaSaleBaseWithdrawAddressRemoved) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaSaleBase.contract.WatchLogs(opts, "WithdrawAddressRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaSaleBaseWithdrawAddressRemoved)
				if err := _DigitalMediaSaleBase.contract.UnpackLog(event, "WithdrawAddressRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawAddressRemoved is a log parse operation binding the contract event 0xffdbac6a703f8c063588b1b434bac15231b40f4c20b16f797a989d47a56ae8b2.
//
// Solidity: event WithdrawAddressRemoved(address widthdrawAddress)
func (_DigitalMediaSaleBase *DigitalMediaSaleBaseFilterer) ParseWithdrawAddressRemoved(log types.Log) (*DigitalMediaSaleBaseWithdrawAddressRemoved, error) {
	event := new(DigitalMediaSaleBaseWithdrawAddressRemoved)
	if err := _DigitalMediaSaleBase.contract.UnpackLog(event, "WithdrawAddressRemoved", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaStoreInterfaceABI is the input ABI used to generate the binding from.
const DigitalMediaStoreInterfaceABI = "[{\"constant\":false,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_printIndex\",\"type\":\"uint32\"},{\"name\":\"_totalSupply\",\"type\":\"uint32\"},{\"name\":\"_collectionId\",\"type\":\"uint256\"},{\"name\":\"_metadataPath\",\"type\":\"string\"}],\"name\":\"createDigitalMedia\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_digitalMediaId\",\"type\":\"uint256\"},{\"name\":\"_increment\",\"type\":\"uint32\"}],\"name\":\"incrementDigitalMediaPrintIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_digitalMediaId\",\"type\":\"uint256\"}],\"name\":\"getDigitalMedia\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"totalSupply\",\"type\":\"uint32\"},{\"name\":\"printIndex\",\"type\":\"uint32\"},{\"name\":\"collectionId\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"metadataPath\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_collectionId\",\"type\":\"uint256\"}],\"name\":\"getCollection\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"metadataPath\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDigitalMediaStoreVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"registerTokenContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_metadataPath\",\"type\":\"string\"}],\"name\":\"createCollection\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStartingDigitalMediaId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// DigitalMediaStoreInterfaceFuncSigs maps the 4-byte function signature to its string representation.
var DigitalMediaStoreInterfaceFuncSigs = map[string]string{
	"b577fd73": "createCollection(address,string)",
	"09242ba2": "createDigitalMedia(address,uint32,uint32,uint256,string)",
	"5a1f3c28": "getCollection(uint256)",
	"55df4275": "getDigitalMedia(uint256)",
	"6c669f25": "getDigitalMediaStoreVersion()",
	"b9905d11": "getStartingDigitalMediaId()",
	"5160a124": "incrementDigitalMediaPrintIndex(uint256,uint32)",
	"a60800b8": "registerTokenContractAddress()",
}

// DigitalMediaStoreInterface is an auto generated Go binding around an Ethereum contract.
type DigitalMediaStoreInterface struct {
	DigitalMediaStoreInterfaceCaller     // Read-only binding to the contract
	DigitalMediaStoreInterfaceTransactor // Write-only binding to the contract
	DigitalMediaStoreInterfaceFilterer   // Log filterer for contract events
}

// DigitalMediaStoreInterfaceCaller is an auto generated read-only Go binding around an Ethereum contract.
type DigitalMediaStoreInterfaceCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaStoreInterfaceTransactor is an auto generated write-only Go binding around an Ethereum contract.
type DigitalMediaStoreInterfaceTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaStoreInterfaceFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type DigitalMediaStoreInterfaceFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaStoreInterfaceSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type DigitalMediaStoreInterfaceSession struct {
	Contract     *DigitalMediaStoreInterface // Generic contract binding to set the session for
	CallOpts     bind.CallOpts               // Call options to use throughout this session
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// DigitalMediaStoreInterfaceCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type DigitalMediaStoreInterfaceCallerSession struct {
	Contract *DigitalMediaStoreInterfaceCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                     // Call options to use throughout this session
}

// DigitalMediaStoreInterfaceTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type DigitalMediaStoreInterfaceTransactorSession struct {
	Contract     *DigitalMediaStoreInterfaceTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                     // Transaction auth options to use throughout this session
}

// DigitalMediaStoreInterfaceRaw is an auto generated low-level Go binding around an Ethereum contract.
type DigitalMediaStoreInterfaceRaw struct {
	Contract *DigitalMediaStoreInterface // Generic contract binding to access the raw methods on
}

// DigitalMediaStoreInterfaceCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type DigitalMediaStoreInterfaceCallerRaw struct {
	Contract *DigitalMediaStoreInterfaceCaller // Generic read-only contract binding to access the raw methods on
}

// DigitalMediaStoreInterfaceTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type DigitalMediaStoreInterfaceTransactorRaw struct {
	Contract *DigitalMediaStoreInterfaceTransactor // Generic write-only contract binding to access the raw methods on
}

// NewDigitalMediaStoreInterface creates a new instance of DigitalMediaStoreInterface, bound to a specific deployed contract.
func NewDigitalMediaStoreInterface(address common.Address, backend bind.ContractBackend) (*DigitalMediaStoreInterface, error) {
	contract, err := bindDigitalMediaStoreInterface(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaStoreInterface{DigitalMediaStoreInterfaceCaller: DigitalMediaStoreInterfaceCaller{contract: contract}, DigitalMediaStoreInterfaceTransactor: DigitalMediaStoreInterfaceTransactor{contract: contract}, DigitalMediaStoreInterfaceFilterer: DigitalMediaStoreInterfaceFilterer{contract: contract}}, nil
}

// NewDigitalMediaStoreInterfaceCaller creates a new read-only instance of DigitalMediaStoreInterface, bound to a specific deployed contract.
func NewDigitalMediaStoreInterfaceCaller(address common.Address, caller bind.ContractCaller) (*DigitalMediaStoreInterfaceCaller, error) {
	contract, err := bindDigitalMediaStoreInterface(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaStoreInterfaceCaller{contract: contract}, nil
}

// NewDigitalMediaStoreInterfaceTransactor creates a new write-only instance of DigitalMediaStoreInterface, bound to a specific deployed contract.
func NewDigitalMediaStoreInterfaceTransactor(address common.Address, transactor bind.ContractTransactor) (*DigitalMediaStoreInterfaceTransactor, error) {
	contract, err := bindDigitalMediaStoreInterface(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaStoreInterfaceTransactor{contract: contract}, nil
}

// NewDigitalMediaStoreInterfaceFilterer creates a new log filterer instance of DigitalMediaStoreInterface, bound to a specific deployed contract.
func NewDigitalMediaStoreInterfaceFilterer(address common.Address, filterer bind.ContractFilterer) (*DigitalMediaStoreInterfaceFilterer, error) {
	contract, err := bindDigitalMediaStoreInterface(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaStoreInterfaceFilterer{contract: contract}, nil
}

// bindDigitalMediaStoreInterface binds a generic wrapper to an already deployed contract.
func bindDigitalMediaStoreInterface(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(DigitalMediaStoreInterfaceABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _DigitalMediaStoreInterface.Contract.DigitalMediaStoreInterfaceCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.Contract.DigitalMediaStoreInterfaceTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.Contract.DigitalMediaStoreInterfaceTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _DigitalMediaStoreInterface.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.Contract.contract.Transact(opts, method, params...)
}

// GetCollection is a free data retrieval call binding the contract method 0x5a1f3c28.
//
// Solidity: function getCollection(uint256 _collectionId) constant returns(uint256 id, address creator, string metadataPath)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceCaller) GetCollection(opts *bind.CallOpts, _collectionId *big.Int) (struct {
	Id           *big.Int
	Creator      common.Address
	MetadataPath string
}, error) {
	ret := new(struct {
		Id           *big.Int
		Creator      common.Address
		MetadataPath string
	})
	out := ret
	err := _DigitalMediaStoreInterface.contract.Call(opts, out, "getCollection", _collectionId)
	return *ret, err
}

// GetCollection is a free data retrieval call binding the contract method 0x5a1f3c28.
//
// Solidity: function getCollection(uint256 _collectionId) constant returns(uint256 id, address creator, string metadataPath)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceSession) GetCollection(_collectionId *big.Int) (struct {
	Id           *big.Int
	Creator      common.Address
	MetadataPath string
}, error) {
	return _DigitalMediaStoreInterface.Contract.GetCollection(&_DigitalMediaStoreInterface.CallOpts, _collectionId)
}

// GetCollection is a free data retrieval call binding the contract method 0x5a1f3c28.
//
// Solidity: function getCollection(uint256 _collectionId) constant returns(uint256 id, address creator, string metadataPath)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceCallerSession) GetCollection(_collectionId *big.Int) (struct {
	Id           *big.Int
	Creator      common.Address
	MetadataPath string
}, error) {
	return _DigitalMediaStoreInterface.Contract.GetCollection(&_DigitalMediaStoreInterface.CallOpts, _collectionId)
}

// GetDigitalMedia is a free data retrieval call binding the contract method 0x55df4275.
//
// Solidity: function getDigitalMedia(uint256 _digitalMediaId) constant returns(uint256 id, uint32 totalSupply, uint32 printIndex, uint256 collectionId, address creator, string metadataPath)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceCaller) GetDigitalMedia(opts *bind.CallOpts, _digitalMediaId *big.Int) (struct {
	Id           *big.Int
	TotalSupply  uint32
	PrintIndex   uint32
	CollectionId *big.Int
	Creator      common.Address
	MetadataPath string
}, error) {
	ret := new(struct {
		Id           *big.Int
		TotalSupply  uint32
		PrintIndex   uint32
		CollectionId *big.Int
		Creator      common.Address
		MetadataPath string
	})
	out := ret
	err := _DigitalMediaStoreInterface.contract.Call(opts, out, "getDigitalMedia", _digitalMediaId)
	return *ret, err
}

// GetDigitalMedia is a free data retrieval call binding the contract method 0x55df4275.
//
// Solidity: function getDigitalMedia(uint256 _digitalMediaId) constant returns(uint256 id, uint32 totalSupply, uint32 printIndex, uint256 collectionId, address creator, string metadataPath)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceSession) GetDigitalMedia(_digitalMediaId *big.Int) (struct {
	Id           *big.Int
	TotalSupply  uint32
	PrintIndex   uint32
	CollectionId *big.Int
	Creator      common.Address
	MetadataPath string
}, error) {
	return _DigitalMediaStoreInterface.Contract.GetDigitalMedia(&_DigitalMediaStoreInterface.CallOpts, _digitalMediaId)
}

// GetDigitalMedia is a free data retrieval call binding the contract method 0x55df4275.
//
// Solidity: function getDigitalMedia(uint256 _digitalMediaId) constant returns(uint256 id, uint32 totalSupply, uint32 printIndex, uint256 collectionId, address creator, string metadataPath)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceCallerSession) GetDigitalMedia(_digitalMediaId *big.Int) (struct {
	Id           *big.Int
	TotalSupply  uint32
	PrintIndex   uint32
	CollectionId *big.Int
	Creator      common.Address
	MetadataPath string
}, error) {
	return _DigitalMediaStoreInterface.Contract.GetDigitalMedia(&_DigitalMediaStoreInterface.CallOpts, _digitalMediaId)
}

// GetDigitalMediaStoreVersion is a free data retrieval call binding the contract method 0x6c669f25.
//
// Solidity: function getDigitalMediaStoreVersion() constant returns(uint256)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceCaller) GetDigitalMediaStoreVersion(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaStoreInterface.contract.Call(opts, out, "getDigitalMediaStoreVersion")
	return *ret0, err
}

// GetDigitalMediaStoreVersion is a free data retrieval call binding the contract method 0x6c669f25.
//
// Solidity: function getDigitalMediaStoreVersion() constant returns(uint256)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceSession) GetDigitalMediaStoreVersion() (*big.Int, error) {
	return _DigitalMediaStoreInterface.Contract.GetDigitalMediaStoreVersion(&_DigitalMediaStoreInterface.CallOpts)
}

// GetDigitalMediaStoreVersion is a free data retrieval call binding the contract method 0x6c669f25.
//
// Solidity: function getDigitalMediaStoreVersion() constant returns(uint256)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceCallerSession) GetDigitalMediaStoreVersion() (*big.Int, error) {
	return _DigitalMediaStoreInterface.Contract.GetDigitalMediaStoreVersion(&_DigitalMediaStoreInterface.CallOpts)
}

// GetStartingDigitalMediaId is a free data retrieval call binding the contract method 0xb9905d11.
//
// Solidity: function getStartingDigitalMediaId() constant returns(uint256)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceCaller) GetStartingDigitalMediaId(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaStoreInterface.contract.Call(opts, out, "getStartingDigitalMediaId")
	return *ret0, err
}

// GetStartingDigitalMediaId is a free data retrieval call binding the contract method 0xb9905d11.
//
// Solidity: function getStartingDigitalMediaId() constant returns(uint256)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceSession) GetStartingDigitalMediaId() (*big.Int, error) {
	return _DigitalMediaStoreInterface.Contract.GetStartingDigitalMediaId(&_DigitalMediaStoreInterface.CallOpts)
}

// GetStartingDigitalMediaId is a free data retrieval call binding the contract method 0xb9905d11.
//
// Solidity: function getStartingDigitalMediaId() constant returns(uint256)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceCallerSession) GetStartingDigitalMediaId() (*big.Int, error) {
	return _DigitalMediaStoreInterface.Contract.GetStartingDigitalMediaId(&_DigitalMediaStoreInterface.CallOpts)
}

// CreateCollection is a paid mutator transaction binding the contract method 0xb577fd73.
//
// Solidity: function createCollection(address _creator, string _metadataPath) returns(uint256)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceTransactor) CreateCollection(opts *bind.TransactOpts, _creator common.Address, _metadataPath string) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.contract.Transact(opts, "createCollection", _creator, _metadataPath)
}

// CreateCollection is a paid mutator transaction binding the contract method 0xb577fd73.
//
// Solidity: function createCollection(address _creator, string _metadataPath) returns(uint256)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceSession) CreateCollection(_creator common.Address, _metadataPath string) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.Contract.CreateCollection(&_DigitalMediaStoreInterface.TransactOpts, _creator, _metadataPath)
}

// CreateCollection is a paid mutator transaction binding the contract method 0xb577fd73.
//
// Solidity: function createCollection(address _creator, string _metadataPath) returns(uint256)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceTransactorSession) CreateCollection(_creator common.Address, _metadataPath string) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.Contract.CreateCollection(&_DigitalMediaStoreInterface.TransactOpts, _creator, _metadataPath)
}

// CreateDigitalMedia is a paid mutator transaction binding the contract method 0x09242ba2.
//
// Solidity: function createDigitalMedia(address _creator, uint32 _printIndex, uint32 _totalSupply, uint256 _collectionId, string _metadataPath) returns(uint256)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceTransactor) CreateDigitalMedia(opts *bind.TransactOpts, _creator common.Address, _printIndex uint32, _totalSupply uint32, _collectionId *big.Int, _metadataPath string) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.contract.Transact(opts, "createDigitalMedia", _creator, _printIndex, _totalSupply, _collectionId, _metadataPath)
}

// CreateDigitalMedia is a paid mutator transaction binding the contract method 0x09242ba2.
//
// Solidity: function createDigitalMedia(address _creator, uint32 _printIndex, uint32 _totalSupply, uint256 _collectionId, string _metadataPath) returns(uint256)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceSession) CreateDigitalMedia(_creator common.Address, _printIndex uint32, _totalSupply uint32, _collectionId *big.Int, _metadataPath string) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.Contract.CreateDigitalMedia(&_DigitalMediaStoreInterface.TransactOpts, _creator, _printIndex, _totalSupply, _collectionId, _metadataPath)
}

// CreateDigitalMedia is a paid mutator transaction binding the contract method 0x09242ba2.
//
// Solidity: function createDigitalMedia(address _creator, uint32 _printIndex, uint32 _totalSupply, uint256 _collectionId, string _metadataPath) returns(uint256)
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceTransactorSession) CreateDigitalMedia(_creator common.Address, _printIndex uint32, _totalSupply uint32, _collectionId *big.Int, _metadataPath string) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.Contract.CreateDigitalMedia(&_DigitalMediaStoreInterface.TransactOpts, _creator, _printIndex, _totalSupply, _collectionId, _metadataPath)
}

// IncrementDigitalMediaPrintIndex is a paid mutator transaction binding the contract method 0x5160a124.
//
// Solidity: function incrementDigitalMediaPrintIndex(uint256 _digitalMediaId, uint32 _increment) returns()
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceTransactor) IncrementDigitalMediaPrintIndex(opts *bind.TransactOpts, _digitalMediaId *big.Int, _increment uint32) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.contract.Transact(opts, "incrementDigitalMediaPrintIndex", _digitalMediaId, _increment)
}

// IncrementDigitalMediaPrintIndex is a paid mutator transaction binding the contract method 0x5160a124.
//
// Solidity: function incrementDigitalMediaPrintIndex(uint256 _digitalMediaId, uint32 _increment) returns()
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceSession) IncrementDigitalMediaPrintIndex(_digitalMediaId *big.Int, _increment uint32) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.Contract.IncrementDigitalMediaPrintIndex(&_DigitalMediaStoreInterface.TransactOpts, _digitalMediaId, _increment)
}

// IncrementDigitalMediaPrintIndex is a paid mutator transaction binding the contract method 0x5160a124.
//
// Solidity: function incrementDigitalMediaPrintIndex(uint256 _digitalMediaId, uint32 _increment) returns()
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceTransactorSession) IncrementDigitalMediaPrintIndex(_digitalMediaId *big.Int, _increment uint32) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.Contract.IncrementDigitalMediaPrintIndex(&_DigitalMediaStoreInterface.TransactOpts, _digitalMediaId, _increment)
}

// RegisterTokenContractAddress is a paid mutator transaction binding the contract method 0xa60800b8.
//
// Solidity: function registerTokenContractAddress() returns()
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceTransactor) RegisterTokenContractAddress(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.contract.Transact(opts, "registerTokenContractAddress")
}

// RegisterTokenContractAddress is a paid mutator transaction binding the contract method 0xa60800b8.
//
// Solidity: function registerTokenContractAddress() returns()
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceSession) RegisterTokenContractAddress() (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.Contract.RegisterTokenContractAddress(&_DigitalMediaStoreInterface.TransactOpts)
}

// RegisterTokenContractAddress is a paid mutator transaction binding the contract method 0xa60800b8.
//
// Solidity: function registerTokenContractAddress() returns()
func (_DigitalMediaStoreInterface *DigitalMediaStoreInterfaceTransactorSession) RegisterTokenContractAddress() (*types.Transaction, error) {
	return _DigitalMediaStoreInterface.Contract.RegisterTokenContractAddress(&_DigitalMediaStoreInterface.TransactOpts)
}

// DigitalMediaTokenABI is the input ABI used to generate the binding from.
const DigitalMediaTokenABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"currentStartingDigitalMediaId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"singleCreatorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentDigitalMediaStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToDigitalMediaRelease\",\"outputs\":[{\"name\":\"printEdition\",\"type\":\"uint32\"},{\"name\":\"digitalMediaId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedCreators\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dmsAddress\",\"type\":\"address\"}],\"name\":\"setV1DigitalMediaStoreAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"v1DigitalMediaStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCreatorAddress\",\"type\":\"address\"}],\"name\":\"changeSingleCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creatorRegistryStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"name\":\"_tokenIdStartingCounter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"printEdition\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"tokenURI\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"digitalMediaId\",\"type\":\"uint256\"}],\"name\":\"DigitalMediaReleaseCreateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"storeContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"printIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"collectionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"metadataPath\",\"type\":\"string\"}],\"name\":\"DigitalMediaCreateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"storeContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"metadataPath\",\"type\":\"string\"}],\"name\":\"DigitalMediaCollectionCreateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"storeContractAddress\",\"type\":\"address\"}],\"name\":\"DigitalMediaBurnEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"DigitalMediaReleaseBurnEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"digitalMediaId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"printEdition\",\"type\":\"uint32\"}],\"name\":\"UpdateDigitalMediaPrintIndexEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCreator\",\"type\":\"address\"}],\"name\":\"ChangedCreator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousCreatorAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newCreatorAddress\",\"type\":\"address\"}],\"name\":\"SingleCreatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]"

// DigitalMediaTokenFuncSigs maps the 4-byte function signature to its string representation.
var DigitalMediaTokenFuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"55232467": "approvedCreators(address)",
	"70a08231": "balanceOf(address)",
	"a7df572c": "changeSingleCreator(address)",
	"b39ba60a": "creatorRegistryStore()",
	"1b284e75": "currentDigitalMediaStore()",
	"0154788d": "currentStartingDigitalMediaId()",
	"4f558e79": "exists(uint256)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"06fdde03": "name()",
	"8da5cb5b": "owner()",
	"6352211e": "ownerOf(uint256)",
	"8456cb59": "pause()",
	"5c975abb": "paused()",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"91c60788": "setV1DigitalMediaStoreAddress(address)",
	"147ca2af": "singleCreatorAddress()",
	"01ffc9a7": "supportsInterface(bytes4)",
	"95d89b41": "symbol()",
	"4f6ccce7": "tokenByIndex(uint256)",
	"3db57cbe": "tokenIdToDigitalMediaRelease(uint256)",
	"2f745c59": "tokenOfOwnerByIndex(address,uint256)",
	"c87b56dd": "tokenURI(uint256)",
	"18160ddd": "totalSupply()",
	"23b872dd": "transferFrom(address,address,uint256)",
	"f2fde38b": "transferOwnership(address)",
	"3f4ba83a": "unpause()",
	"a0f01e08": "v1DigitalMediaStore()",
}

// DigitalMediaTokenBin is the compiled bytecode used for deploying new contracts.
var DigitalMediaTokenBin = "0x60806040526000805460a060020a60ff02191681556013553480156200002457600080fd5b506040516200197d3803806200197d83398101604090815281516020808401519284015160008054600160a060020a03191633179055918401805190949390930192849184916200007c9160099190850190620000a1565b5080516200009290600a906020840190620000a1565b50505060135550620001469050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10620000e457805160ff191683800117855562000114565b8280016001018555821562000114579182015b8281111562000114578251825591602001919060010190620000f7565b506200012292915062000126565b5090565b6200014391905b808211156200012257600081556001016200012d565b90565b61182780620001566000396000f3006080604052600436106101715763ffffffff60e060020a6000350416630154788d811461017657806301ffc9a71461019d57806306fdde03146101d3578063081812fc1461025d578063095ea7b314610291578063147ca2af146102b757806318160ddd146102cc5780631b284e75146102e157806323b872dd146102f65780632f745c59146103205780633db57cbe146103445780633f4ba83a1461037c57806342842e0e146103915780634f558e79146103bb5780634f6ccce7146103d357806355232467146103eb5780635c975abb1461040c5780636352211e1461042157806370a08231146104395780638456cb591461045a5780638da5cb5b1461046f57806391c607881461048457806395d89b41146104a5578063a0f01e08146104ba578063a22cb465146104cf578063a7df572c146104f5578063b39ba60a14610516578063b88d4fde1461052b578063c87b56dd1461059a578063e985e9c5146105b2578063f2fde38b146105d9575b600080fd5b34801561018257600080fd5b5061018b6105fa565b60408051918252519081900360200190f35b3480156101a957600080fd5b506101bf600160e060020a031960043516610600565b604080519115158252519081900360200190f35b3480156101df57600080fd5b506101e86107da565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561022257818101518382015260200161020a565b50505050905090810190601f16801561024f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561026957600080fd5b50610275600435610871565b60408051600160a060020a039092168252519081900360200190f35b34801561029d57600080fd5b506102b5600160a060020a036004351660243561088c565b005b3480156102c357600080fd5b50610275610971565b3480156102d857600080fd5b5061018b610980565b3480156102ed57600080fd5b50610275610986565b34801561030257600080fd5b506102b5600160a060020a0360043581169060243516604435610995565b34801561032c57600080fd5b5061018b600160a060020a0360043516602435610a44565b34801561035057600080fd5b5061035c600435610a91565b6040805163ffffffff909316835260208301919091528051918290030190f35b34801561038857600080fd5b506102b5610ab3565b34801561039d57600080fd5b506102b5600160a060020a0360043581169060243516604435610b3a565b3480156103c757600080fd5b506101bf600435610b72565b3480156103df57600080fd5b5061018b600435610b8f565b3480156103f757600080fd5b50610275600160a060020a0360043516610bc4565b34801561041857600080fd5b506101bf610bdf565b34801561042d57600080fd5b50610275600435610c00565b34801561044557600080fd5b5061018b600160a060020a0360043516610c24565b34801561046657600080fd5b506102b5610c57565b34801561047b57600080fd5b50610275610cf4565b34801561049057600080fd5b506102b5600160a060020a0360043516610d03565b3480156104b157600080fd5b506101e8610f00565b3480156104c657600080fd5b50610275610f61565b3480156104db57600080fd5b506102b5600160a060020a03600435166024351515610f70565b34801561050157600080fd5b506102b5600160a060020a0360043516610ff4565b34801561052257600080fd5b506102756110f8565b34801561053757600080fd5b50604080516020601f6064356004818101359283018490048402850184019095528184526102b594600160a060020a0381358116956024803590921695604435953695608494019181908401838280828437509497506111079650505050505050565b3480156105a657600080fd5b506101e8600435611146565b3480156105be57600080fd5b506101bf600160a060020a03600435811690602435166111fb565b3480156105e557600080fd5b506102b5600160a060020a0360043516611229565b60035481565b604080517f737570706f727473496e7465726661636528627974657334290000000000000081529051908190036019019020600090600160e060020a0319838116911614806107d45750604080517f736166655472616e7366657246726f6d28616464726573732c6164647265737381527f2c75696e74323536290000000000000000000000000000000000000000000000602082015281519081900360290181207f617070726f766528616464726573732c75696e74323536290000000000000000825282519182900360180182207f6f776e65724f662875696e743235362900000000000000000000000000000000835283519283900360100183207f62616c616e63654f662861646472657373290000000000000000000000000000845284519384900360120184207f746f74616c537570706c792829000000000000000000000000000000000000008552855194859003600d0185207f73796d626f6c2829000000000000000000000000000000000000000000000000865286519586900360080186207f6e616d65282900000000000000000000000000000000000000000000000000008752965195869003600601909520600160e060020a0319898116919097189095181818181891909116145b92915050565b60098054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152606093909290918301828280156108665780601f1061083b57610100808354040283529160200191610866565b820191906000526020600020905b81548152906001019060200180831161084957829003601f168201915b505050505090505b90565b600090815260066020526040902054600160a060020a031690565b600061089782610c00565b9050600160a060020a0383811690821614156108b257600080fd5b33600160a060020a03821614806108ce57506108ce81336111fb565b15156108d957600080fd5b60006108e483610871565b600160a060020a03161415806109025750600160a060020a03831615155b1561096c576000828152600660209081526040918290208054600160a060020a031916600160a060020a03878116918217909255835186815293519093918516927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a35b505050565b601054600160a060020a031681565b600d5490565b600254600160a060020a031681565b806109a033826112b0565b15156109ab57600080fd5b600160a060020a03841615156109c057600080fd5b600160a060020a03831615156109d557600080fd5b6109df848361130f565b6109e984836113b0565b6109f383836114e9565b82600160a060020a031684600160a060020a03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a350505050565b6000610a4f83610c24565b8210610a5a57600080fd5b600160a060020a0383166000908152600b60205260409020805483908110610a7e57fe5b9060005260206000200154905092915050565b6011602052600090815260409020805460019091015463ffffffff9091169082565b600054600160a060020a03163314610aca57600080fd5b60005474010000000000000000000000000000000000000000900460ff161515610af357600080fd5b6000805474ff0000000000000000000000000000000000000000191681556040517f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b339190a1565b80610b4533826112b0565b1515610b5057600080fd5b610b6c8484846020604051908101604052806000815250611107565b50505050565b600090815260056020526040902054600160a060020a0316151590565b6000610b99610980565b8210610ba457600080fd5b600d805483908110610bb257fe5b90600052602060002001549050919050565b601260205260009081526040902054600160a060020a031681565b60005474010000000000000000000000000000000000000000900460ff1681565b600081815260056020526040812054600160a060020a03168015156107d457600080fd5b6000600160a060020a0382161515610c3b57600080fd5b50600160a060020a031660009081526007602052604090205490565b600054600160a060020a03163314610c6e57600080fd5b60005474010000000000000000000000000000000000000000900460ff1615610c9657600080fd5b6000805474ff00000000000000000000000000000000000000001916740100000000000000000000000000000000000000001781556040517f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff6259190a1565b600054600160a060020a031681565b60008054600160a060020a03163314610d1b57600080fd5b600154600160a060020a031615610d9357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f5631206d656469612073746f726520616c7265616479207365742e0000000000604482015290519081900360640190fd5b81905080600160a060020a0316636c669f256040518163ffffffff1660e060020a028152600401602060405180830381600087803b158015610dd457600080fd5b505af1158015610de8573d6000803e3d6000fd5b505050506040513d6020811015610dfe57600080fd5b5051600114610e6e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e636f72726563742076657273696f6e2e0000000000000000000000000000604482015290519081900360640190fd5b60018054600160a060020a031916600160a060020a038381169190911791829055604080517fa60800b80000000000000000000000000000000000000000000000000000000081529051929091169163a60800b89160048082019260009290919082900301818387803b158015610ee457600080fd5b505af1158015610ef8573d6000803e3d6000fd5b505050505050565b600a8054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152606093909290918301828280156108665780601f1061083b57610100808354040283529160200191610866565b600154600160a060020a031681565b600160a060020a038216331415610f8657600080fd5b336000818152600860209081526040808320600160a060020a03871680855290835292819020805460ff1916861515908117909155815190815290519293927f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31929181900390910190a35050565b600160a060020a038116151561100957600080fd5b601054600160a060020a031633146110a857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4e6f7420617070726f76656420746f206368616e67652073696e676c6520637260448201527f6561746f722e0000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b60108054600160a060020a031916600160a060020a0383811691821792839055604051919216907f384c948063df3740539b4b000658c1a22348e7f18c87f808085662e461e48e7190600090a350565b600454600160a060020a031681565b8161111233826112b0565b151561111d57600080fd5b611128858585610995565b61113485858585611532565b151561113f57600080fd5b5050505050565b606061115182610b72565b151561115c57600080fd5b6000828152600f602090815260409182902080548351601f6002600019610100600186161502019093169290920491820184900484028101840190945280845290918301828280156111ef5780601f106111c4576101008083540402835291602001916111ef565b820191906000526020600020905b8154815290600101906020018083116111d257829003601f168201915b50505050509050919050565b600160a060020a03918216600090815260086020908152604080832093909416825291909152205460ff1690565b600054600160a060020a0316331461124057600080fd5b600160a060020a038116151561125557600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a360008054600160a060020a031916600160a060020a0392909216919091179055565b6000806112bc83610c00565b905080600160a060020a031684600160a060020a031614806112f7575083600160a060020a03166112ec84610871565b600160a060020a0316145b80611307575061130781856111fb565b949350505050565b81600160a060020a031661132282610c00565b600160a060020a03161461133557600080fd5b600081815260066020526040902054600160a060020a0316156113ac5760008181526006602090815260408083208054600160a060020a031916905580518481529051600160a060020a038616927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a35b5050565b60008060006113bf858561168a565b6000848152600c6020908152604080832054600160a060020a0389168452600b909252909120549093506113fa90600163ffffffff61171316565b600160a060020a0386166000908152600b602052604090208054919350908390811061142257fe5b9060005260206000200154905080600b600087600160a060020a0316600160a060020a031681526020019081526020016000208481548110151561146257fe5b6000918252602080832090910192909255600160a060020a0387168152600b9091526040812080548490811061149457fe5b6000918252602080832090910192909255600160a060020a0387168152600b909152604090208054906114cb9060001983016117be565b506000938452600c6020526040808520859055908452909220555050565b60006114f58383611725565b50600160a060020a039091166000908152600b6020908152604080832080546001810182559084528284208101859055938352600c909152902055565b60008061154785600160a060020a03166117a9565b15156115565760019150611681565b84600160a060020a031663f0b9e5ba8786866040518463ffffffff1660e060020a0281526004018084600160a060020a0316600160a060020a0316815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b838110156115d55781810151838201526020016115bd565b50505050905090810190601f1680156116025780820380516001836020036101000a031916815260200191505b50945050505050602060405180830381600087803b15801561162357600080fd5b505af1158015611637573d6000803e3d6000fd5b505050506040513d602081101561164d57600080fd5b5051600160e060020a031981167ff0b9e5ba0000000000000000000000000000000000000000000000000000000014925090505b50949350505050565b81600160a060020a031661169d82610c00565b600160a060020a0316146116b057600080fd5b600160a060020a0382166000908152600760205260409020546116da90600163ffffffff61171316565b600160a060020a039092166000908152600760209081526040808320949094559181526005909152208054600160a060020a0319169055565b60008282111561171f57fe5b50900390565b600081815260056020526040902054600160a060020a03161561174757600080fd5b60008181526005602090815260408083208054600160a060020a031916600160a060020a038716908117909155835260079091529020546117899060016117b1565b600160a060020a0390921660009081526007602052604090209190915550565b6000903b1190565b818101828110156107d457fe5b81548183558181111561096c5760008381526020902061096c91810190830161086e91905b808211156117f757600081556001016117e3565b50905600a165627a7a72305820e18060e82f08fc26123b1dbb16cfee3d1b7e0f3f1a57838ec2faab330b787c490029"

// DeployDigitalMediaToken deploys a new Ethereum contract, binding an instance of DigitalMediaToken to it.
func DeployDigitalMediaToken(auth *bind.TransactOpts, backend bind.ContractBackend, _tokenName string, _tokenSymbol string, _tokenIdStartingCounter *big.Int) (common.Address, *types.Transaction, *DigitalMediaToken, error) {
	parsed, err := abi.JSON(strings.NewReader(DigitalMediaTokenABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(DigitalMediaTokenBin), backend, _tokenName, _tokenSymbol, _tokenIdStartingCounter)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &DigitalMediaToken{DigitalMediaTokenCaller: DigitalMediaTokenCaller{contract: contract}, DigitalMediaTokenTransactor: DigitalMediaTokenTransactor{contract: contract}, DigitalMediaTokenFilterer: DigitalMediaTokenFilterer{contract: contract}}, nil
}

// DigitalMediaToken is an auto generated Go binding around an Ethereum contract.
type DigitalMediaToken struct {
	DigitalMediaTokenCaller     // Read-only binding to the contract
	DigitalMediaTokenTransactor // Write-only binding to the contract
	DigitalMediaTokenFilterer   // Log filterer for contract events
}

// DigitalMediaTokenCaller is an auto generated read-only Go binding around an Ethereum contract.
type DigitalMediaTokenCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaTokenTransactor is an auto generated write-only Go binding around an Ethereum contract.
type DigitalMediaTokenTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaTokenFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type DigitalMediaTokenFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DigitalMediaTokenSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type DigitalMediaTokenSession struct {
	Contract     *DigitalMediaToken // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// DigitalMediaTokenCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type DigitalMediaTokenCallerSession struct {
	Contract *DigitalMediaTokenCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// DigitalMediaTokenTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type DigitalMediaTokenTransactorSession struct {
	Contract     *DigitalMediaTokenTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// DigitalMediaTokenRaw is an auto generated low-level Go binding around an Ethereum contract.
type DigitalMediaTokenRaw struct {
	Contract *DigitalMediaToken // Generic contract binding to access the raw methods on
}

// DigitalMediaTokenCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type DigitalMediaTokenCallerRaw struct {
	Contract *DigitalMediaTokenCaller // Generic read-only contract binding to access the raw methods on
}

// DigitalMediaTokenTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type DigitalMediaTokenTransactorRaw struct {
	Contract *DigitalMediaTokenTransactor // Generic write-only contract binding to access the raw methods on
}

// NewDigitalMediaToken creates a new instance of DigitalMediaToken, bound to a specific deployed contract.
func NewDigitalMediaToken(address common.Address, backend bind.ContractBackend) (*DigitalMediaToken, error) {
	contract, err := bindDigitalMediaToken(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaToken{DigitalMediaTokenCaller: DigitalMediaTokenCaller{contract: contract}, DigitalMediaTokenTransactor: DigitalMediaTokenTransactor{contract: contract}, DigitalMediaTokenFilterer: DigitalMediaTokenFilterer{contract: contract}}, nil
}

// NewDigitalMediaTokenCaller creates a new read-only instance of DigitalMediaToken, bound to a specific deployed contract.
func NewDigitalMediaTokenCaller(address common.Address, caller bind.ContractCaller) (*DigitalMediaTokenCaller, error) {
	contract, err := bindDigitalMediaToken(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenCaller{contract: contract}, nil
}

// NewDigitalMediaTokenTransactor creates a new write-only instance of DigitalMediaToken, bound to a specific deployed contract.
func NewDigitalMediaTokenTransactor(address common.Address, transactor bind.ContractTransactor) (*DigitalMediaTokenTransactor, error) {
	contract, err := bindDigitalMediaToken(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenTransactor{contract: contract}, nil
}

// NewDigitalMediaTokenFilterer creates a new log filterer instance of DigitalMediaToken, bound to a specific deployed contract.
func NewDigitalMediaTokenFilterer(address common.Address, filterer bind.ContractFilterer) (*DigitalMediaTokenFilterer, error) {
	contract, err := bindDigitalMediaToken(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenFilterer{contract: contract}, nil
}

// bindDigitalMediaToken binds a generic wrapper to an already deployed contract.
func bindDigitalMediaToken(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(DigitalMediaTokenABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DigitalMediaToken *DigitalMediaTokenRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _DigitalMediaToken.Contract.DigitalMediaTokenCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DigitalMediaToken *DigitalMediaTokenRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.DigitalMediaTokenTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DigitalMediaToken *DigitalMediaTokenRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.DigitalMediaTokenTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DigitalMediaToken *DigitalMediaTokenCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _DigitalMediaToken.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DigitalMediaToken *DigitalMediaTokenTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DigitalMediaToken *DigitalMediaTokenTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.contract.Transact(opts, method, params...)
}

// ApprovedCreators is a free data retrieval call binding the contract method 0x55232467.
//
// Solidity: function approvedCreators(address ) constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCaller) ApprovedCreators(opts *bind.CallOpts, arg0 common.Address) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "approvedCreators", arg0)
	return *ret0, err
}

// ApprovedCreators is a free data retrieval call binding the contract method 0x55232467.
//
// Solidity: function approvedCreators(address ) constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenSession) ApprovedCreators(arg0 common.Address) (common.Address, error) {
	return _DigitalMediaToken.Contract.ApprovedCreators(&_DigitalMediaToken.CallOpts, arg0)
}

// ApprovedCreators is a free data retrieval call binding the contract method 0x55232467.
//
// Solidity: function approvedCreators(address ) constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) ApprovedCreators(arg0 common.Address) (common.Address, error) {
	return _DigitalMediaToken.Contract.ApprovedCreators(&_DigitalMediaToken.CallOpts, arg0)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenCaller) BalanceOf(opts *bind.CallOpts, _owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "balanceOf", _owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _DigitalMediaToken.Contract.BalanceOf(&_DigitalMediaToken.CallOpts, _owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _DigitalMediaToken.Contract.BalanceOf(&_DigitalMediaToken.CallOpts, _owner)
}

// CreatorRegistryStore is a free data retrieval call binding the contract method 0xb39ba60a.
//
// Solidity: function creatorRegistryStore() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCaller) CreatorRegistryStore(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "creatorRegistryStore")
	return *ret0, err
}

// CreatorRegistryStore is a free data retrieval call binding the contract method 0xb39ba60a.
//
// Solidity: function creatorRegistryStore() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenSession) CreatorRegistryStore() (common.Address, error) {
	return _DigitalMediaToken.Contract.CreatorRegistryStore(&_DigitalMediaToken.CallOpts)
}

// CreatorRegistryStore is a free data retrieval call binding the contract method 0xb39ba60a.
//
// Solidity: function creatorRegistryStore() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) CreatorRegistryStore() (common.Address, error) {
	return _DigitalMediaToken.Contract.CreatorRegistryStore(&_DigitalMediaToken.CallOpts)
}

// CurrentDigitalMediaStore is a free data retrieval call binding the contract method 0x1b284e75.
//
// Solidity: function currentDigitalMediaStore() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCaller) CurrentDigitalMediaStore(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "currentDigitalMediaStore")
	return *ret0, err
}

// CurrentDigitalMediaStore is a free data retrieval call binding the contract method 0x1b284e75.
//
// Solidity: function currentDigitalMediaStore() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenSession) CurrentDigitalMediaStore() (common.Address, error) {
	return _DigitalMediaToken.Contract.CurrentDigitalMediaStore(&_DigitalMediaToken.CallOpts)
}

// CurrentDigitalMediaStore is a free data retrieval call binding the contract method 0x1b284e75.
//
// Solidity: function currentDigitalMediaStore() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) CurrentDigitalMediaStore() (common.Address, error) {
	return _DigitalMediaToken.Contract.CurrentDigitalMediaStore(&_DigitalMediaToken.CallOpts)
}

// CurrentStartingDigitalMediaId is a free data retrieval call binding the contract method 0x0154788d.
//
// Solidity: function currentStartingDigitalMediaId() constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenCaller) CurrentStartingDigitalMediaId(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "currentStartingDigitalMediaId")
	return *ret0, err
}

// CurrentStartingDigitalMediaId is a free data retrieval call binding the contract method 0x0154788d.
//
// Solidity: function currentStartingDigitalMediaId() constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenSession) CurrentStartingDigitalMediaId() (*big.Int, error) {
	return _DigitalMediaToken.Contract.CurrentStartingDigitalMediaId(&_DigitalMediaToken.CallOpts)
}

// CurrentStartingDigitalMediaId is a free data retrieval call binding the contract method 0x0154788d.
//
// Solidity: function currentStartingDigitalMediaId() constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) CurrentStartingDigitalMediaId() (*big.Int, error) {
	return _DigitalMediaToken.Contract.CurrentStartingDigitalMediaId(&_DigitalMediaToken.CallOpts)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_DigitalMediaToken *DigitalMediaTokenCaller) Exists(opts *bind.CallOpts, _tokenId *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "exists", _tokenId)
	return *ret0, err
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_DigitalMediaToken *DigitalMediaTokenSession) Exists(_tokenId *big.Int) (bool, error) {
	return _DigitalMediaToken.Contract.Exists(&_DigitalMediaToken.CallOpts, _tokenId)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) Exists(_tokenId *big.Int) (bool, error) {
	return _DigitalMediaToken.Contract.Exists(&_DigitalMediaToken.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCaller) GetApproved(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "getApproved", _tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _DigitalMediaToken.Contract.GetApproved(&_DigitalMediaToken.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _DigitalMediaToken.Contract.GetApproved(&_DigitalMediaToken.CallOpts, _tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_DigitalMediaToken *DigitalMediaTokenCaller) IsApprovedForAll(opts *bind.CallOpts, _owner common.Address, _operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "isApprovedForAll", _owner, _operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_DigitalMediaToken *DigitalMediaTokenSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _DigitalMediaToken.Contract.IsApprovedForAll(&_DigitalMediaToken.CallOpts, _owner, _operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _DigitalMediaToken.Contract.IsApprovedForAll(&_DigitalMediaToken.CallOpts, _owner, _operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_DigitalMediaToken *DigitalMediaTokenCaller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_DigitalMediaToken *DigitalMediaTokenSession) Name() (string, error) {
	return _DigitalMediaToken.Contract.Name(&_DigitalMediaToken.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) Name() (string, error) {
	return _DigitalMediaToken.Contract.Name(&_DigitalMediaToken.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenSession) Owner() (common.Address, error) {
	return _DigitalMediaToken.Contract.Owner(&_DigitalMediaToken.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) Owner() (common.Address, error) {
	return _DigitalMediaToken.Contract.Owner(&_DigitalMediaToken.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCaller) OwnerOf(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "ownerOf", _tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _DigitalMediaToken.Contract.OwnerOf(&_DigitalMediaToken.CallOpts, _tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _DigitalMediaToken.Contract.OwnerOf(&_DigitalMediaToken.CallOpts, _tokenId)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_DigitalMediaToken *DigitalMediaTokenCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "paused")
	return *ret0, err
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_DigitalMediaToken *DigitalMediaTokenSession) Paused() (bool, error) {
	return _DigitalMediaToken.Contract.Paused(&_DigitalMediaToken.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) Paused() (bool, error) {
	return _DigitalMediaToken.Contract.Paused(&_DigitalMediaToken.CallOpts)
}

// SingleCreatorAddress is a free data retrieval call binding the contract method 0x147ca2af.
//
// Solidity: function singleCreatorAddress() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCaller) SingleCreatorAddress(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "singleCreatorAddress")
	return *ret0, err
}

// SingleCreatorAddress is a free data retrieval call binding the contract method 0x147ca2af.
//
// Solidity: function singleCreatorAddress() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenSession) SingleCreatorAddress() (common.Address, error) {
	return _DigitalMediaToken.Contract.SingleCreatorAddress(&_DigitalMediaToken.CallOpts)
}

// SingleCreatorAddress is a free data retrieval call binding the contract method 0x147ca2af.
//
// Solidity: function singleCreatorAddress() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) SingleCreatorAddress() (common.Address, error) {
	return _DigitalMediaToken.Contract.SingleCreatorAddress(&_DigitalMediaToken.CallOpts)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 _interfaceID) constant returns(bool)
func (_DigitalMediaToken *DigitalMediaTokenCaller) SupportsInterface(opts *bind.CallOpts, _interfaceID [4]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "supportsInterface", _interfaceID)
	return *ret0, err
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 _interfaceID) constant returns(bool)
func (_DigitalMediaToken *DigitalMediaTokenSession) SupportsInterface(_interfaceID [4]byte) (bool, error) {
	return _DigitalMediaToken.Contract.SupportsInterface(&_DigitalMediaToken.CallOpts, _interfaceID)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 _interfaceID) constant returns(bool)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) SupportsInterface(_interfaceID [4]byte) (bool, error) {
	return _DigitalMediaToken.Contract.SupportsInterface(&_DigitalMediaToken.CallOpts, _interfaceID)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_DigitalMediaToken *DigitalMediaTokenCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_DigitalMediaToken *DigitalMediaTokenSession) Symbol() (string, error) {
	return _DigitalMediaToken.Contract.Symbol(&_DigitalMediaToken.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) Symbol() (string, error) {
	return _DigitalMediaToken.Contract.Symbol(&_DigitalMediaToken.CallOpts)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenCaller) TokenByIndex(opts *bind.CallOpts, _index *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "tokenByIndex", _index)
	return *ret0, err
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenSession) TokenByIndex(_index *big.Int) (*big.Int, error) {
	return _DigitalMediaToken.Contract.TokenByIndex(&_DigitalMediaToken.CallOpts, _index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) TokenByIndex(_index *big.Int) (*big.Int, error) {
	return _DigitalMediaToken.Contract.TokenByIndex(&_DigitalMediaToken.CallOpts, _index)
}

// TokenIdToDigitalMediaRelease is a free data retrieval call binding the contract method 0x3db57cbe.
//
// Solidity: function tokenIdToDigitalMediaRelease(uint256 ) constant returns(uint32 printEdition, uint256 digitalMediaId)
func (_DigitalMediaToken *DigitalMediaTokenCaller) TokenIdToDigitalMediaRelease(opts *bind.CallOpts, arg0 *big.Int) (struct {
	PrintEdition   uint32
	DigitalMediaId *big.Int
}, error) {
	ret := new(struct {
		PrintEdition   uint32
		DigitalMediaId *big.Int
	})
	out := ret
	err := _DigitalMediaToken.contract.Call(opts, out, "tokenIdToDigitalMediaRelease", arg0)
	return *ret, err
}

// TokenIdToDigitalMediaRelease is a free data retrieval call binding the contract method 0x3db57cbe.
//
// Solidity: function tokenIdToDigitalMediaRelease(uint256 ) constant returns(uint32 printEdition, uint256 digitalMediaId)
func (_DigitalMediaToken *DigitalMediaTokenSession) TokenIdToDigitalMediaRelease(arg0 *big.Int) (struct {
	PrintEdition   uint32
	DigitalMediaId *big.Int
}, error) {
	return _DigitalMediaToken.Contract.TokenIdToDigitalMediaRelease(&_DigitalMediaToken.CallOpts, arg0)
}

// TokenIdToDigitalMediaRelease is a free data retrieval call binding the contract method 0x3db57cbe.
//
// Solidity: function tokenIdToDigitalMediaRelease(uint256 ) constant returns(uint32 printEdition, uint256 digitalMediaId)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) TokenIdToDigitalMediaRelease(arg0 *big.Int) (struct {
	PrintEdition   uint32
	DigitalMediaId *big.Int
}, error) {
	return _DigitalMediaToken.Contract.TokenIdToDigitalMediaRelease(&_DigitalMediaToken.CallOpts, arg0)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, _owner common.Address, _index *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "tokenOfOwnerByIndex", _owner, _index)
	return *ret0, err
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenSession) TokenOfOwnerByIndex(_owner common.Address, _index *big.Int) (*big.Int, error) {
	return _DigitalMediaToken.Contract.TokenOfOwnerByIndex(&_DigitalMediaToken.CallOpts, _owner, _index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) TokenOfOwnerByIndex(_owner common.Address, _index *big.Int) (*big.Int, error) {
	return _DigitalMediaToken.Contract.TokenOfOwnerByIndex(&_DigitalMediaToken.CallOpts, _owner, _index)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_DigitalMediaToken *DigitalMediaTokenCaller) TokenURI(opts *bind.CallOpts, _tokenId *big.Int) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "tokenURI", _tokenId)
	return *ret0, err
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_DigitalMediaToken *DigitalMediaTokenSession) TokenURI(_tokenId *big.Int) (string, error) {
	return _DigitalMediaToken.Contract.TokenURI(&_DigitalMediaToken.CallOpts, _tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) TokenURI(_tokenId *big.Int) (string, error) {
	return _DigitalMediaToken.Contract.TokenURI(&_DigitalMediaToken.CallOpts, _tokenId)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenSession) TotalSupply() (*big.Int, error) {
	return _DigitalMediaToken.Contract.TotalSupply(&_DigitalMediaToken.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) TotalSupply() (*big.Int, error) {
	return _DigitalMediaToken.Contract.TotalSupply(&_DigitalMediaToken.CallOpts)
}

// V1DigitalMediaStore is a free data retrieval call binding the contract method 0xa0f01e08.
//
// Solidity: function v1DigitalMediaStore() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCaller) V1DigitalMediaStore(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _DigitalMediaToken.contract.Call(opts, out, "v1DigitalMediaStore")
	return *ret0, err
}

// V1DigitalMediaStore is a free data retrieval call binding the contract method 0xa0f01e08.
//
// Solidity: function v1DigitalMediaStore() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenSession) V1DigitalMediaStore() (common.Address, error) {
	return _DigitalMediaToken.Contract.V1DigitalMediaStore(&_DigitalMediaToken.CallOpts)
}

// V1DigitalMediaStore is a free data retrieval call binding the contract method 0xa0f01e08.
//
// Solidity: function v1DigitalMediaStore() constant returns(address)
func (_DigitalMediaToken *DigitalMediaTokenCallerSession) V1DigitalMediaStore() (common.Address, error) {
	return _DigitalMediaToken.Contract.V1DigitalMediaStore(&_DigitalMediaToken.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactor) Approve(opts *bind.TransactOpts, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaToken.contract.Transact(opts, "approve", _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_DigitalMediaToken *DigitalMediaTokenSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.Approve(&_DigitalMediaToken.TransactOpts, _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactorSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.Approve(&_DigitalMediaToken.TransactOpts, _to, _tokenId)
}

// ChangeSingleCreator is a paid mutator transaction binding the contract method 0xa7df572c.
//
// Solidity: function changeSingleCreator(address _newCreatorAddress) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactor) ChangeSingleCreator(opts *bind.TransactOpts, _newCreatorAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaToken.contract.Transact(opts, "changeSingleCreator", _newCreatorAddress)
}

// ChangeSingleCreator is a paid mutator transaction binding the contract method 0xa7df572c.
//
// Solidity: function changeSingleCreator(address _newCreatorAddress) returns()
func (_DigitalMediaToken *DigitalMediaTokenSession) ChangeSingleCreator(_newCreatorAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.ChangeSingleCreator(&_DigitalMediaToken.TransactOpts, _newCreatorAddress)
}

// ChangeSingleCreator is a paid mutator transaction binding the contract method 0xa7df572c.
//
// Solidity: function changeSingleCreator(address _newCreatorAddress) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactorSession) ChangeSingleCreator(_newCreatorAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.ChangeSingleCreator(&_DigitalMediaToken.TransactOpts, _newCreatorAddress)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaToken.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_DigitalMediaToken *DigitalMediaTokenSession) Pause() (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.Pause(&_DigitalMediaToken.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactorSession) Pause() (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.Pause(&_DigitalMediaToken.TransactOpts)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactor) SafeTransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaToken.contract.Transact(opts, "safeTransferFrom", _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_DigitalMediaToken *DigitalMediaTokenSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.SafeTransferFrom(&_DigitalMediaToken.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactorSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.SafeTransferFrom(&_DigitalMediaToken.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactor) SafeTransferFrom0(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _DigitalMediaToken.contract.Transact(opts, "safeTransferFrom0", _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_DigitalMediaToken *DigitalMediaTokenSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.SafeTransferFrom0(&_DigitalMediaToken.TransactOpts, _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactorSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.SafeTransferFrom0(&_DigitalMediaToken.TransactOpts, _from, _to, _tokenId, _data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactor) SetApprovalForAll(opts *bind.TransactOpts, _to common.Address, _approved bool) (*types.Transaction, error) {
	return _DigitalMediaToken.contract.Transact(opts, "setApprovalForAll", _to, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_DigitalMediaToken *DigitalMediaTokenSession) SetApprovalForAll(_to common.Address, _approved bool) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.SetApprovalForAll(&_DigitalMediaToken.TransactOpts, _to, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactorSession) SetApprovalForAll(_to common.Address, _approved bool) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.SetApprovalForAll(&_DigitalMediaToken.TransactOpts, _to, _approved)
}

// SetV1DigitalMediaStoreAddress is a paid mutator transaction binding the contract method 0x91c60788.
//
// Solidity: function setV1DigitalMediaStoreAddress(address _dmsAddress) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactor) SetV1DigitalMediaStoreAddress(opts *bind.TransactOpts, _dmsAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaToken.contract.Transact(opts, "setV1DigitalMediaStoreAddress", _dmsAddress)
}

// SetV1DigitalMediaStoreAddress is a paid mutator transaction binding the contract method 0x91c60788.
//
// Solidity: function setV1DigitalMediaStoreAddress(address _dmsAddress) returns()
func (_DigitalMediaToken *DigitalMediaTokenSession) SetV1DigitalMediaStoreAddress(_dmsAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.SetV1DigitalMediaStoreAddress(&_DigitalMediaToken.TransactOpts, _dmsAddress)
}

// SetV1DigitalMediaStoreAddress is a paid mutator transaction binding the contract method 0x91c60788.
//
// Solidity: function setV1DigitalMediaStoreAddress(address _dmsAddress) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactorSession) SetV1DigitalMediaStoreAddress(_dmsAddress common.Address) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.SetV1DigitalMediaStoreAddress(&_DigitalMediaToken.TransactOpts, _dmsAddress)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactor) TransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaToken.contract.Transact(opts, "transferFrom", _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_DigitalMediaToken *DigitalMediaTokenSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.TransferFrom(&_DigitalMediaToken.TransactOpts, _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactorSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.TransferFrom(&_DigitalMediaToken.TransactOpts, _from, _to, _tokenId)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _DigitalMediaToken.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_DigitalMediaToken *DigitalMediaTokenSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.TransferOwnership(&_DigitalMediaToken.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.TransferOwnership(&_DigitalMediaToken.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DigitalMediaToken.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_DigitalMediaToken *DigitalMediaTokenSession) Unpause() (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.Unpause(&_DigitalMediaToken.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_DigitalMediaToken *DigitalMediaTokenTransactorSession) Unpause() (*types.Transaction, error) {
	return _DigitalMediaToken.Contract.Unpause(&_DigitalMediaToken.TransactOpts)
}

// DigitalMediaTokenApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the DigitalMediaToken contract.
type DigitalMediaTokenApprovalIterator struct {
	Event *DigitalMediaTokenApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenApproval represents a Approval event raised by the DigitalMediaToken contract.
type DigitalMediaTokenApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterApproval(opts *bind.FilterOpts, _owner []common.Address, _approved []common.Address) (*DigitalMediaTokenApprovalIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenApprovalIterator{contract: _DigitalMediaToken.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenApproval, _owner []common.Address, _approved []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenApproval)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseApproval(log types.Log) (*DigitalMediaTokenApproval, error) {
	event := new(DigitalMediaTokenApproval)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the DigitalMediaToken contract.
type DigitalMediaTokenApprovalForAllIterator struct {
	Event *DigitalMediaTokenApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenApprovalForAll represents a ApprovalForAll event raised by the DigitalMediaToken contract.
type DigitalMediaTokenApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterApprovalForAll(opts *bind.FilterOpts, _owner []common.Address, _operator []common.Address) (*DigitalMediaTokenApprovalForAllIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenApprovalForAllIterator{contract: _DigitalMediaToken.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenApprovalForAll, _owner []common.Address, _operator []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenApprovalForAll)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseApprovalForAll(log types.Log) (*DigitalMediaTokenApprovalForAll, error) {
	event := new(DigitalMediaTokenApprovalForAll)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenChangedCreatorIterator is returned from FilterChangedCreator and is used to iterate over the raw logs and unpacked data for ChangedCreator events raised by the DigitalMediaToken contract.
type DigitalMediaTokenChangedCreatorIterator struct {
	Event *DigitalMediaTokenChangedCreator // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenChangedCreatorIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenChangedCreator)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenChangedCreator)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenChangedCreatorIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenChangedCreatorIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenChangedCreator represents a ChangedCreator event raised by the DigitalMediaToken contract.
type DigitalMediaTokenChangedCreator struct {
	Creator    common.Address
	NewCreator common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterChangedCreator is a free log retrieval operation binding the contract event 0xde6cfdf21fe76bcb45258138e27bcd332b76941b24d226b5da8dc5f9cd531c3e.
//
// Solidity: event ChangedCreator(address creator, address newCreator)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterChangedCreator(opts *bind.FilterOpts) (*DigitalMediaTokenChangedCreatorIterator, error) {

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "ChangedCreator")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenChangedCreatorIterator{contract: _DigitalMediaToken.contract, event: "ChangedCreator", logs: logs, sub: sub}, nil
}

// WatchChangedCreator is a free log subscription operation binding the contract event 0xde6cfdf21fe76bcb45258138e27bcd332b76941b24d226b5da8dc5f9cd531c3e.
//
// Solidity: event ChangedCreator(address creator, address newCreator)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchChangedCreator(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenChangedCreator) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "ChangedCreator")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenChangedCreator)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "ChangedCreator", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangedCreator is a log parse operation binding the contract event 0xde6cfdf21fe76bcb45258138e27bcd332b76941b24d226b5da8dc5f9cd531c3e.
//
// Solidity: event ChangedCreator(address creator, address newCreator)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseChangedCreator(log types.Log) (*DigitalMediaTokenChangedCreator, error) {
	event := new(DigitalMediaTokenChangedCreator)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "ChangedCreator", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenDigitalMediaBurnEventIterator is returned from FilterDigitalMediaBurnEvent and is used to iterate over the raw logs and unpacked data for DigitalMediaBurnEvent events raised by the DigitalMediaToken contract.
type DigitalMediaTokenDigitalMediaBurnEventIterator struct {
	Event *DigitalMediaTokenDigitalMediaBurnEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenDigitalMediaBurnEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenDigitalMediaBurnEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenDigitalMediaBurnEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenDigitalMediaBurnEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenDigitalMediaBurnEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenDigitalMediaBurnEvent represents a DigitalMediaBurnEvent event raised by the DigitalMediaToken contract.
type DigitalMediaTokenDigitalMediaBurnEvent struct {
	Id                   *big.Int
	Caller               common.Address
	StoreContractAddress common.Address
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterDigitalMediaBurnEvent is a free log retrieval operation binding the contract event 0x327ecc068f1b41267f69376098f6a50da487e4a4d762d53c01197d6a2f294b3e.
//
// Solidity: event DigitalMediaBurnEvent(uint256 id, address caller, address storeContractAddress)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterDigitalMediaBurnEvent(opts *bind.FilterOpts) (*DigitalMediaTokenDigitalMediaBurnEventIterator, error) {

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "DigitalMediaBurnEvent")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenDigitalMediaBurnEventIterator{contract: _DigitalMediaToken.contract, event: "DigitalMediaBurnEvent", logs: logs, sub: sub}, nil
}

// WatchDigitalMediaBurnEvent is a free log subscription operation binding the contract event 0x327ecc068f1b41267f69376098f6a50da487e4a4d762d53c01197d6a2f294b3e.
//
// Solidity: event DigitalMediaBurnEvent(uint256 id, address caller, address storeContractAddress)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchDigitalMediaBurnEvent(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenDigitalMediaBurnEvent) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "DigitalMediaBurnEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenDigitalMediaBurnEvent)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "DigitalMediaBurnEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDigitalMediaBurnEvent is a log parse operation binding the contract event 0x327ecc068f1b41267f69376098f6a50da487e4a4d762d53c01197d6a2f294b3e.
//
// Solidity: event DigitalMediaBurnEvent(uint256 id, address caller, address storeContractAddress)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseDigitalMediaBurnEvent(log types.Log) (*DigitalMediaTokenDigitalMediaBurnEvent, error) {
	event := new(DigitalMediaTokenDigitalMediaBurnEvent)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "DigitalMediaBurnEvent", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenDigitalMediaCollectionCreateEventIterator is returned from FilterDigitalMediaCollectionCreateEvent and is used to iterate over the raw logs and unpacked data for DigitalMediaCollectionCreateEvent events raised by the DigitalMediaToken contract.
type DigitalMediaTokenDigitalMediaCollectionCreateEventIterator struct {
	Event *DigitalMediaTokenDigitalMediaCollectionCreateEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenDigitalMediaCollectionCreateEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenDigitalMediaCollectionCreateEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenDigitalMediaCollectionCreateEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenDigitalMediaCollectionCreateEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenDigitalMediaCollectionCreateEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenDigitalMediaCollectionCreateEvent represents a DigitalMediaCollectionCreateEvent event raised by the DigitalMediaToken contract.
type DigitalMediaTokenDigitalMediaCollectionCreateEvent struct {
	Id                   *big.Int
	StoreContractAddress common.Address
	Creator              common.Address
	MetadataPath         string
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterDigitalMediaCollectionCreateEvent is a free log retrieval operation binding the contract event 0x01e2312dcdafe7cd3f82579d8c121fdb930d46ef2eb231953a521ac62093e277.
//
// Solidity: event DigitalMediaCollectionCreateEvent(uint256 id, address storeContractAddress, address creator, string metadataPath)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterDigitalMediaCollectionCreateEvent(opts *bind.FilterOpts) (*DigitalMediaTokenDigitalMediaCollectionCreateEventIterator, error) {

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "DigitalMediaCollectionCreateEvent")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenDigitalMediaCollectionCreateEventIterator{contract: _DigitalMediaToken.contract, event: "DigitalMediaCollectionCreateEvent", logs: logs, sub: sub}, nil
}

// WatchDigitalMediaCollectionCreateEvent is a free log subscription operation binding the contract event 0x01e2312dcdafe7cd3f82579d8c121fdb930d46ef2eb231953a521ac62093e277.
//
// Solidity: event DigitalMediaCollectionCreateEvent(uint256 id, address storeContractAddress, address creator, string metadataPath)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchDigitalMediaCollectionCreateEvent(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenDigitalMediaCollectionCreateEvent) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "DigitalMediaCollectionCreateEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenDigitalMediaCollectionCreateEvent)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "DigitalMediaCollectionCreateEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDigitalMediaCollectionCreateEvent is a log parse operation binding the contract event 0x01e2312dcdafe7cd3f82579d8c121fdb930d46ef2eb231953a521ac62093e277.
//
// Solidity: event DigitalMediaCollectionCreateEvent(uint256 id, address storeContractAddress, address creator, string metadataPath)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseDigitalMediaCollectionCreateEvent(log types.Log) (*DigitalMediaTokenDigitalMediaCollectionCreateEvent, error) {
	event := new(DigitalMediaTokenDigitalMediaCollectionCreateEvent)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "DigitalMediaCollectionCreateEvent", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenDigitalMediaCreateEventIterator is returned from FilterDigitalMediaCreateEvent and is used to iterate over the raw logs and unpacked data for DigitalMediaCreateEvent events raised by the DigitalMediaToken contract.
type DigitalMediaTokenDigitalMediaCreateEventIterator struct {
	Event *DigitalMediaTokenDigitalMediaCreateEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenDigitalMediaCreateEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenDigitalMediaCreateEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenDigitalMediaCreateEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenDigitalMediaCreateEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenDigitalMediaCreateEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenDigitalMediaCreateEvent represents a DigitalMediaCreateEvent event raised by the DigitalMediaToken contract.
type DigitalMediaTokenDigitalMediaCreateEvent struct {
	Id                   *big.Int
	StoreContractAddress common.Address
	Creator              common.Address
	TotalSupply          uint32
	PrintIndex           uint32
	CollectionId         *big.Int
	MetadataPath         string
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterDigitalMediaCreateEvent is a free log retrieval operation binding the contract event 0x794c5cd70604d9d8dc2cbca1f8be65f167e4147b6512541d41e8e410594098a0.
//
// Solidity: event DigitalMediaCreateEvent(uint256 id, address storeContractAddress, address creator, uint32 totalSupply, uint32 printIndex, uint256 collectionId, string metadataPath)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterDigitalMediaCreateEvent(opts *bind.FilterOpts) (*DigitalMediaTokenDigitalMediaCreateEventIterator, error) {

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "DigitalMediaCreateEvent")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenDigitalMediaCreateEventIterator{contract: _DigitalMediaToken.contract, event: "DigitalMediaCreateEvent", logs: logs, sub: sub}, nil
}

// WatchDigitalMediaCreateEvent is a free log subscription operation binding the contract event 0x794c5cd70604d9d8dc2cbca1f8be65f167e4147b6512541d41e8e410594098a0.
//
// Solidity: event DigitalMediaCreateEvent(uint256 id, address storeContractAddress, address creator, uint32 totalSupply, uint32 printIndex, uint256 collectionId, string metadataPath)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchDigitalMediaCreateEvent(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenDigitalMediaCreateEvent) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "DigitalMediaCreateEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenDigitalMediaCreateEvent)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "DigitalMediaCreateEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDigitalMediaCreateEvent is a log parse operation binding the contract event 0x794c5cd70604d9d8dc2cbca1f8be65f167e4147b6512541d41e8e410594098a0.
//
// Solidity: event DigitalMediaCreateEvent(uint256 id, address storeContractAddress, address creator, uint32 totalSupply, uint32 printIndex, uint256 collectionId, string metadataPath)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseDigitalMediaCreateEvent(log types.Log) (*DigitalMediaTokenDigitalMediaCreateEvent, error) {
	event := new(DigitalMediaTokenDigitalMediaCreateEvent)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "DigitalMediaCreateEvent", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenDigitalMediaReleaseBurnEventIterator is returned from FilterDigitalMediaReleaseBurnEvent and is used to iterate over the raw logs and unpacked data for DigitalMediaReleaseBurnEvent events raised by the DigitalMediaToken contract.
type DigitalMediaTokenDigitalMediaReleaseBurnEventIterator struct {
	Event *DigitalMediaTokenDigitalMediaReleaseBurnEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenDigitalMediaReleaseBurnEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenDigitalMediaReleaseBurnEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenDigitalMediaReleaseBurnEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenDigitalMediaReleaseBurnEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenDigitalMediaReleaseBurnEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenDigitalMediaReleaseBurnEvent represents a DigitalMediaReleaseBurnEvent event raised by the DigitalMediaToken contract.
type DigitalMediaTokenDigitalMediaReleaseBurnEvent struct {
	TokenId *big.Int
	Owner   common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterDigitalMediaReleaseBurnEvent is a free log retrieval operation binding the contract event 0x1e8df141f42ed659a8fe7e7c5966cbdf2d240d0c45f4c30cbe02526c618075ef.
//
// Solidity: event DigitalMediaReleaseBurnEvent(uint256 tokenId, address owner)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterDigitalMediaReleaseBurnEvent(opts *bind.FilterOpts) (*DigitalMediaTokenDigitalMediaReleaseBurnEventIterator, error) {

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "DigitalMediaReleaseBurnEvent")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenDigitalMediaReleaseBurnEventIterator{contract: _DigitalMediaToken.contract, event: "DigitalMediaReleaseBurnEvent", logs: logs, sub: sub}, nil
}

// WatchDigitalMediaReleaseBurnEvent is a free log subscription operation binding the contract event 0x1e8df141f42ed659a8fe7e7c5966cbdf2d240d0c45f4c30cbe02526c618075ef.
//
// Solidity: event DigitalMediaReleaseBurnEvent(uint256 tokenId, address owner)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchDigitalMediaReleaseBurnEvent(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenDigitalMediaReleaseBurnEvent) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "DigitalMediaReleaseBurnEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenDigitalMediaReleaseBurnEvent)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "DigitalMediaReleaseBurnEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDigitalMediaReleaseBurnEvent is a log parse operation binding the contract event 0x1e8df141f42ed659a8fe7e7c5966cbdf2d240d0c45f4c30cbe02526c618075ef.
//
// Solidity: event DigitalMediaReleaseBurnEvent(uint256 tokenId, address owner)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseDigitalMediaReleaseBurnEvent(log types.Log) (*DigitalMediaTokenDigitalMediaReleaseBurnEvent, error) {
	event := new(DigitalMediaTokenDigitalMediaReleaseBurnEvent)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "DigitalMediaReleaseBurnEvent", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenDigitalMediaReleaseCreateEventIterator is returned from FilterDigitalMediaReleaseCreateEvent and is used to iterate over the raw logs and unpacked data for DigitalMediaReleaseCreateEvent events raised by the DigitalMediaToken contract.
type DigitalMediaTokenDigitalMediaReleaseCreateEventIterator struct {
	Event *DigitalMediaTokenDigitalMediaReleaseCreateEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenDigitalMediaReleaseCreateEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenDigitalMediaReleaseCreateEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenDigitalMediaReleaseCreateEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenDigitalMediaReleaseCreateEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenDigitalMediaReleaseCreateEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenDigitalMediaReleaseCreateEvent represents a DigitalMediaReleaseCreateEvent event raised by the DigitalMediaToken contract.
type DigitalMediaTokenDigitalMediaReleaseCreateEvent struct {
	Id             *big.Int
	Owner          common.Address
	PrintEdition   uint32
	TokenURI       string
	DigitalMediaId *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterDigitalMediaReleaseCreateEvent is a free log retrieval operation binding the contract event 0x775f53e4c75ce0c74e611f7f0bb660e4cd647e0522ef0f8aefd4ecef373c5df9.
//
// Solidity: event DigitalMediaReleaseCreateEvent(uint256 id, address owner, uint32 printEdition, string tokenURI, uint256 digitalMediaId)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterDigitalMediaReleaseCreateEvent(opts *bind.FilterOpts) (*DigitalMediaTokenDigitalMediaReleaseCreateEventIterator, error) {

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "DigitalMediaReleaseCreateEvent")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenDigitalMediaReleaseCreateEventIterator{contract: _DigitalMediaToken.contract, event: "DigitalMediaReleaseCreateEvent", logs: logs, sub: sub}, nil
}

// WatchDigitalMediaReleaseCreateEvent is a free log subscription operation binding the contract event 0x775f53e4c75ce0c74e611f7f0bb660e4cd647e0522ef0f8aefd4ecef373c5df9.
//
// Solidity: event DigitalMediaReleaseCreateEvent(uint256 id, address owner, uint32 printEdition, string tokenURI, uint256 digitalMediaId)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchDigitalMediaReleaseCreateEvent(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenDigitalMediaReleaseCreateEvent) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "DigitalMediaReleaseCreateEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenDigitalMediaReleaseCreateEvent)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "DigitalMediaReleaseCreateEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDigitalMediaReleaseCreateEvent is a log parse operation binding the contract event 0x775f53e4c75ce0c74e611f7f0bb660e4cd647e0522ef0f8aefd4ecef373c5df9.
//
// Solidity: event DigitalMediaReleaseCreateEvent(uint256 id, address owner, uint32 printEdition, string tokenURI, uint256 digitalMediaId)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseDigitalMediaReleaseCreateEvent(log types.Log) (*DigitalMediaTokenDigitalMediaReleaseCreateEvent, error) {
	event := new(DigitalMediaTokenDigitalMediaReleaseCreateEvent)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "DigitalMediaReleaseCreateEvent", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the DigitalMediaToken contract.
type DigitalMediaTokenOwnershipTransferredIterator struct {
	Event *DigitalMediaTokenOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenOwnershipTransferred represents a OwnershipTransferred event raised by the DigitalMediaToken contract.
type DigitalMediaTokenOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*DigitalMediaTokenOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenOwnershipTransferredIterator{contract: _DigitalMediaToken.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenOwnershipTransferred)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseOwnershipTransferred(log types.Log) (*DigitalMediaTokenOwnershipTransferred, error) {
	event := new(DigitalMediaTokenOwnershipTransferred)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenPauseIterator is returned from FilterPause and is used to iterate over the raw logs and unpacked data for Pause events raised by the DigitalMediaToken contract.
type DigitalMediaTokenPauseIterator struct {
	Event *DigitalMediaTokenPause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenPauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenPause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenPause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenPauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenPauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenPause represents a Pause event raised by the DigitalMediaToken contract.
type DigitalMediaTokenPause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPause is a free log retrieval operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterPause(opts *bind.FilterOpts) (*DigitalMediaTokenPauseIterator, error) {

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenPauseIterator{contract: _DigitalMediaToken.contract, event: "Pause", logs: logs, sub: sub}, nil
}

// WatchPause is a free log subscription operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchPause(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenPause) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenPause)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "Pause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePause is a log parse operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParsePause(log types.Log) (*DigitalMediaTokenPause, error) {
	event := new(DigitalMediaTokenPause)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "Pause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenSingleCreatorChangedIterator is returned from FilterSingleCreatorChanged and is used to iterate over the raw logs and unpacked data for SingleCreatorChanged events raised by the DigitalMediaToken contract.
type DigitalMediaTokenSingleCreatorChangedIterator struct {
	Event *DigitalMediaTokenSingleCreatorChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenSingleCreatorChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenSingleCreatorChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenSingleCreatorChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenSingleCreatorChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenSingleCreatorChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenSingleCreatorChanged represents a SingleCreatorChanged event raised by the DigitalMediaToken contract.
type DigitalMediaTokenSingleCreatorChanged struct {
	PreviousCreatorAddress common.Address
	NewCreatorAddress      common.Address
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterSingleCreatorChanged is a free log retrieval operation binding the contract event 0x384c948063df3740539b4b000658c1a22348e7f18c87f808085662e461e48e71.
//
// Solidity: event SingleCreatorChanged(address indexed previousCreatorAddress, address indexed newCreatorAddress)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterSingleCreatorChanged(opts *bind.FilterOpts, previousCreatorAddress []common.Address, newCreatorAddress []common.Address) (*DigitalMediaTokenSingleCreatorChangedIterator, error) {

	var previousCreatorAddressRule []interface{}
	for _, previousCreatorAddressItem := range previousCreatorAddress {
		previousCreatorAddressRule = append(previousCreatorAddressRule, previousCreatorAddressItem)
	}
	var newCreatorAddressRule []interface{}
	for _, newCreatorAddressItem := range newCreatorAddress {
		newCreatorAddressRule = append(newCreatorAddressRule, newCreatorAddressItem)
	}

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "SingleCreatorChanged", previousCreatorAddressRule, newCreatorAddressRule)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenSingleCreatorChangedIterator{contract: _DigitalMediaToken.contract, event: "SingleCreatorChanged", logs: logs, sub: sub}, nil
}

// WatchSingleCreatorChanged is a free log subscription operation binding the contract event 0x384c948063df3740539b4b000658c1a22348e7f18c87f808085662e461e48e71.
//
// Solidity: event SingleCreatorChanged(address indexed previousCreatorAddress, address indexed newCreatorAddress)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchSingleCreatorChanged(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenSingleCreatorChanged, previousCreatorAddress []common.Address, newCreatorAddress []common.Address) (event.Subscription, error) {

	var previousCreatorAddressRule []interface{}
	for _, previousCreatorAddressItem := range previousCreatorAddress {
		previousCreatorAddressRule = append(previousCreatorAddressRule, previousCreatorAddressItem)
	}
	var newCreatorAddressRule []interface{}
	for _, newCreatorAddressItem := range newCreatorAddress {
		newCreatorAddressRule = append(newCreatorAddressRule, newCreatorAddressItem)
	}

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "SingleCreatorChanged", previousCreatorAddressRule, newCreatorAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenSingleCreatorChanged)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "SingleCreatorChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSingleCreatorChanged is a log parse operation binding the contract event 0x384c948063df3740539b4b000658c1a22348e7f18c87f808085662e461e48e71.
//
// Solidity: event SingleCreatorChanged(address indexed previousCreatorAddress, address indexed newCreatorAddress)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseSingleCreatorChanged(log types.Log) (*DigitalMediaTokenSingleCreatorChanged, error) {
	event := new(DigitalMediaTokenSingleCreatorChanged)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "SingleCreatorChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the DigitalMediaToken contract.
type DigitalMediaTokenTransferIterator struct {
	Event *DigitalMediaTokenTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenTransfer represents a Transfer event raised by the DigitalMediaToken contract.
type DigitalMediaTokenTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterTransfer(opts *bind.FilterOpts, _from []common.Address, _to []common.Address) (*DigitalMediaTokenTransferIterator, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenTransferIterator{contract: _DigitalMediaToken.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenTransfer, _from []common.Address, _to []common.Address) (event.Subscription, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenTransfer)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseTransfer(log types.Log) (*DigitalMediaTokenTransfer, error) {
	event := new(DigitalMediaTokenTransfer)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenUnpauseIterator is returned from FilterUnpause and is used to iterate over the raw logs and unpacked data for Unpause events raised by the DigitalMediaToken contract.
type DigitalMediaTokenUnpauseIterator struct {
	Event *DigitalMediaTokenUnpause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenUnpauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenUnpause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenUnpause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenUnpauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenUnpauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenUnpause represents a Unpause event raised by the DigitalMediaToken contract.
type DigitalMediaTokenUnpause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUnpause is a free log retrieval operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterUnpause(opts *bind.FilterOpts) (*DigitalMediaTokenUnpauseIterator, error) {

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenUnpauseIterator{contract: _DigitalMediaToken.contract, event: "Unpause", logs: logs, sub: sub}, nil
}

// WatchUnpause is a free log subscription operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchUnpause(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenUnpause) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenUnpause)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "Unpause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpause is a log parse operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseUnpause(log types.Log) (*DigitalMediaTokenUnpause, error) {
	event := new(DigitalMediaTokenUnpause)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "Unpause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// DigitalMediaTokenUpdateDigitalMediaPrintIndexEventIterator is returned from FilterUpdateDigitalMediaPrintIndexEvent and is used to iterate over the raw logs and unpacked data for UpdateDigitalMediaPrintIndexEvent events raised by the DigitalMediaToken contract.
type DigitalMediaTokenUpdateDigitalMediaPrintIndexEventIterator struct {
	Event *DigitalMediaTokenUpdateDigitalMediaPrintIndexEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DigitalMediaTokenUpdateDigitalMediaPrintIndexEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DigitalMediaTokenUpdateDigitalMediaPrintIndexEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DigitalMediaTokenUpdateDigitalMediaPrintIndexEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DigitalMediaTokenUpdateDigitalMediaPrintIndexEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DigitalMediaTokenUpdateDigitalMediaPrintIndexEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DigitalMediaTokenUpdateDigitalMediaPrintIndexEvent represents a UpdateDigitalMediaPrintIndexEvent event raised by the DigitalMediaToken contract.
type DigitalMediaTokenUpdateDigitalMediaPrintIndexEvent struct {
	DigitalMediaId *big.Int
	PrintEdition   uint32
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterUpdateDigitalMediaPrintIndexEvent is a free log retrieval operation binding the contract event 0x12d99f5e49ef761c52953e4f9a109827fc3540292ba88c10d309fef470685259.
//
// Solidity: event UpdateDigitalMediaPrintIndexEvent(uint256 digitalMediaId, uint32 printEdition)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) FilterUpdateDigitalMediaPrintIndexEvent(opts *bind.FilterOpts) (*DigitalMediaTokenUpdateDigitalMediaPrintIndexEventIterator, error) {

	logs, sub, err := _DigitalMediaToken.contract.FilterLogs(opts, "UpdateDigitalMediaPrintIndexEvent")
	if err != nil {
		return nil, err
	}
	return &DigitalMediaTokenUpdateDigitalMediaPrintIndexEventIterator{contract: _DigitalMediaToken.contract, event: "UpdateDigitalMediaPrintIndexEvent", logs: logs, sub: sub}, nil
}

// WatchUpdateDigitalMediaPrintIndexEvent is a free log subscription operation binding the contract event 0x12d99f5e49ef761c52953e4f9a109827fc3540292ba88c10d309fef470685259.
//
// Solidity: event UpdateDigitalMediaPrintIndexEvent(uint256 digitalMediaId, uint32 printEdition)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) WatchUpdateDigitalMediaPrintIndexEvent(opts *bind.WatchOpts, sink chan<- *DigitalMediaTokenUpdateDigitalMediaPrintIndexEvent) (event.Subscription, error) {

	logs, sub, err := _DigitalMediaToken.contract.WatchLogs(opts, "UpdateDigitalMediaPrintIndexEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DigitalMediaTokenUpdateDigitalMediaPrintIndexEvent)
				if err := _DigitalMediaToken.contract.UnpackLog(event, "UpdateDigitalMediaPrintIndexEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateDigitalMediaPrintIndexEvent is a log parse operation binding the contract event 0x12d99f5e49ef761c52953e4f9a109827fc3540292ba88c10d309fef470685259.
//
// Solidity: event UpdateDigitalMediaPrintIndexEvent(uint256 digitalMediaId, uint32 printEdition)
func (_DigitalMediaToken *DigitalMediaTokenFilterer) ParseUpdateDigitalMediaPrintIndexEvent(log types.Log) (*DigitalMediaTokenUpdateDigitalMediaPrintIndexEvent, error) {
	event := new(DigitalMediaTokenUpdateDigitalMediaPrintIndexEvent)
	if err := _DigitalMediaToken.contract.UnpackLog(event, "UpdateDigitalMediaPrintIndexEvent", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721ABI is the input ABI used to generate the binding from.
const ERC721ABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"_exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]"

// ERC721FuncSigs maps the 4-byte function signature to its string representation.
var ERC721FuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"4f558e79": "exists(uint256)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"06fdde03": "name()",
	"6352211e": "ownerOf(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"95d89b41": "symbol()",
	"4f6ccce7": "tokenByIndex(uint256)",
	"2f745c59": "tokenOfOwnerByIndex(address,uint256)",
	"c87b56dd": "tokenURI(uint256)",
	"18160ddd": "totalSupply()",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// ERC721 is an auto generated Go binding around an Ethereum contract.
type ERC721 struct {
	ERC721Caller     // Read-only binding to the contract
	ERC721Transactor // Write-only binding to the contract
	ERC721Filterer   // Log filterer for contract events
}

// ERC721Caller is an auto generated read-only Go binding around an Ethereum contract.
type ERC721Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721Transactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC721Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC721Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC721Session struct {
	Contract     *ERC721           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC721CallerSession struct {
	Contract *ERC721Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ERC721TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC721TransactorSession struct {
	Contract     *ERC721Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721Raw is an auto generated low-level Go binding around an Ethereum contract.
type ERC721Raw struct {
	Contract *ERC721 // Generic contract binding to access the raw methods on
}

// ERC721CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC721CallerRaw struct {
	Contract *ERC721Caller // Generic read-only contract binding to access the raw methods on
}

// ERC721TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC721TransactorRaw struct {
	Contract *ERC721Transactor // Generic write-only contract binding to access the raw methods on
}

// NewERC721 creates a new instance of ERC721, bound to a specific deployed contract.
func NewERC721(address common.Address, backend bind.ContractBackend) (*ERC721, error) {
	contract, err := bindERC721(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC721{ERC721Caller: ERC721Caller{contract: contract}, ERC721Transactor: ERC721Transactor{contract: contract}, ERC721Filterer: ERC721Filterer{contract: contract}}, nil
}

// NewERC721Caller creates a new read-only instance of ERC721, bound to a specific deployed contract.
func NewERC721Caller(address common.Address, caller bind.ContractCaller) (*ERC721Caller, error) {
	contract, err := bindERC721(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721Caller{contract: contract}, nil
}

// NewERC721Transactor creates a new write-only instance of ERC721, bound to a specific deployed contract.
func NewERC721Transactor(address common.Address, transactor bind.ContractTransactor) (*ERC721Transactor, error) {
	contract, err := bindERC721(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721Transactor{contract: contract}, nil
}

// NewERC721Filterer creates a new log filterer instance of ERC721, bound to a specific deployed contract.
func NewERC721Filterer(address common.Address, filterer bind.ContractFilterer) (*ERC721Filterer, error) {
	contract, err := bindERC721(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC721Filterer{contract: contract}, nil
}

// bindERC721 binds a generic wrapper to an already deployed contract.
func bindERC721(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721 *ERC721Raw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721.Contract.ERC721Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721 *ERC721Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721.Contract.ERC721Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721 *ERC721Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721.Contract.ERC721Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721 *ERC721CallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721 *ERC721TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721 *ERC721TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 _balance)
func (_ERC721 *ERC721Caller) BalanceOf(opts *bind.CallOpts, _owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "balanceOf", _owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 _balance)
func (_ERC721 *ERC721Session) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721.Contract.BalanceOf(&_ERC721.CallOpts, _owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 _balance)
func (_ERC721 *ERC721CallerSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721.Contract.BalanceOf(&_ERC721.CallOpts, _owner)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool _exists)
func (_ERC721 *ERC721Caller) Exists(opts *bind.CallOpts, _tokenId *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "exists", _tokenId)
	return *ret0, err
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool _exists)
func (_ERC721 *ERC721Session) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721.Contract.Exists(&_ERC721.CallOpts, _tokenId)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool _exists)
func (_ERC721 *ERC721CallerSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721.Contract.Exists(&_ERC721.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address _operator)
func (_ERC721 *ERC721Caller) GetApproved(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "getApproved", _tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address _operator)
func (_ERC721 *ERC721Session) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721.Contract.GetApproved(&_ERC721.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address _operator)
func (_ERC721 *ERC721CallerSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721.Contract.GetApproved(&_ERC721.CallOpts, _tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721 *ERC721Caller) IsApprovedForAll(opts *bind.CallOpts, _owner common.Address, _operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "isApprovedForAll", _owner, _operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721 *ERC721Session) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721.Contract.IsApprovedForAll(&_ERC721.CallOpts, _owner, _operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721 *ERC721CallerSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721.Contract.IsApprovedForAll(&_ERC721.CallOpts, _owner, _operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string _name)
func (_ERC721 *ERC721Caller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string _name)
func (_ERC721 *ERC721Session) Name() (string, error) {
	return _ERC721.Contract.Name(&_ERC721.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string _name)
func (_ERC721 *ERC721CallerSession) Name() (string, error) {
	return _ERC721.Contract.Name(&_ERC721.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address _owner)
func (_ERC721 *ERC721Caller) OwnerOf(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "ownerOf", _tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address _owner)
func (_ERC721 *ERC721Session) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721.Contract.OwnerOf(&_ERC721.CallOpts, _tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address _owner)
func (_ERC721 *ERC721CallerSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721.Contract.OwnerOf(&_ERC721.CallOpts, _tokenId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string _symbol)
func (_ERC721 *ERC721Caller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string _symbol)
func (_ERC721 *ERC721Session) Symbol() (string, error) {
	return _ERC721.Contract.Symbol(&_ERC721.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string _symbol)
func (_ERC721 *ERC721CallerSession) Symbol() (string, error) {
	return _ERC721.Contract.Symbol(&_ERC721.CallOpts)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_ERC721 *ERC721Caller) TokenByIndex(opts *bind.CallOpts, _index *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "tokenByIndex", _index)
	return *ret0, err
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_ERC721 *ERC721Session) TokenByIndex(_index *big.Int) (*big.Int, error) {
	return _ERC721.Contract.TokenByIndex(&_ERC721.CallOpts, _index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_ERC721 *ERC721CallerSession) TokenByIndex(_index *big.Int) (*big.Int, error) {
	return _ERC721.Contract.TokenByIndex(&_ERC721.CallOpts, _index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256 _tokenId)
func (_ERC721 *ERC721Caller) TokenOfOwnerByIndex(opts *bind.CallOpts, _owner common.Address, _index *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "tokenOfOwnerByIndex", _owner, _index)
	return *ret0, err
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256 _tokenId)
func (_ERC721 *ERC721Session) TokenOfOwnerByIndex(_owner common.Address, _index *big.Int) (*big.Int, error) {
	return _ERC721.Contract.TokenOfOwnerByIndex(&_ERC721.CallOpts, _owner, _index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256 _tokenId)
func (_ERC721 *ERC721CallerSession) TokenOfOwnerByIndex(_owner common.Address, _index *big.Int) (*big.Int, error) {
	return _ERC721.Contract.TokenOfOwnerByIndex(&_ERC721.CallOpts, _owner, _index)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_ERC721 *ERC721Caller) TokenURI(opts *bind.CallOpts, _tokenId *big.Int) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "tokenURI", _tokenId)
	return *ret0, err
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_ERC721 *ERC721Session) TokenURI(_tokenId *big.Int) (string, error) {
	return _ERC721.Contract.TokenURI(&_ERC721.CallOpts, _tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_ERC721 *ERC721CallerSession) TokenURI(_tokenId *big.Int) (string, error) {
	return _ERC721.Contract.TokenURI(&_ERC721.CallOpts, _tokenId)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC721 *ERC721Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC721 *ERC721Session) TotalSupply() (*big.Int, error) {
	return _ERC721.Contract.TotalSupply(&_ERC721.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC721 *ERC721CallerSession) TotalSupply() (*big.Int, error) {
	return _ERC721.Contract.TotalSupply(&_ERC721.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721 *ERC721Transactor) Approve(opts *bind.TransactOpts, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.contract.Transact(opts, "approve", _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721 *ERC721Session) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.Contract.Approve(&_ERC721.TransactOpts, _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721 *ERC721TransactorSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.Contract.Approve(&_ERC721.TransactOpts, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721 *ERC721Transactor) SafeTransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.contract.Transact(opts, "safeTransferFrom", _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721 *ERC721Session) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.Contract.SafeTransferFrom(&_ERC721.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721 *ERC721TransactorSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.Contract.SafeTransferFrom(&_ERC721.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721 *ERC721Transactor) SafeTransferFrom0(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721.contract.Transact(opts, "safeTransferFrom0", _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721 *ERC721Session) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721.Contract.SafeTransferFrom0(&_ERC721.TransactOpts, _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721 *ERC721TransactorSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721.Contract.SafeTransferFrom0(&_ERC721.TransactOpts, _from, _to, _tokenId, _data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _operator, bool _approved) returns()
func (_ERC721 *ERC721Transactor) SetApprovalForAll(opts *bind.TransactOpts, _operator common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721.contract.Transact(opts, "setApprovalForAll", _operator, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _operator, bool _approved) returns()
func (_ERC721 *ERC721Session) SetApprovalForAll(_operator common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721.Contract.SetApprovalForAll(&_ERC721.TransactOpts, _operator, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _operator, bool _approved) returns()
func (_ERC721 *ERC721TransactorSession) SetApprovalForAll(_operator common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721.Contract.SetApprovalForAll(&_ERC721.TransactOpts, _operator, _approved)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721 *ERC721Transactor) TransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.contract.Transact(opts, "transferFrom", _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721 *ERC721Session) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.Contract.TransferFrom(&_ERC721.TransactOpts, _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721 *ERC721TransactorSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721.Contract.TransferFrom(&_ERC721.TransactOpts, _from, _to, _tokenId)
}

// ERC721ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC721 contract.
type ERC721ApprovalIterator struct {
	Event *ERC721Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721Approval represents a Approval event raised by the ERC721 contract.
type ERC721Approval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721 *ERC721Filterer) FilterApproval(opts *bind.FilterOpts, _owner []common.Address, _approved []common.Address) (*ERC721ApprovalIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721.contract.FilterLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return &ERC721ApprovalIterator{contract: _ERC721.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721 *ERC721Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC721Approval, _owner []common.Address, _approved []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721.contract.WatchLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721Approval)
				if err := _ERC721.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721 *ERC721Filterer) ParseApproval(log types.Log) (*ERC721Approval, error) {
	event := new(ERC721Approval)
	if err := _ERC721.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721ApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ERC721 contract.
type ERC721ApprovalForAllIterator struct {
	Event *ERC721ApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721ApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721ApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721ApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721ApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721ApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721ApprovalForAll represents a ApprovalForAll event raised by the ERC721 contract.
type ERC721ApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721 *ERC721Filterer) FilterApprovalForAll(opts *bind.FilterOpts, _owner []common.Address, _operator []common.Address) (*ERC721ApprovalForAllIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721.contract.FilterLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return &ERC721ApprovalForAllIterator{contract: _ERC721.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721 *ERC721Filterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ERC721ApprovalForAll, _owner []common.Address, _operator []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721.contract.WatchLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721ApprovalForAll)
				if err := _ERC721.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721 *ERC721Filterer) ParseApprovalForAll(log types.Log) (*ERC721ApprovalForAll, error) {
	event := new(ERC721ApprovalForAll)
	if err := _ERC721.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC721 contract.
type ERC721TransferIterator struct {
	Event *ERC721Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721Transfer represents a Transfer event raised by the ERC721 contract.
type ERC721Transfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721 *ERC721Filterer) FilterTransfer(opts *bind.FilterOpts, _from []common.Address, _to []common.Address) (*ERC721TransferIterator, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721.contract.FilterLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return &ERC721TransferIterator{contract: _ERC721.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721 *ERC721Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC721Transfer, _from []common.Address, _to []common.Address) (event.Subscription, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721.contract.WatchLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721Transfer)
				if err := _ERC721.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721 *ERC721Filterer) ParseTransfer(log types.Log) (*ERC721Transfer, error) {
	event := new(ERC721Transfer)
	if err := _ERC721.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721BasicABI is the input ABI used to generate the binding from.
const ERC721BasicABI = "[{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"_exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]"

// ERC721BasicFuncSigs maps the 4-byte function signature to its string representation.
var ERC721BasicFuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"4f558e79": "exists(uint256)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"6352211e": "ownerOf(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// ERC721Basic is an auto generated Go binding around an Ethereum contract.
type ERC721Basic struct {
	ERC721BasicCaller     // Read-only binding to the contract
	ERC721BasicTransactor // Write-only binding to the contract
	ERC721BasicFilterer   // Log filterer for contract events
}

// ERC721BasicCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC721BasicCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721BasicTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC721BasicTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721BasicFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC721BasicFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721BasicSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC721BasicSession struct {
	Contract     *ERC721Basic      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721BasicCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC721BasicCallerSession struct {
	Contract *ERC721BasicCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// ERC721BasicTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC721BasicTransactorSession struct {
	Contract     *ERC721BasicTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// ERC721BasicRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC721BasicRaw struct {
	Contract *ERC721Basic // Generic contract binding to access the raw methods on
}

// ERC721BasicCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC721BasicCallerRaw struct {
	Contract *ERC721BasicCaller // Generic read-only contract binding to access the raw methods on
}

// ERC721BasicTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC721BasicTransactorRaw struct {
	Contract *ERC721BasicTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC721Basic creates a new instance of ERC721Basic, bound to a specific deployed contract.
func NewERC721Basic(address common.Address, backend bind.ContractBackend) (*ERC721Basic, error) {
	contract, err := bindERC721Basic(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC721Basic{ERC721BasicCaller: ERC721BasicCaller{contract: contract}, ERC721BasicTransactor: ERC721BasicTransactor{contract: contract}, ERC721BasicFilterer: ERC721BasicFilterer{contract: contract}}, nil
}

// NewERC721BasicCaller creates a new read-only instance of ERC721Basic, bound to a specific deployed contract.
func NewERC721BasicCaller(address common.Address, caller bind.ContractCaller) (*ERC721BasicCaller, error) {
	contract, err := bindERC721Basic(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicCaller{contract: contract}, nil
}

// NewERC721BasicTransactor creates a new write-only instance of ERC721Basic, bound to a specific deployed contract.
func NewERC721BasicTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC721BasicTransactor, error) {
	contract, err := bindERC721Basic(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicTransactor{contract: contract}, nil
}

// NewERC721BasicFilterer creates a new log filterer instance of ERC721Basic, bound to a specific deployed contract.
func NewERC721BasicFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC721BasicFilterer, error) {
	contract, err := bindERC721Basic(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicFilterer{contract: contract}, nil
}

// bindERC721Basic binds a generic wrapper to an already deployed contract.
func bindERC721Basic(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721BasicABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Basic *ERC721BasicRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Basic.Contract.ERC721BasicCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Basic *ERC721BasicRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Basic.Contract.ERC721BasicTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Basic *ERC721BasicRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Basic.Contract.ERC721BasicTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Basic *ERC721BasicCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Basic.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Basic *ERC721BasicTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Basic.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Basic *ERC721BasicTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Basic.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 _balance)
func (_ERC721Basic *ERC721BasicCaller) BalanceOf(opts *bind.CallOpts, _owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Basic.contract.Call(opts, out, "balanceOf", _owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 _balance)
func (_ERC721Basic *ERC721BasicSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721Basic.Contract.BalanceOf(&_ERC721Basic.CallOpts, _owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 _balance)
func (_ERC721Basic *ERC721BasicCallerSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721Basic.Contract.BalanceOf(&_ERC721Basic.CallOpts, _owner)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool _exists)
func (_ERC721Basic *ERC721BasicCaller) Exists(opts *bind.CallOpts, _tokenId *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Basic.contract.Call(opts, out, "exists", _tokenId)
	return *ret0, err
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool _exists)
func (_ERC721Basic *ERC721BasicSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721Basic.Contract.Exists(&_ERC721Basic.CallOpts, _tokenId)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool _exists)
func (_ERC721Basic *ERC721BasicCallerSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721Basic.Contract.Exists(&_ERC721Basic.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address _operator)
func (_ERC721Basic *ERC721BasicCaller) GetApproved(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721Basic.contract.Call(opts, out, "getApproved", _tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address _operator)
func (_ERC721Basic *ERC721BasicSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Basic.Contract.GetApproved(&_ERC721Basic.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address _operator)
func (_ERC721Basic *ERC721BasicCallerSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Basic.Contract.GetApproved(&_ERC721Basic.CallOpts, _tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Basic *ERC721BasicCaller) IsApprovedForAll(opts *bind.CallOpts, _owner common.Address, _operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Basic.contract.Call(opts, out, "isApprovedForAll", _owner, _operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Basic *ERC721BasicSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721Basic.Contract.IsApprovedForAll(&_ERC721Basic.CallOpts, _owner, _operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Basic *ERC721BasicCallerSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721Basic.Contract.IsApprovedForAll(&_ERC721Basic.CallOpts, _owner, _operator)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address _owner)
func (_ERC721Basic *ERC721BasicCaller) OwnerOf(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721Basic.contract.Call(opts, out, "ownerOf", _tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address _owner)
func (_ERC721Basic *ERC721BasicSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Basic.Contract.OwnerOf(&_ERC721Basic.CallOpts, _tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address _owner)
func (_ERC721Basic *ERC721BasicCallerSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Basic.Contract.OwnerOf(&_ERC721Basic.CallOpts, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Basic *ERC721BasicTransactor) Approve(opts *bind.TransactOpts, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Basic.contract.Transact(opts, "approve", _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Basic *ERC721BasicSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Basic.Contract.Approve(&_ERC721Basic.TransactOpts, _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Basic *ERC721BasicTransactorSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Basic.Contract.Approve(&_ERC721Basic.TransactOpts, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Basic *ERC721BasicTransactor) SafeTransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Basic.contract.Transact(opts, "safeTransferFrom", _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Basic *ERC721BasicSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Basic.Contract.SafeTransferFrom(&_ERC721Basic.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Basic *ERC721BasicTransactorSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Basic.Contract.SafeTransferFrom(&_ERC721Basic.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Basic *ERC721BasicTransactor) SafeTransferFrom0(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Basic.contract.Transact(opts, "safeTransferFrom0", _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Basic *ERC721BasicSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Basic.Contract.SafeTransferFrom0(&_ERC721Basic.TransactOpts, _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Basic *ERC721BasicTransactorSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Basic.Contract.SafeTransferFrom0(&_ERC721Basic.TransactOpts, _from, _to, _tokenId, _data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _operator, bool _approved) returns()
func (_ERC721Basic *ERC721BasicTransactor) SetApprovalForAll(opts *bind.TransactOpts, _operator common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Basic.contract.Transact(opts, "setApprovalForAll", _operator, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _operator, bool _approved) returns()
func (_ERC721Basic *ERC721BasicSession) SetApprovalForAll(_operator common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Basic.Contract.SetApprovalForAll(&_ERC721Basic.TransactOpts, _operator, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _operator, bool _approved) returns()
func (_ERC721Basic *ERC721BasicTransactorSession) SetApprovalForAll(_operator common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Basic.Contract.SetApprovalForAll(&_ERC721Basic.TransactOpts, _operator, _approved)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Basic *ERC721BasicTransactor) TransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Basic.contract.Transact(opts, "transferFrom", _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Basic *ERC721BasicSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Basic.Contract.TransferFrom(&_ERC721Basic.TransactOpts, _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Basic *ERC721BasicTransactorSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Basic.Contract.TransferFrom(&_ERC721Basic.TransactOpts, _from, _to, _tokenId)
}

// ERC721BasicApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC721Basic contract.
type ERC721BasicApprovalIterator struct {
	Event *ERC721BasicApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721BasicApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721BasicApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721BasicApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721BasicApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721BasicApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721BasicApproval represents a Approval event raised by the ERC721Basic contract.
type ERC721BasicApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Basic *ERC721BasicFilterer) FilterApproval(opts *bind.FilterOpts, _owner []common.Address, _approved []common.Address) (*ERC721BasicApprovalIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721Basic.contract.FilterLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicApprovalIterator{contract: _ERC721Basic.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Basic *ERC721BasicFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC721BasicApproval, _owner []common.Address, _approved []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721Basic.contract.WatchLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721BasicApproval)
				if err := _ERC721Basic.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Basic *ERC721BasicFilterer) ParseApproval(log types.Log) (*ERC721BasicApproval, error) {
	event := new(ERC721BasicApproval)
	if err := _ERC721Basic.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721BasicApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ERC721Basic contract.
type ERC721BasicApprovalForAllIterator struct {
	Event *ERC721BasicApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721BasicApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721BasicApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721BasicApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721BasicApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721BasicApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721BasicApprovalForAll represents a ApprovalForAll event raised by the ERC721Basic contract.
type ERC721BasicApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Basic *ERC721BasicFilterer) FilterApprovalForAll(opts *bind.FilterOpts, _owner []common.Address, _operator []common.Address) (*ERC721BasicApprovalForAllIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721Basic.contract.FilterLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicApprovalForAllIterator{contract: _ERC721Basic.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Basic *ERC721BasicFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ERC721BasicApprovalForAll, _owner []common.Address, _operator []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721Basic.contract.WatchLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721BasicApprovalForAll)
				if err := _ERC721Basic.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Basic *ERC721BasicFilterer) ParseApprovalForAll(log types.Log) (*ERC721BasicApprovalForAll, error) {
	event := new(ERC721BasicApprovalForAll)
	if err := _ERC721Basic.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721BasicTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC721Basic contract.
type ERC721BasicTransferIterator struct {
	Event *ERC721BasicTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721BasicTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721BasicTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721BasicTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721BasicTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721BasicTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721BasicTransfer represents a Transfer event raised by the ERC721Basic contract.
type ERC721BasicTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Basic *ERC721BasicFilterer) FilterTransfer(opts *bind.FilterOpts, _from []common.Address, _to []common.Address) (*ERC721BasicTransferIterator, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721Basic.contract.FilterLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicTransferIterator{contract: _ERC721Basic.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Basic *ERC721BasicFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC721BasicTransfer, _from []common.Address, _to []common.Address) (event.Subscription, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721Basic.contract.WatchLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721BasicTransfer)
				if err := _ERC721Basic.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Basic *ERC721BasicFilterer) ParseTransfer(log types.Log) (*ERC721BasicTransfer, error) {
	event := new(ERC721BasicTransfer)
	if err := _ERC721Basic.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721BasicTokenABI is the input ABI used to generate the binding from.
const ERC721BasicTokenABI = "[{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]"

// ERC721BasicTokenFuncSigs maps the 4-byte function signature to its string representation.
var ERC721BasicTokenFuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"4f558e79": "exists(uint256)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"6352211e": "ownerOf(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// ERC721BasicTokenBin is the compiled bytecode used for deploying new contracts.
var ERC721BasicTokenBin = "0x608060405234801561001057600080fd5b506109f5806100206000396000f3006080604052600436106100a35763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663081812fc81146100a8578063095ea7b3146100dc57806323b872dd1461010257806342842e0e1461012c5780634f558e79146101565780636352211e1461018257806370a082311461019a578063a22cb465146101cd578063b88d4fde146101f3578063e985e9c514610262575b600080fd5b3480156100b457600080fd5b506100c0600435610289565b60408051600160a060020a039092168252519081900360200190f35b3480156100e857600080fd5b50610100600160a060020a03600435166024356102a4565b005b34801561010e57600080fd5b50610100600160a060020a0360043581169060243516604435610396565b34801561013857600080fd5b50610100600160a060020a0360043581169060243516604435610445565b34801561016257600080fd5b5061016e60043561047d565b604080519115158252519081900360200190f35b34801561018e57600080fd5b506100c060043561049a565b3480156101a657600080fd5b506101bb600160a060020a03600435166104c4565b60408051918252519081900360200190f35b3480156101d957600080fd5b50610100600160a060020a036004351660243515156104f7565b3480156101ff57600080fd5b50604080516020601f60643560048181013592830184900484028501840190955281845261010094600160a060020a03813581169560248035909216956044359536956084940191819084018382808284375094975061057b9650505050505050565b34801561026e57600080fd5b5061016e600160a060020a03600435811690602435166105ba565b600090815260016020526040902054600160a060020a031690565b60006102af8261049a565b9050600160a060020a0383811690821614156102ca57600080fd5b33600160a060020a03821614806102e657506102e681336105ba565b15156102f157600080fd5b60006102fc83610289565b600160a060020a031614158061031a5750600160a060020a03831615155b1561039157600082815260016020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03878116918217909255835186815293519093918516927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a35b505050565b806103a133826105e8565b15156103ac57600080fd5b600160a060020a03841615156103c157600080fd5b600160a060020a03831615156103d657600080fd5b6103e08483610647565b6103ea84836106f5565b6103f4838361078a565b82600160a060020a031684600160a060020a03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a350505050565b8061045033826105e8565b151561045b57600080fd5b610477848484602060405190810160405280600081525061057b565b50505050565b600090815260208190526040902054600160a060020a0316151590565b600081815260208190526040812054600160a060020a03168015156104be57600080fd5b92915050565b6000600160a060020a03821615156104db57600080fd5b50600160a060020a031660009081526002602052604090205490565b600160a060020a03821633141561050d57600080fd5b336000818152600360209081526040808320600160a060020a03871680855290835292819020805460ff1916861515908117909155815190815290519293927f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31929181900390910190a35050565b8161058633826105e8565b151561059157600080fd5b61059c858585610396565b6105a885858585610819565b15156105b357600080fd5b5050505050565b600160a060020a03918216600090815260036020908152604080832093909416825291909152205460ff1690565b6000806105f48361049a565b905080600160a060020a031684600160a060020a0316148061062f575083600160a060020a031661062484610289565b600160a060020a0316145b8061063f575061063f81856105ba565b949350505050565b81600160a060020a031661065a8261049a565b600160a060020a03161461066d57600080fd5b600081815260016020526040902054600160a060020a0316156106f1576000818152600160209081526040808320805473ffffffffffffffffffffffffffffffffffffffff1916905580518481529051600160a060020a038616927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a35b5050565b81600160a060020a03166107088261049a565b600160a060020a03161461071b57600080fd5b600160a060020a03821660009081526002602052604090205461074590600163ffffffff6109a216565b600160a060020a039092166000908152600260209081526040808320949094559181529081905220805473ffffffffffffffffffffffffffffffffffffffff19169055565b600081815260208190526040902054600160a060020a0316156107ac57600080fd5b600081815260208181526040808320805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038716908117909155835260029091529020546107f99060016109b4565b600160a060020a0390921660009081526002602052604090209190915550565b60008061082e85600160a060020a03166109c1565b151561083d5760019150610999565b84600160a060020a031663f0b9e5ba8786866040518463ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018084600160a060020a0316600160a060020a0316815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b838110156108d55781810151838201526020016108bd565b50505050905090810190601f1680156109025780820380516001836020036101000a031916815260200191505b50945050505050602060405180830381600087803b15801561092357600080fd5b505af1158015610937573d6000803e3d6000fd5b505050506040513d602081101561094d57600080fd5b50517fffffffff0000000000000000000000000000000000000000000000000000000081167ff0b9e5ba0000000000000000000000000000000000000000000000000000000014925090505b50949350505050565b6000828211156109ae57fe5b50900390565b818101828110156104be57fe5b6000903b11905600a165627a7a7230582078d996e082451f4d78eb76f6e532dcf7fb9e69830caf2f588d4df0b5bcb35af10029"

// DeployERC721BasicToken deploys a new Ethereum contract, binding an instance of ERC721BasicToken to it.
func DeployERC721BasicToken(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ERC721BasicToken, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721BasicTokenABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ERC721BasicTokenBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC721BasicToken{ERC721BasicTokenCaller: ERC721BasicTokenCaller{contract: contract}, ERC721BasicTokenTransactor: ERC721BasicTokenTransactor{contract: contract}, ERC721BasicTokenFilterer: ERC721BasicTokenFilterer{contract: contract}}, nil
}

// ERC721BasicToken is an auto generated Go binding around an Ethereum contract.
type ERC721BasicToken struct {
	ERC721BasicTokenCaller     // Read-only binding to the contract
	ERC721BasicTokenTransactor // Write-only binding to the contract
	ERC721BasicTokenFilterer   // Log filterer for contract events
}

// ERC721BasicTokenCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC721BasicTokenCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721BasicTokenTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC721BasicTokenTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721BasicTokenFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC721BasicTokenFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721BasicTokenSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC721BasicTokenSession struct {
	Contract     *ERC721BasicToken // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721BasicTokenCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC721BasicTokenCallerSession struct {
	Contract *ERC721BasicTokenCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// ERC721BasicTokenTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC721BasicTokenTransactorSession struct {
	Contract     *ERC721BasicTokenTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// ERC721BasicTokenRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC721BasicTokenRaw struct {
	Contract *ERC721BasicToken // Generic contract binding to access the raw methods on
}

// ERC721BasicTokenCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC721BasicTokenCallerRaw struct {
	Contract *ERC721BasicTokenCaller // Generic read-only contract binding to access the raw methods on
}

// ERC721BasicTokenTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC721BasicTokenTransactorRaw struct {
	Contract *ERC721BasicTokenTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC721BasicToken creates a new instance of ERC721BasicToken, bound to a specific deployed contract.
func NewERC721BasicToken(address common.Address, backend bind.ContractBackend) (*ERC721BasicToken, error) {
	contract, err := bindERC721BasicToken(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicToken{ERC721BasicTokenCaller: ERC721BasicTokenCaller{contract: contract}, ERC721BasicTokenTransactor: ERC721BasicTokenTransactor{contract: contract}, ERC721BasicTokenFilterer: ERC721BasicTokenFilterer{contract: contract}}, nil
}

// NewERC721BasicTokenCaller creates a new read-only instance of ERC721BasicToken, bound to a specific deployed contract.
func NewERC721BasicTokenCaller(address common.Address, caller bind.ContractCaller) (*ERC721BasicTokenCaller, error) {
	contract, err := bindERC721BasicToken(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicTokenCaller{contract: contract}, nil
}

// NewERC721BasicTokenTransactor creates a new write-only instance of ERC721BasicToken, bound to a specific deployed contract.
func NewERC721BasicTokenTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC721BasicTokenTransactor, error) {
	contract, err := bindERC721BasicToken(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicTokenTransactor{contract: contract}, nil
}

// NewERC721BasicTokenFilterer creates a new log filterer instance of ERC721BasicToken, bound to a specific deployed contract.
func NewERC721BasicTokenFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC721BasicTokenFilterer, error) {
	contract, err := bindERC721BasicToken(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicTokenFilterer{contract: contract}, nil
}

// bindERC721BasicToken binds a generic wrapper to an already deployed contract.
func bindERC721BasicToken(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721BasicTokenABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721BasicToken *ERC721BasicTokenRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721BasicToken.Contract.ERC721BasicTokenCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721BasicToken *ERC721BasicTokenRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.ERC721BasicTokenTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721BasicToken *ERC721BasicTokenRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.ERC721BasicTokenTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721BasicToken *ERC721BasicTokenCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721BasicToken.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721BasicToken *ERC721BasicTokenTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721BasicToken *ERC721BasicTokenTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_ERC721BasicToken *ERC721BasicTokenCaller) BalanceOf(opts *bind.CallOpts, _owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721BasicToken.contract.Call(opts, out, "balanceOf", _owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_ERC721BasicToken *ERC721BasicTokenSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721BasicToken.Contract.BalanceOf(&_ERC721BasicToken.CallOpts, _owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_ERC721BasicToken *ERC721BasicTokenCallerSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721BasicToken.Contract.BalanceOf(&_ERC721BasicToken.CallOpts, _owner)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_ERC721BasicToken *ERC721BasicTokenCaller) Exists(opts *bind.CallOpts, _tokenId *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721BasicToken.contract.Call(opts, out, "exists", _tokenId)
	return *ret0, err
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_ERC721BasicToken *ERC721BasicTokenSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721BasicToken.Contract.Exists(&_ERC721BasicToken.CallOpts, _tokenId)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_ERC721BasicToken *ERC721BasicTokenCallerSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721BasicToken.Contract.Exists(&_ERC721BasicToken.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_ERC721BasicToken *ERC721BasicTokenCaller) GetApproved(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721BasicToken.contract.Call(opts, out, "getApproved", _tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_ERC721BasicToken *ERC721BasicTokenSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721BasicToken.Contract.GetApproved(&_ERC721BasicToken.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_ERC721BasicToken *ERC721BasicTokenCallerSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721BasicToken.Contract.GetApproved(&_ERC721BasicToken.CallOpts, _tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721BasicToken *ERC721BasicTokenCaller) IsApprovedForAll(opts *bind.CallOpts, _owner common.Address, _operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721BasicToken.contract.Call(opts, out, "isApprovedForAll", _owner, _operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721BasicToken *ERC721BasicTokenSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721BasicToken.Contract.IsApprovedForAll(&_ERC721BasicToken.CallOpts, _owner, _operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721BasicToken *ERC721BasicTokenCallerSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721BasicToken.Contract.IsApprovedForAll(&_ERC721BasicToken.CallOpts, _owner, _operator)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_ERC721BasicToken *ERC721BasicTokenCaller) OwnerOf(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721BasicToken.contract.Call(opts, out, "ownerOf", _tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_ERC721BasicToken *ERC721BasicTokenSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721BasicToken.Contract.OwnerOf(&_ERC721BasicToken.CallOpts, _tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_ERC721BasicToken *ERC721BasicTokenCallerSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721BasicToken.Contract.OwnerOf(&_ERC721BasicToken.CallOpts, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721BasicToken *ERC721BasicTokenTransactor) Approve(opts *bind.TransactOpts, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721BasicToken.contract.Transact(opts, "approve", _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721BasicToken *ERC721BasicTokenSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.Approve(&_ERC721BasicToken.TransactOpts, _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721BasicToken *ERC721BasicTokenTransactorSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.Approve(&_ERC721BasicToken.TransactOpts, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721BasicToken *ERC721BasicTokenTransactor) SafeTransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721BasicToken.contract.Transact(opts, "safeTransferFrom", _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721BasicToken *ERC721BasicTokenSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.SafeTransferFrom(&_ERC721BasicToken.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721BasicToken *ERC721BasicTokenTransactorSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.SafeTransferFrom(&_ERC721BasicToken.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721BasicToken *ERC721BasicTokenTransactor) SafeTransferFrom0(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721BasicToken.contract.Transact(opts, "safeTransferFrom0", _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721BasicToken *ERC721BasicTokenSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.SafeTransferFrom0(&_ERC721BasicToken.TransactOpts, _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721BasicToken *ERC721BasicTokenTransactorSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.SafeTransferFrom0(&_ERC721BasicToken.TransactOpts, _from, _to, _tokenId, _data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_ERC721BasicToken *ERC721BasicTokenTransactor) SetApprovalForAll(opts *bind.TransactOpts, _to common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721BasicToken.contract.Transact(opts, "setApprovalForAll", _to, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_ERC721BasicToken *ERC721BasicTokenSession) SetApprovalForAll(_to common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.SetApprovalForAll(&_ERC721BasicToken.TransactOpts, _to, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_ERC721BasicToken *ERC721BasicTokenTransactorSession) SetApprovalForAll(_to common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.SetApprovalForAll(&_ERC721BasicToken.TransactOpts, _to, _approved)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721BasicToken *ERC721BasicTokenTransactor) TransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721BasicToken.contract.Transact(opts, "transferFrom", _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721BasicToken *ERC721BasicTokenSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.TransferFrom(&_ERC721BasicToken.TransactOpts, _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721BasicToken *ERC721BasicTokenTransactorSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721BasicToken.Contract.TransferFrom(&_ERC721BasicToken.TransactOpts, _from, _to, _tokenId)
}

// ERC721BasicTokenApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC721BasicToken contract.
type ERC721BasicTokenApprovalIterator struct {
	Event *ERC721BasicTokenApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721BasicTokenApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721BasicTokenApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721BasicTokenApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721BasicTokenApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721BasicTokenApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721BasicTokenApproval represents a Approval event raised by the ERC721BasicToken contract.
type ERC721BasicTokenApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721BasicToken *ERC721BasicTokenFilterer) FilterApproval(opts *bind.FilterOpts, _owner []common.Address, _approved []common.Address) (*ERC721BasicTokenApprovalIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721BasicToken.contract.FilterLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicTokenApprovalIterator{contract: _ERC721BasicToken.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721BasicToken *ERC721BasicTokenFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC721BasicTokenApproval, _owner []common.Address, _approved []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721BasicToken.contract.WatchLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721BasicTokenApproval)
				if err := _ERC721BasicToken.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721BasicToken *ERC721BasicTokenFilterer) ParseApproval(log types.Log) (*ERC721BasicTokenApproval, error) {
	event := new(ERC721BasicTokenApproval)
	if err := _ERC721BasicToken.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721BasicTokenApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ERC721BasicToken contract.
type ERC721BasicTokenApprovalForAllIterator struct {
	Event *ERC721BasicTokenApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721BasicTokenApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721BasicTokenApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721BasicTokenApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721BasicTokenApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721BasicTokenApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721BasicTokenApprovalForAll represents a ApprovalForAll event raised by the ERC721BasicToken contract.
type ERC721BasicTokenApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721BasicToken *ERC721BasicTokenFilterer) FilterApprovalForAll(opts *bind.FilterOpts, _owner []common.Address, _operator []common.Address) (*ERC721BasicTokenApprovalForAllIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721BasicToken.contract.FilterLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicTokenApprovalForAllIterator{contract: _ERC721BasicToken.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721BasicToken *ERC721BasicTokenFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ERC721BasicTokenApprovalForAll, _owner []common.Address, _operator []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721BasicToken.contract.WatchLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721BasicTokenApprovalForAll)
				if err := _ERC721BasicToken.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721BasicToken *ERC721BasicTokenFilterer) ParseApprovalForAll(log types.Log) (*ERC721BasicTokenApprovalForAll, error) {
	event := new(ERC721BasicTokenApprovalForAll)
	if err := _ERC721BasicToken.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721BasicTokenTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC721BasicToken contract.
type ERC721BasicTokenTransferIterator struct {
	Event *ERC721BasicTokenTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721BasicTokenTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721BasicTokenTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721BasicTokenTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721BasicTokenTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721BasicTokenTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721BasicTokenTransfer represents a Transfer event raised by the ERC721BasicToken contract.
type ERC721BasicTokenTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721BasicToken *ERC721BasicTokenFilterer) FilterTransfer(opts *bind.FilterOpts, _from []common.Address, _to []common.Address) (*ERC721BasicTokenTransferIterator, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721BasicToken.contract.FilterLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return &ERC721BasicTokenTransferIterator{contract: _ERC721BasicToken.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721BasicToken *ERC721BasicTokenFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC721BasicTokenTransfer, _from []common.Address, _to []common.Address) (event.Subscription, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721BasicToken.contract.WatchLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721BasicTokenTransfer)
				if err := _ERC721BasicToken.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721BasicToken *ERC721BasicTokenFilterer) ParseTransfer(log types.Log) (*ERC721BasicTokenTransfer, error) {
	event := new(ERC721BasicTokenTransfer)
	if err := _ERC721BasicToken.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721EnumerableABI is the input ABI used to generate the binding from.
const ERC721EnumerableABI = "[{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"_exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]"

// ERC721EnumerableFuncSigs maps the 4-byte function signature to its string representation.
var ERC721EnumerableFuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"4f558e79": "exists(uint256)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"6352211e": "ownerOf(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"4f6ccce7": "tokenByIndex(uint256)",
	"2f745c59": "tokenOfOwnerByIndex(address,uint256)",
	"18160ddd": "totalSupply()",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// ERC721Enumerable is an auto generated Go binding around an Ethereum contract.
type ERC721Enumerable struct {
	ERC721EnumerableCaller     // Read-only binding to the contract
	ERC721EnumerableTransactor // Write-only binding to the contract
	ERC721EnumerableFilterer   // Log filterer for contract events
}

// ERC721EnumerableCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC721EnumerableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721EnumerableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC721EnumerableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721EnumerableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC721EnumerableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721EnumerableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC721EnumerableSession struct {
	Contract     *ERC721Enumerable // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721EnumerableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC721EnumerableCallerSession struct {
	Contract *ERC721EnumerableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// ERC721EnumerableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC721EnumerableTransactorSession struct {
	Contract     *ERC721EnumerableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// ERC721EnumerableRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC721EnumerableRaw struct {
	Contract *ERC721Enumerable // Generic contract binding to access the raw methods on
}

// ERC721EnumerableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC721EnumerableCallerRaw struct {
	Contract *ERC721EnumerableCaller // Generic read-only contract binding to access the raw methods on
}

// ERC721EnumerableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC721EnumerableTransactorRaw struct {
	Contract *ERC721EnumerableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC721Enumerable creates a new instance of ERC721Enumerable, bound to a specific deployed contract.
func NewERC721Enumerable(address common.Address, backend bind.ContractBackend) (*ERC721Enumerable, error) {
	contract, err := bindERC721Enumerable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC721Enumerable{ERC721EnumerableCaller: ERC721EnumerableCaller{contract: contract}, ERC721EnumerableTransactor: ERC721EnumerableTransactor{contract: contract}, ERC721EnumerableFilterer: ERC721EnumerableFilterer{contract: contract}}, nil
}

// NewERC721EnumerableCaller creates a new read-only instance of ERC721Enumerable, bound to a specific deployed contract.
func NewERC721EnumerableCaller(address common.Address, caller bind.ContractCaller) (*ERC721EnumerableCaller, error) {
	contract, err := bindERC721Enumerable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721EnumerableCaller{contract: contract}, nil
}

// NewERC721EnumerableTransactor creates a new write-only instance of ERC721Enumerable, bound to a specific deployed contract.
func NewERC721EnumerableTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC721EnumerableTransactor, error) {
	contract, err := bindERC721Enumerable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721EnumerableTransactor{contract: contract}, nil
}

// NewERC721EnumerableFilterer creates a new log filterer instance of ERC721Enumerable, bound to a specific deployed contract.
func NewERC721EnumerableFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC721EnumerableFilterer, error) {
	contract, err := bindERC721Enumerable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC721EnumerableFilterer{contract: contract}, nil
}

// bindERC721Enumerable binds a generic wrapper to an already deployed contract.
func bindERC721Enumerable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721EnumerableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Enumerable *ERC721EnumerableRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Enumerable.Contract.ERC721EnumerableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Enumerable *ERC721EnumerableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.ERC721EnumerableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Enumerable *ERC721EnumerableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.ERC721EnumerableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Enumerable *ERC721EnumerableCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Enumerable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Enumerable *ERC721EnumerableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Enumerable *ERC721EnumerableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 _balance)
func (_ERC721Enumerable *ERC721EnumerableCaller) BalanceOf(opts *bind.CallOpts, _owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Enumerable.contract.Call(opts, out, "balanceOf", _owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 _balance)
func (_ERC721Enumerable *ERC721EnumerableSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721Enumerable.Contract.BalanceOf(&_ERC721Enumerable.CallOpts, _owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 _balance)
func (_ERC721Enumerable *ERC721EnumerableCallerSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721Enumerable.Contract.BalanceOf(&_ERC721Enumerable.CallOpts, _owner)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool _exists)
func (_ERC721Enumerable *ERC721EnumerableCaller) Exists(opts *bind.CallOpts, _tokenId *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Enumerable.contract.Call(opts, out, "exists", _tokenId)
	return *ret0, err
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool _exists)
func (_ERC721Enumerable *ERC721EnumerableSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721Enumerable.Contract.Exists(&_ERC721Enumerable.CallOpts, _tokenId)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool _exists)
func (_ERC721Enumerable *ERC721EnumerableCallerSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721Enumerable.Contract.Exists(&_ERC721Enumerable.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address _operator)
func (_ERC721Enumerable *ERC721EnumerableCaller) GetApproved(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721Enumerable.contract.Call(opts, out, "getApproved", _tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address _operator)
func (_ERC721Enumerable *ERC721EnumerableSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Enumerable.Contract.GetApproved(&_ERC721Enumerable.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address _operator)
func (_ERC721Enumerable *ERC721EnumerableCallerSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Enumerable.Contract.GetApproved(&_ERC721Enumerable.CallOpts, _tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Enumerable *ERC721EnumerableCaller) IsApprovedForAll(opts *bind.CallOpts, _owner common.Address, _operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Enumerable.contract.Call(opts, out, "isApprovedForAll", _owner, _operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Enumerable *ERC721EnumerableSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721Enumerable.Contract.IsApprovedForAll(&_ERC721Enumerable.CallOpts, _owner, _operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Enumerable *ERC721EnumerableCallerSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721Enumerable.Contract.IsApprovedForAll(&_ERC721Enumerable.CallOpts, _owner, _operator)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address _owner)
func (_ERC721Enumerable *ERC721EnumerableCaller) OwnerOf(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721Enumerable.contract.Call(opts, out, "ownerOf", _tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address _owner)
func (_ERC721Enumerable *ERC721EnumerableSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Enumerable.Contract.OwnerOf(&_ERC721Enumerable.CallOpts, _tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address _owner)
func (_ERC721Enumerable *ERC721EnumerableCallerSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Enumerable.Contract.OwnerOf(&_ERC721Enumerable.CallOpts, _tokenId)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_ERC721Enumerable *ERC721EnumerableCaller) TokenByIndex(opts *bind.CallOpts, _index *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Enumerable.contract.Call(opts, out, "tokenByIndex", _index)
	return *ret0, err
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_ERC721Enumerable *ERC721EnumerableSession) TokenByIndex(_index *big.Int) (*big.Int, error) {
	return _ERC721Enumerable.Contract.TokenByIndex(&_ERC721Enumerable.CallOpts, _index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_ERC721Enumerable *ERC721EnumerableCallerSession) TokenByIndex(_index *big.Int) (*big.Int, error) {
	return _ERC721Enumerable.Contract.TokenByIndex(&_ERC721Enumerable.CallOpts, _index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256 _tokenId)
func (_ERC721Enumerable *ERC721EnumerableCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, _owner common.Address, _index *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Enumerable.contract.Call(opts, out, "tokenOfOwnerByIndex", _owner, _index)
	return *ret0, err
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256 _tokenId)
func (_ERC721Enumerable *ERC721EnumerableSession) TokenOfOwnerByIndex(_owner common.Address, _index *big.Int) (*big.Int, error) {
	return _ERC721Enumerable.Contract.TokenOfOwnerByIndex(&_ERC721Enumerable.CallOpts, _owner, _index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256 _tokenId)
func (_ERC721Enumerable *ERC721EnumerableCallerSession) TokenOfOwnerByIndex(_owner common.Address, _index *big.Int) (*big.Int, error) {
	return _ERC721Enumerable.Contract.TokenOfOwnerByIndex(&_ERC721Enumerable.CallOpts, _owner, _index)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC721Enumerable *ERC721EnumerableCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Enumerable.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC721Enumerable *ERC721EnumerableSession) TotalSupply() (*big.Int, error) {
	return _ERC721Enumerable.Contract.TotalSupply(&_ERC721Enumerable.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC721Enumerable *ERC721EnumerableCallerSession) TotalSupply() (*big.Int, error) {
	return _ERC721Enumerable.Contract.TotalSupply(&_ERC721Enumerable.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Enumerable *ERC721EnumerableTransactor) Approve(opts *bind.TransactOpts, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Enumerable.contract.Transact(opts, "approve", _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Enumerable *ERC721EnumerableSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.Approve(&_ERC721Enumerable.TransactOpts, _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Enumerable *ERC721EnumerableTransactorSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.Approve(&_ERC721Enumerable.TransactOpts, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Enumerable *ERC721EnumerableTransactor) SafeTransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Enumerable.contract.Transact(opts, "safeTransferFrom", _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Enumerable *ERC721EnumerableSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.SafeTransferFrom(&_ERC721Enumerable.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Enumerable *ERC721EnumerableTransactorSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.SafeTransferFrom(&_ERC721Enumerable.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Enumerable *ERC721EnumerableTransactor) SafeTransferFrom0(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Enumerable.contract.Transact(opts, "safeTransferFrom0", _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Enumerable *ERC721EnumerableSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.SafeTransferFrom0(&_ERC721Enumerable.TransactOpts, _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Enumerable *ERC721EnumerableTransactorSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.SafeTransferFrom0(&_ERC721Enumerable.TransactOpts, _from, _to, _tokenId, _data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _operator, bool _approved) returns()
func (_ERC721Enumerable *ERC721EnumerableTransactor) SetApprovalForAll(opts *bind.TransactOpts, _operator common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Enumerable.contract.Transact(opts, "setApprovalForAll", _operator, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _operator, bool _approved) returns()
func (_ERC721Enumerable *ERC721EnumerableSession) SetApprovalForAll(_operator common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.SetApprovalForAll(&_ERC721Enumerable.TransactOpts, _operator, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _operator, bool _approved) returns()
func (_ERC721Enumerable *ERC721EnumerableTransactorSession) SetApprovalForAll(_operator common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.SetApprovalForAll(&_ERC721Enumerable.TransactOpts, _operator, _approved)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Enumerable *ERC721EnumerableTransactor) TransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Enumerable.contract.Transact(opts, "transferFrom", _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Enumerable *ERC721EnumerableSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.TransferFrom(&_ERC721Enumerable.TransactOpts, _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Enumerable *ERC721EnumerableTransactorSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Enumerable.Contract.TransferFrom(&_ERC721Enumerable.TransactOpts, _from, _to, _tokenId)
}

// ERC721EnumerableApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC721Enumerable contract.
type ERC721EnumerableApprovalIterator struct {
	Event *ERC721EnumerableApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721EnumerableApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721EnumerableApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721EnumerableApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721EnumerableApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721EnumerableApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721EnumerableApproval represents a Approval event raised by the ERC721Enumerable contract.
type ERC721EnumerableApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Enumerable *ERC721EnumerableFilterer) FilterApproval(opts *bind.FilterOpts, _owner []common.Address, _approved []common.Address) (*ERC721EnumerableApprovalIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721Enumerable.contract.FilterLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return &ERC721EnumerableApprovalIterator{contract: _ERC721Enumerable.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Enumerable *ERC721EnumerableFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC721EnumerableApproval, _owner []common.Address, _approved []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721Enumerable.contract.WatchLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721EnumerableApproval)
				if err := _ERC721Enumerable.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Enumerable *ERC721EnumerableFilterer) ParseApproval(log types.Log) (*ERC721EnumerableApproval, error) {
	event := new(ERC721EnumerableApproval)
	if err := _ERC721Enumerable.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721EnumerableApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ERC721Enumerable contract.
type ERC721EnumerableApprovalForAllIterator struct {
	Event *ERC721EnumerableApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721EnumerableApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721EnumerableApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721EnumerableApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721EnumerableApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721EnumerableApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721EnumerableApprovalForAll represents a ApprovalForAll event raised by the ERC721Enumerable contract.
type ERC721EnumerableApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Enumerable *ERC721EnumerableFilterer) FilterApprovalForAll(opts *bind.FilterOpts, _owner []common.Address, _operator []common.Address) (*ERC721EnumerableApprovalForAllIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721Enumerable.contract.FilterLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return &ERC721EnumerableApprovalForAllIterator{contract: _ERC721Enumerable.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Enumerable *ERC721EnumerableFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ERC721EnumerableApprovalForAll, _owner []common.Address, _operator []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721Enumerable.contract.WatchLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721EnumerableApprovalForAll)
				if err := _ERC721Enumerable.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Enumerable *ERC721EnumerableFilterer) ParseApprovalForAll(log types.Log) (*ERC721EnumerableApprovalForAll, error) {
	event := new(ERC721EnumerableApprovalForAll)
	if err := _ERC721Enumerable.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721EnumerableTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC721Enumerable contract.
type ERC721EnumerableTransferIterator struct {
	Event *ERC721EnumerableTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721EnumerableTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721EnumerableTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721EnumerableTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721EnumerableTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721EnumerableTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721EnumerableTransfer represents a Transfer event raised by the ERC721Enumerable contract.
type ERC721EnumerableTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Enumerable *ERC721EnumerableFilterer) FilterTransfer(opts *bind.FilterOpts, _from []common.Address, _to []common.Address) (*ERC721EnumerableTransferIterator, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721Enumerable.contract.FilterLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return &ERC721EnumerableTransferIterator{contract: _ERC721Enumerable.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Enumerable *ERC721EnumerableFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC721EnumerableTransfer, _from []common.Address, _to []common.Address) (event.Subscription, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721Enumerable.contract.WatchLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721EnumerableTransfer)
				if err := _ERC721Enumerable.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Enumerable *ERC721EnumerableFilterer) ParseTransfer(log types.Log) (*ERC721EnumerableTransfer, error) {
	event := new(ERC721EnumerableTransfer)
	if err := _ERC721Enumerable.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721HolderABI is the input ABI used to generate the binding from.
const ERC721HolderABI = "[{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ERC721HolderFuncSigs maps the 4-byte function signature to its string representation.
var ERC721HolderFuncSigs = map[string]string{
	"f0b9e5ba": "onERC721Received(address,uint256,bytes)",
}

// ERC721HolderBin is the compiled bytecode used for deploying new contracts.
var ERC721HolderBin = "0x608060405234801561001057600080fd5b50610144806100206000396000f3006080604052600436106100405763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663f0b9e5ba8114610045575b600080fd5b34801561005157600080fd5b50604080516020600460443581810135601f81018490048402850184019095528484526100bb94823573ffffffffffffffffffffffffffffffffffffffff169460248035953695946064949201919081908401838280828437509497506100f09650505050505050565b604080517fffffffff000000000000000000000000000000000000000000000000000000009092168252519081900360200190f35b7ff0b9e5ba0000000000000000000000000000000000000000000000000000000093925050505600a165627a7a72305820e79da40189cc3c6463e5cdbb594459b5f5699ac571abe2d5381f85e8acb91c3b0029"

// DeployERC721Holder deploys a new Ethereum contract, binding an instance of ERC721Holder to it.
func DeployERC721Holder(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ERC721Holder, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721HolderABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ERC721HolderBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC721Holder{ERC721HolderCaller: ERC721HolderCaller{contract: contract}, ERC721HolderTransactor: ERC721HolderTransactor{contract: contract}, ERC721HolderFilterer: ERC721HolderFilterer{contract: contract}}, nil
}

// ERC721Holder is an auto generated Go binding around an Ethereum contract.
type ERC721Holder struct {
	ERC721HolderCaller     // Read-only binding to the contract
	ERC721HolderTransactor // Write-only binding to the contract
	ERC721HolderFilterer   // Log filterer for contract events
}

// ERC721HolderCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC721HolderCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721HolderTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC721HolderTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721HolderFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC721HolderFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721HolderSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC721HolderSession struct {
	Contract     *ERC721Holder     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721HolderCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC721HolderCallerSession struct {
	Contract *ERC721HolderCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// ERC721HolderTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC721HolderTransactorSession struct {
	Contract     *ERC721HolderTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// ERC721HolderRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC721HolderRaw struct {
	Contract *ERC721Holder // Generic contract binding to access the raw methods on
}

// ERC721HolderCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC721HolderCallerRaw struct {
	Contract *ERC721HolderCaller // Generic read-only contract binding to access the raw methods on
}

// ERC721HolderTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC721HolderTransactorRaw struct {
	Contract *ERC721HolderTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC721Holder creates a new instance of ERC721Holder, bound to a specific deployed contract.
func NewERC721Holder(address common.Address, backend bind.ContractBackend) (*ERC721Holder, error) {
	contract, err := bindERC721Holder(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC721Holder{ERC721HolderCaller: ERC721HolderCaller{contract: contract}, ERC721HolderTransactor: ERC721HolderTransactor{contract: contract}, ERC721HolderFilterer: ERC721HolderFilterer{contract: contract}}, nil
}

// NewERC721HolderCaller creates a new read-only instance of ERC721Holder, bound to a specific deployed contract.
func NewERC721HolderCaller(address common.Address, caller bind.ContractCaller) (*ERC721HolderCaller, error) {
	contract, err := bindERC721Holder(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721HolderCaller{contract: contract}, nil
}

// NewERC721HolderTransactor creates a new write-only instance of ERC721Holder, bound to a specific deployed contract.
func NewERC721HolderTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC721HolderTransactor, error) {
	contract, err := bindERC721Holder(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721HolderTransactor{contract: contract}, nil
}

// NewERC721HolderFilterer creates a new log filterer instance of ERC721Holder, bound to a specific deployed contract.
func NewERC721HolderFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC721HolderFilterer, error) {
	contract, err := bindERC721Holder(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC721HolderFilterer{contract: contract}, nil
}

// bindERC721Holder binds a generic wrapper to an already deployed contract.
func bindERC721Holder(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721HolderABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Holder *ERC721HolderRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Holder.Contract.ERC721HolderCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Holder *ERC721HolderRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Holder.Contract.ERC721HolderTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Holder *ERC721HolderRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Holder.Contract.ERC721HolderTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Holder *ERC721HolderCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Holder.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Holder *ERC721HolderTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Holder.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Holder *ERC721HolderTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Holder.Contract.contract.Transact(opts, method, params...)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xf0b9e5ba.
//
// Solidity: function onERC721Received(address , uint256 , bytes ) returns(bytes4)
func (_ERC721Holder *ERC721HolderTransactor) OnERC721Received(opts *bind.TransactOpts, arg0 common.Address, arg1 *big.Int, arg2 []byte) (*types.Transaction, error) {
	return _ERC721Holder.contract.Transact(opts, "onERC721Received", arg0, arg1, arg2)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xf0b9e5ba.
//
// Solidity: function onERC721Received(address , uint256 , bytes ) returns(bytes4)
func (_ERC721Holder *ERC721HolderSession) OnERC721Received(arg0 common.Address, arg1 *big.Int, arg2 []byte) (*types.Transaction, error) {
	return _ERC721Holder.Contract.OnERC721Received(&_ERC721Holder.TransactOpts, arg0, arg1, arg2)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xf0b9e5ba.
//
// Solidity: function onERC721Received(address , uint256 , bytes ) returns(bytes4)
func (_ERC721Holder *ERC721HolderTransactorSession) OnERC721Received(arg0 common.Address, arg1 *big.Int, arg2 []byte) (*types.Transaction, error) {
	return _ERC721Holder.Contract.OnERC721Received(&_ERC721Holder.TransactOpts, arg0, arg1, arg2)
}

// ERC721MetadataABI is the input ABI used to generate the binding from.
const ERC721MetadataABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"_exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]"

// ERC721MetadataFuncSigs maps the 4-byte function signature to its string representation.
var ERC721MetadataFuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"4f558e79": "exists(uint256)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"06fdde03": "name()",
	"6352211e": "ownerOf(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"95d89b41": "symbol()",
	"c87b56dd": "tokenURI(uint256)",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// ERC721Metadata is an auto generated Go binding around an Ethereum contract.
type ERC721Metadata struct {
	ERC721MetadataCaller     // Read-only binding to the contract
	ERC721MetadataTransactor // Write-only binding to the contract
	ERC721MetadataFilterer   // Log filterer for contract events
}

// ERC721MetadataCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC721MetadataCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721MetadataTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC721MetadataTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721MetadataFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC721MetadataFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721MetadataSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC721MetadataSession struct {
	Contract     *ERC721Metadata   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721MetadataCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC721MetadataCallerSession struct {
	Contract *ERC721MetadataCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// ERC721MetadataTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC721MetadataTransactorSession struct {
	Contract     *ERC721MetadataTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// ERC721MetadataRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC721MetadataRaw struct {
	Contract *ERC721Metadata // Generic contract binding to access the raw methods on
}

// ERC721MetadataCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC721MetadataCallerRaw struct {
	Contract *ERC721MetadataCaller // Generic read-only contract binding to access the raw methods on
}

// ERC721MetadataTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC721MetadataTransactorRaw struct {
	Contract *ERC721MetadataTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC721Metadata creates a new instance of ERC721Metadata, bound to a specific deployed contract.
func NewERC721Metadata(address common.Address, backend bind.ContractBackend) (*ERC721Metadata, error) {
	contract, err := bindERC721Metadata(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC721Metadata{ERC721MetadataCaller: ERC721MetadataCaller{contract: contract}, ERC721MetadataTransactor: ERC721MetadataTransactor{contract: contract}, ERC721MetadataFilterer: ERC721MetadataFilterer{contract: contract}}, nil
}

// NewERC721MetadataCaller creates a new read-only instance of ERC721Metadata, bound to a specific deployed contract.
func NewERC721MetadataCaller(address common.Address, caller bind.ContractCaller) (*ERC721MetadataCaller, error) {
	contract, err := bindERC721Metadata(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721MetadataCaller{contract: contract}, nil
}

// NewERC721MetadataTransactor creates a new write-only instance of ERC721Metadata, bound to a specific deployed contract.
func NewERC721MetadataTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC721MetadataTransactor, error) {
	contract, err := bindERC721Metadata(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721MetadataTransactor{contract: contract}, nil
}

// NewERC721MetadataFilterer creates a new log filterer instance of ERC721Metadata, bound to a specific deployed contract.
func NewERC721MetadataFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC721MetadataFilterer, error) {
	contract, err := bindERC721Metadata(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC721MetadataFilterer{contract: contract}, nil
}

// bindERC721Metadata binds a generic wrapper to an already deployed contract.
func bindERC721Metadata(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721MetadataABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Metadata *ERC721MetadataRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Metadata.Contract.ERC721MetadataCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Metadata *ERC721MetadataRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.ERC721MetadataTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Metadata *ERC721MetadataRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.ERC721MetadataTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Metadata *ERC721MetadataCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Metadata.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Metadata *ERC721MetadataTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Metadata *ERC721MetadataTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 _balance)
func (_ERC721Metadata *ERC721MetadataCaller) BalanceOf(opts *bind.CallOpts, _owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Metadata.contract.Call(opts, out, "balanceOf", _owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 _balance)
func (_ERC721Metadata *ERC721MetadataSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721Metadata.Contract.BalanceOf(&_ERC721Metadata.CallOpts, _owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 _balance)
func (_ERC721Metadata *ERC721MetadataCallerSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721Metadata.Contract.BalanceOf(&_ERC721Metadata.CallOpts, _owner)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool _exists)
func (_ERC721Metadata *ERC721MetadataCaller) Exists(opts *bind.CallOpts, _tokenId *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Metadata.contract.Call(opts, out, "exists", _tokenId)
	return *ret0, err
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool _exists)
func (_ERC721Metadata *ERC721MetadataSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721Metadata.Contract.Exists(&_ERC721Metadata.CallOpts, _tokenId)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool _exists)
func (_ERC721Metadata *ERC721MetadataCallerSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721Metadata.Contract.Exists(&_ERC721Metadata.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address _operator)
func (_ERC721Metadata *ERC721MetadataCaller) GetApproved(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721Metadata.contract.Call(opts, out, "getApproved", _tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address _operator)
func (_ERC721Metadata *ERC721MetadataSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Metadata.Contract.GetApproved(&_ERC721Metadata.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address _operator)
func (_ERC721Metadata *ERC721MetadataCallerSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Metadata.Contract.GetApproved(&_ERC721Metadata.CallOpts, _tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Metadata *ERC721MetadataCaller) IsApprovedForAll(opts *bind.CallOpts, _owner common.Address, _operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Metadata.contract.Call(opts, out, "isApprovedForAll", _owner, _operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Metadata *ERC721MetadataSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721Metadata.Contract.IsApprovedForAll(&_ERC721Metadata.CallOpts, _owner, _operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Metadata *ERC721MetadataCallerSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721Metadata.Contract.IsApprovedForAll(&_ERC721Metadata.CallOpts, _owner, _operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string _name)
func (_ERC721Metadata *ERC721MetadataCaller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721Metadata.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string _name)
func (_ERC721Metadata *ERC721MetadataSession) Name() (string, error) {
	return _ERC721Metadata.Contract.Name(&_ERC721Metadata.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string _name)
func (_ERC721Metadata *ERC721MetadataCallerSession) Name() (string, error) {
	return _ERC721Metadata.Contract.Name(&_ERC721Metadata.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address _owner)
func (_ERC721Metadata *ERC721MetadataCaller) OwnerOf(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721Metadata.contract.Call(opts, out, "ownerOf", _tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address _owner)
func (_ERC721Metadata *ERC721MetadataSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Metadata.Contract.OwnerOf(&_ERC721Metadata.CallOpts, _tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address _owner)
func (_ERC721Metadata *ERC721MetadataCallerSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Metadata.Contract.OwnerOf(&_ERC721Metadata.CallOpts, _tokenId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string _symbol)
func (_ERC721Metadata *ERC721MetadataCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721Metadata.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string _symbol)
func (_ERC721Metadata *ERC721MetadataSession) Symbol() (string, error) {
	return _ERC721Metadata.Contract.Symbol(&_ERC721Metadata.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string _symbol)
func (_ERC721Metadata *ERC721MetadataCallerSession) Symbol() (string, error) {
	return _ERC721Metadata.Contract.Symbol(&_ERC721Metadata.CallOpts)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_ERC721Metadata *ERC721MetadataCaller) TokenURI(opts *bind.CallOpts, _tokenId *big.Int) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721Metadata.contract.Call(opts, out, "tokenURI", _tokenId)
	return *ret0, err
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_ERC721Metadata *ERC721MetadataSession) TokenURI(_tokenId *big.Int) (string, error) {
	return _ERC721Metadata.Contract.TokenURI(&_ERC721Metadata.CallOpts, _tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_ERC721Metadata *ERC721MetadataCallerSession) TokenURI(_tokenId *big.Int) (string, error) {
	return _ERC721Metadata.Contract.TokenURI(&_ERC721Metadata.CallOpts, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Metadata *ERC721MetadataTransactor) Approve(opts *bind.TransactOpts, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Metadata.contract.Transact(opts, "approve", _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Metadata *ERC721MetadataSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.Approve(&_ERC721Metadata.TransactOpts, _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Metadata *ERC721MetadataTransactorSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.Approve(&_ERC721Metadata.TransactOpts, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Metadata *ERC721MetadataTransactor) SafeTransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Metadata.contract.Transact(opts, "safeTransferFrom", _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Metadata *ERC721MetadataSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.SafeTransferFrom(&_ERC721Metadata.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Metadata *ERC721MetadataTransactorSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.SafeTransferFrom(&_ERC721Metadata.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Metadata *ERC721MetadataTransactor) SafeTransferFrom0(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Metadata.contract.Transact(opts, "safeTransferFrom0", _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Metadata *ERC721MetadataSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.SafeTransferFrom0(&_ERC721Metadata.TransactOpts, _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Metadata *ERC721MetadataTransactorSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.SafeTransferFrom0(&_ERC721Metadata.TransactOpts, _from, _to, _tokenId, _data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _operator, bool _approved) returns()
func (_ERC721Metadata *ERC721MetadataTransactor) SetApprovalForAll(opts *bind.TransactOpts, _operator common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Metadata.contract.Transact(opts, "setApprovalForAll", _operator, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _operator, bool _approved) returns()
func (_ERC721Metadata *ERC721MetadataSession) SetApprovalForAll(_operator common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.SetApprovalForAll(&_ERC721Metadata.TransactOpts, _operator, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _operator, bool _approved) returns()
func (_ERC721Metadata *ERC721MetadataTransactorSession) SetApprovalForAll(_operator common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.SetApprovalForAll(&_ERC721Metadata.TransactOpts, _operator, _approved)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Metadata *ERC721MetadataTransactor) TransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Metadata.contract.Transact(opts, "transferFrom", _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Metadata *ERC721MetadataSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.TransferFrom(&_ERC721Metadata.TransactOpts, _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Metadata *ERC721MetadataTransactorSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Metadata.Contract.TransferFrom(&_ERC721Metadata.TransactOpts, _from, _to, _tokenId)
}

// ERC721MetadataApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC721Metadata contract.
type ERC721MetadataApprovalIterator struct {
	Event *ERC721MetadataApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721MetadataApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721MetadataApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721MetadataApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721MetadataApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721MetadataApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721MetadataApproval represents a Approval event raised by the ERC721Metadata contract.
type ERC721MetadataApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Metadata *ERC721MetadataFilterer) FilterApproval(opts *bind.FilterOpts, _owner []common.Address, _approved []common.Address) (*ERC721MetadataApprovalIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721Metadata.contract.FilterLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return &ERC721MetadataApprovalIterator{contract: _ERC721Metadata.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Metadata *ERC721MetadataFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC721MetadataApproval, _owner []common.Address, _approved []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721Metadata.contract.WatchLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721MetadataApproval)
				if err := _ERC721Metadata.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Metadata *ERC721MetadataFilterer) ParseApproval(log types.Log) (*ERC721MetadataApproval, error) {
	event := new(ERC721MetadataApproval)
	if err := _ERC721Metadata.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721MetadataApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ERC721Metadata contract.
type ERC721MetadataApprovalForAllIterator struct {
	Event *ERC721MetadataApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721MetadataApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721MetadataApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721MetadataApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721MetadataApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721MetadataApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721MetadataApprovalForAll represents a ApprovalForAll event raised by the ERC721Metadata contract.
type ERC721MetadataApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Metadata *ERC721MetadataFilterer) FilterApprovalForAll(opts *bind.FilterOpts, _owner []common.Address, _operator []common.Address) (*ERC721MetadataApprovalForAllIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721Metadata.contract.FilterLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return &ERC721MetadataApprovalForAllIterator{contract: _ERC721Metadata.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Metadata *ERC721MetadataFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ERC721MetadataApprovalForAll, _owner []common.Address, _operator []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721Metadata.contract.WatchLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721MetadataApprovalForAll)
				if err := _ERC721Metadata.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Metadata *ERC721MetadataFilterer) ParseApprovalForAll(log types.Log) (*ERC721MetadataApprovalForAll, error) {
	event := new(ERC721MetadataApprovalForAll)
	if err := _ERC721Metadata.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721MetadataTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC721Metadata contract.
type ERC721MetadataTransferIterator struct {
	Event *ERC721MetadataTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721MetadataTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721MetadataTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721MetadataTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721MetadataTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721MetadataTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721MetadataTransfer represents a Transfer event raised by the ERC721Metadata contract.
type ERC721MetadataTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Metadata *ERC721MetadataFilterer) FilterTransfer(opts *bind.FilterOpts, _from []common.Address, _to []common.Address) (*ERC721MetadataTransferIterator, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721Metadata.contract.FilterLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return &ERC721MetadataTransferIterator{contract: _ERC721Metadata.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Metadata *ERC721MetadataFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC721MetadataTransfer, _from []common.Address, _to []common.Address) (event.Subscription, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721Metadata.contract.WatchLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721MetadataTransfer)
				if err := _ERC721Metadata.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Metadata *ERC721MetadataFilterer) ParseTransfer(log types.Log) (*ERC721MetadataTransfer, error) {
	event := new(ERC721MetadataTransfer)
	if err := _ERC721Metadata.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721ReceiverABI is the input ABI used to generate the binding from.
const ERC721ReceiverABI = "[{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ERC721ReceiverFuncSigs maps the 4-byte function signature to its string representation.
var ERC721ReceiverFuncSigs = map[string]string{
	"f0b9e5ba": "onERC721Received(address,uint256,bytes)",
}

// ERC721Receiver is an auto generated Go binding around an Ethereum contract.
type ERC721Receiver struct {
	ERC721ReceiverCaller     // Read-only binding to the contract
	ERC721ReceiverTransactor // Write-only binding to the contract
	ERC721ReceiverFilterer   // Log filterer for contract events
}

// ERC721ReceiverCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC721ReceiverCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721ReceiverTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC721ReceiverTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721ReceiverFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC721ReceiverFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721ReceiverSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC721ReceiverSession struct {
	Contract     *ERC721Receiver   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721ReceiverCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC721ReceiverCallerSession struct {
	Contract *ERC721ReceiverCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// ERC721ReceiverTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC721ReceiverTransactorSession struct {
	Contract     *ERC721ReceiverTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// ERC721ReceiverRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC721ReceiverRaw struct {
	Contract *ERC721Receiver // Generic contract binding to access the raw methods on
}

// ERC721ReceiverCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC721ReceiverCallerRaw struct {
	Contract *ERC721ReceiverCaller // Generic read-only contract binding to access the raw methods on
}

// ERC721ReceiverTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC721ReceiverTransactorRaw struct {
	Contract *ERC721ReceiverTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC721Receiver creates a new instance of ERC721Receiver, bound to a specific deployed contract.
func NewERC721Receiver(address common.Address, backend bind.ContractBackend) (*ERC721Receiver, error) {
	contract, err := bindERC721Receiver(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC721Receiver{ERC721ReceiverCaller: ERC721ReceiverCaller{contract: contract}, ERC721ReceiverTransactor: ERC721ReceiverTransactor{contract: contract}, ERC721ReceiverFilterer: ERC721ReceiverFilterer{contract: contract}}, nil
}

// NewERC721ReceiverCaller creates a new read-only instance of ERC721Receiver, bound to a specific deployed contract.
func NewERC721ReceiverCaller(address common.Address, caller bind.ContractCaller) (*ERC721ReceiverCaller, error) {
	contract, err := bindERC721Receiver(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721ReceiverCaller{contract: contract}, nil
}

// NewERC721ReceiverTransactor creates a new write-only instance of ERC721Receiver, bound to a specific deployed contract.
func NewERC721ReceiverTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC721ReceiverTransactor, error) {
	contract, err := bindERC721Receiver(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721ReceiverTransactor{contract: contract}, nil
}

// NewERC721ReceiverFilterer creates a new log filterer instance of ERC721Receiver, bound to a specific deployed contract.
func NewERC721ReceiverFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC721ReceiverFilterer, error) {
	contract, err := bindERC721Receiver(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC721ReceiverFilterer{contract: contract}, nil
}

// bindERC721Receiver binds a generic wrapper to an already deployed contract.
func bindERC721Receiver(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721ReceiverABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Receiver *ERC721ReceiverRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Receiver.Contract.ERC721ReceiverCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Receiver *ERC721ReceiverRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Receiver.Contract.ERC721ReceiverTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Receiver *ERC721ReceiverRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Receiver.Contract.ERC721ReceiverTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Receiver *ERC721ReceiverCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Receiver.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Receiver *ERC721ReceiverTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Receiver.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Receiver *ERC721ReceiverTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Receiver.Contract.contract.Transact(opts, method, params...)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xf0b9e5ba.
//
// Solidity: function onERC721Received(address _from, uint256 _tokenId, bytes _data) returns(bytes4)
func (_ERC721Receiver *ERC721ReceiverTransactor) OnERC721Received(opts *bind.TransactOpts, _from common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Receiver.contract.Transact(opts, "onERC721Received", _from, _tokenId, _data)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xf0b9e5ba.
//
// Solidity: function onERC721Received(address _from, uint256 _tokenId, bytes _data) returns(bytes4)
func (_ERC721Receiver *ERC721ReceiverSession) OnERC721Received(_from common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Receiver.Contract.OnERC721Received(&_ERC721Receiver.TransactOpts, _from, _tokenId, _data)
}

// OnERC721Received is a paid mutator transaction binding the contract method 0xf0b9e5ba.
//
// Solidity: function onERC721Received(address _from, uint256 _tokenId, bytes _data) returns(bytes4)
func (_ERC721Receiver *ERC721ReceiverTransactorSession) OnERC721Received(_from common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Receiver.Contract.OnERC721Received(&_ERC721Receiver.TransactOpts, _from, _tokenId, _data)
}

// ERC721SafeABI is the input ABI used to generate the binding from.
const ERC721SafeABI = "[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]"

// ERC721SafeFuncSigs maps the 4-byte function signature to its string representation.
var ERC721SafeFuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"4f558e79": "exists(uint256)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"06fdde03": "name()",
	"6352211e": "ownerOf(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"01ffc9a7": "supportsInterface(bytes4)",
	"95d89b41": "symbol()",
	"4f6ccce7": "tokenByIndex(uint256)",
	"2f745c59": "tokenOfOwnerByIndex(address,uint256)",
	"c87b56dd": "tokenURI(uint256)",
	"18160ddd": "totalSupply()",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// ERC721Safe is an auto generated Go binding around an Ethereum contract.
type ERC721Safe struct {
	ERC721SafeCaller     // Read-only binding to the contract
	ERC721SafeTransactor // Write-only binding to the contract
	ERC721SafeFilterer   // Log filterer for contract events
}

// ERC721SafeCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC721SafeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721SafeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC721SafeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721SafeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC721SafeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721SafeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC721SafeSession struct {
	Contract     *ERC721Safe       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721SafeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC721SafeCallerSession struct {
	Contract *ERC721SafeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// ERC721SafeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC721SafeTransactorSession struct {
	Contract     *ERC721SafeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// ERC721SafeRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC721SafeRaw struct {
	Contract *ERC721Safe // Generic contract binding to access the raw methods on
}

// ERC721SafeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC721SafeCallerRaw struct {
	Contract *ERC721SafeCaller // Generic read-only contract binding to access the raw methods on
}

// ERC721SafeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC721SafeTransactorRaw struct {
	Contract *ERC721SafeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC721Safe creates a new instance of ERC721Safe, bound to a specific deployed contract.
func NewERC721Safe(address common.Address, backend bind.ContractBackend) (*ERC721Safe, error) {
	contract, err := bindERC721Safe(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC721Safe{ERC721SafeCaller: ERC721SafeCaller{contract: contract}, ERC721SafeTransactor: ERC721SafeTransactor{contract: contract}, ERC721SafeFilterer: ERC721SafeFilterer{contract: contract}}, nil
}

// NewERC721SafeCaller creates a new read-only instance of ERC721Safe, bound to a specific deployed contract.
func NewERC721SafeCaller(address common.Address, caller bind.ContractCaller) (*ERC721SafeCaller, error) {
	contract, err := bindERC721Safe(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721SafeCaller{contract: contract}, nil
}

// NewERC721SafeTransactor creates a new write-only instance of ERC721Safe, bound to a specific deployed contract.
func NewERC721SafeTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC721SafeTransactor, error) {
	contract, err := bindERC721Safe(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721SafeTransactor{contract: contract}, nil
}

// NewERC721SafeFilterer creates a new log filterer instance of ERC721Safe, bound to a specific deployed contract.
func NewERC721SafeFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC721SafeFilterer, error) {
	contract, err := bindERC721Safe(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC721SafeFilterer{contract: contract}, nil
}

// bindERC721Safe binds a generic wrapper to an already deployed contract.
func bindERC721Safe(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721SafeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Safe *ERC721SafeRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Safe.Contract.ERC721SafeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Safe *ERC721SafeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Safe.Contract.ERC721SafeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Safe *ERC721SafeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Safe.Contract.ERC721SafeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Safe *ERC721SafeCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Safe.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Safe *ERC721SafeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Safe.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Safe *ERC721SafeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Safe.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_ERC721Safe *ERC721SafeCaller) BalanceOf(opts *bind.CallOpts, _owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Safe.contract.Call(opts, out, "balanceOf", _owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_ERC721Safe *ERC721SafeSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721Safe.Contract.BalanceOf(&_ERC721Safe.CallOpts, _owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_ERC721Safe *ERC721SafeCallerSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721Safe.Contract.BalanceOf(&_ERC721Safe.CallOpts, _owner)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_ERC721Safe *ERC721SafeCaller) Exists(opts *bind.CallOpts, _tokenId *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Safe.contract.Call(opts, out, "exists", _tokenId)
	return *ret0, err
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_ERC721Safe *ERC721SafeSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721Safe.Contract.Exists(&_ERC721Safe.CallOpts, _tokenId)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_ERC721Safe *ERC721SafeCallerSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721Safe.Contract.Exists(&_ERC721Safe.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_ERC721Safe *ERC721SafeCaller) GetApproved(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721Safe.contract.Call(opts, out, "getApproved", _tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_ERC721Safe *ERC721SafeSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Safe.Contract.GetApproved(&_ERC721Safe.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_ERC721Safe *ERC721SafeCallerSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Safe.Contract.GetApproved(&_ERC721Safe.CallOpts, _tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Safe *ERC721SafeCaller) IsApprovedForAll(opts *bind.CallOpts, _owner common.Address, _operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Safe.contract.Call(opts, out, "isApprovedForAll", _owner, _operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Safe *ERC721SafeSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721Safe.Contract.IsApprovedForAll(&_ERC721Safe.CallOpts, _owner, _operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Safe *ERC721SafeCallerSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721Safe.Contract.IsApprovedForAll(&_ERC721Safe.CallOpts, _owner, _operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_ERC721Safe *ERC721SafeCaller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721Safe.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_ERC721Safe *ERC721SafeSession) Name() (string, error) {
	return _ERC721Safe.Contract.Name(&_ERC721Safe.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_ERC721Safe *ERC721SafeCallerSession) Name() (string, error) {
	return _ERC721Safe.Contract.Name(&_ERC721Safe.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_ERC721Safe *ERC721SafeCaller) OwnerOf(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721Safe.contract.Call(opts, out, "ownerOf", _tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_ERC721Safe *ERC721SafeSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Safe.Contract.OwnerOf(&_ERC721Safe.CallOpts, _tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_ERC721Safe *ERC721SafeCallerSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Safe.Contract.OwnerOf(&_ERC721Safe.CallOpts, _tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 _interfaceID) constant returns(bool)
func (_ERC721Safe *ERC721SafeCaller) SupportsInterface(opts *bind.CallOpts, _interfaceID [4]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Safe.contract.Call(opts, out, "supportsInterface", _interfaceID)
	return *ret0, err
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 _interfaceID) constant returns(bool)
func (_ERC721Safe *ERC721SafeSession) SupportsInterface(_interfaceID [4]byte) (bool, error) {
	return _ERC721Safe.Contract.SupportsInterface(&_ERC721Safe.CallOpts, _interfaceID)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 _interfaceID) constant returns(bool)
func (_ERC721Safe *ERC721SafeCallerSession) SupportsInterface(_interfaceID [4]byte) (bool, error) {
	return _ERC721Safe.Contract.SupportsInterface(&_ERC721Safe.CallOpts, _interfaceID)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_ERC721Safe *ERC721SafeCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721Safe.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_ERC721Safe *ERC721SafeSession) Symbol() (string, error) {
	return _ERC721Safe.Contract.Symbol(&_ERC721Safe.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_ERC721Safe *ERC721SafeCallerSession) Symbol() (string, error) {
	return _ERC721Safe.Contract.Symbol(&_ERC721Safe.CallOpts)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_ERC721Safe *ERC721SafeCaller) TokenByIndex(opts *bind.CallOpts, _index *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Safe.contract.Call(opts, out, "tokenByIndex", _index)
	return *ret0, err
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_ERC721Safe *ERC721SafeSession) TokenByIndex(_index *big.Int) (*big.Int, error) {
	return _ERC721Safe.Contract.TokenByIndex(&_ERC721Safe.CallOpts, _index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_ERC721Safe *ERC721SafeCallerSession) TokenByIndex(_index *big.Int) (*big.Int, error) {
	return _ERC721Safe.Contract.TokenByIndex(&_ERC721Safe.CallOpts, _index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256)
func (_ERC721Safe *ERC721SafeCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, _owner common.Address, _index *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Safe.contract.Call(opts, out, "tokenOfOwnerByIndex", _owner, _index)
	return *ret0, err
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256)
func (_ERC721Safe *ERC721SafeSession) TokenOfOwnerByIndex(_owner common.Address, _index *big.Int) (*big.Int, error) {
	return _ERC721Safe.Contract.TokenOfOwnerByIndex(&_ERC721Safe.CallOpts, _owner, _index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256)
func (_ERC721Safe *ERC721SafeCallerSession) TokenOfOwnerByIndex(_owner common.Address, _index *big.Int) (*big.Int, error) {
	return _ERC721Safe.Contract.TokenOfOwnerByIndex(&_ERC721Safe.CallOpts, _owner, _index)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_ERC721Safe *ERC721SafeCaller) TokenURI(opts *bind.CallOpts, _tokenId *big.Int) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721Safe.contract.Call(opts, out, "tokenURI", _tokenId)
	return *ret0, err
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_ERC721Safe *ERC721SafeSession) TokenURI(_tokenId *big.Int) (string, error) {
	return _ERC721Safe.Contract.TokenURI(&_ERC721Safe.CallOpts, _tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_ERC721Safe *ERC721SafeCallerSession) TokenURI(_tokenId *big.Int) (string, error) {
	return _ERC721Safe.Contract.TokenURI(&_ERC721Safe.CallOpts, _tokenId)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC721Safe *ERC721SafeCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Safe.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC721Safe *ERC721SafeSession) TotalSupply() (*big.Int, error) {
	return _ERC721Safe.Contract.TotalSupply(&_ERC721Safe.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC721Safe *ERC721SafeCallerSession) TotalSupply() (*big.Int, error) {
	return _ERC721Safe.Contract.TotalSupply(&_ERC721Safe.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Safe *ERC721SafeTransactor) Approve(opts *bind.TransactOpts, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Safe.contract.Transact(opts, "approve", _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Safe *ERC721SafeSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Safe.Contract.Approve(&_ERC721Safe.TransactOpts, _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Safe *ERC721SafeTransactorSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Safe.Contract.Approve(&_ERC721Safe.TransactOpts, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Safe *ERC721SafeTransactor) SafeTransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Safe.contract.Transact(opts, "safeTransferFrom", _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Safe *ERC721SafeSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Safe.Contract.SafeTransferFrom(&_ERC721Safe.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Safe *ERC721SafeTransactorSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Safe.Contract.SafeTransferFrom(&_ERC721Safe.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Safe *ERC721SafeTransactor) SafeTransferFrom0(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Safe.contract.Transact(opts, "safeTransferFrom0", _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Safe *ERC721SafeSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Safe.Contract.SafeTransferFrom0(&_ERC721Safe.TransactOpts, _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Safe *ERC721SafeTransactorSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Safe.Contract.SafeTransferFrom0(&_ERC721Safe.TransactOpts, _from, _to, _tokenId, _data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_ERC721Safe *ERC721SafeTransactor) SetApprovalForAll(opts *bind.TransactOpts, _to common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Safe.contract.Transact(opts, "setApprovalForAll", _to, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_ERC721Safe *ERC721SafeSession) SetApprovalForAll(_to common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Safe.Contract.SetApprovalForAll(&_ERC721Safe.TransactOpts, _to, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_ERC721Safe *ERC721SafeTransactorSession) SetApprovalForAll(_to common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Safe.Contract.SetApprovalForAll(&_ERC721Safe.TransactOpts, _to, _approved)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Safe *ERC721SafeTransactor) TransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Safe.contract.Transact(opts, "transferFrom", _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Safe *ERC721SafeSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Safe.Contract.TransferFrom(&_ERC721Safe.TransactOpts, _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Safe *ERC721SafeTransactorSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Safe.Contract.TransferFrom(&_ERC721Safe.TransactOpts, _from, _to, _tokenId)
}

// ERC721SafeApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC721Safe contract.
type ERC721SafeApprovalIterator struct {
	Event *ERC721SafeApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721SafeApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721SafeApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721SafeApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721SafeApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721SafeApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721SafeApproval represents a Approval event raised by the ERC721Safe contract.
type ERC721SafeApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Safe *ERC721SafeFilterer) FilterApproval(opts *bind.FilterOpts, _owner []common.Address, _approved []common.Address) (*ERC721SafeApprovalIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721Safe.contract.FilterLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return &ERC721SafeApprovalIterator{contract: _ERC721Safe.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Safe *ERC721SafeFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC721SafeApproval, _owner []common.Address, _approved []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721Safe.contract.WatchLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721SafeApproval)
				if err := _ERC721Safe.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Safe *ERC721SafeFilterer) ParseApproval(log types.Log) (*ERC721SafeApproval, error) {
	event := new(ERC721SafeApproval)
	if err := _ERC721Safe.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721SafeApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ERC721Safe contract.
type ERC721SafeApprovalForAllIterator struct {
	Event *ERC721SafeApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721SafeApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721SafeApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721SafeApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721SafeApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721SafeApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721SafeApprovalForAll represents a ApprovalForAll event raised by the ERC721Safe contract.
type ERC721SafeApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Safe *ERC721SafeFilterer) FilterApprovalForAll(opts *bind.FilterOpts, _owner []common.Address, _operator []common.Address) (*ERC721SafeApprovalForAllIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721Safe.contract.FilterLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return &ERC721SafeApprovalForAllIterator{contract: _ERC721Safe.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Safe *ERC721SafeFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ERC721SafeApprovalForAll, _owner []common.Address, _operator []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721Safe.contract.WatchLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721SafeApprovalForAll)
				if err := _ERC721Safe.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Safe *ERC721SafeFilterer) ParseApprovalForAll(log types.Log) (*ERC721SafeApprovalForAll, error) {
	event := new(ERC721SafeApprovalForAll)
	if err := _ERC721Safe.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721SafeTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC721Safe contract.
type ERC721SafeTransferIterator struct {
	Event *ERC721SafeTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721SafeTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721SafeTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721SafeTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721SafeTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721SafeTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721SafeTransfer represents a Transfer event raised by the ERC721Safe contract.
type ERC721SafeTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Safe *ERC721SafeFilterer) FilterTransfer(opts *bind.FilterOpts, _from []common.Address, _to []common.Address) (*ERC721SafeTransferIterator, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721Safe.contract.FilterLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return &ERC721SafeTransferIterator{contract: _ERC721Safe.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Safe *ERC721SafeFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC721SafeTransfer, _from []common.Address, _to []common.Address) (event.Subscription, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721Safe.contract.WatchLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721SafeTransfer)
				if err := _ERC721Safe.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Safe *ERC721SafeFilterer) ParseTransfer(log types.Log) (*ERC721SafeTransfer, error) {
	event := new(ERC721SafeTransfer)
	if err := _ERC721Safe.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721TokenABI is the input ABI used to generate the binding from.
const ERC721TokenABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]"

// ERC721TokenFuncSigs maps the 4-byte function signature to its string representation.
var ERC721TokenFuncSigs = map[string]string{
	"095ea7b3": "approve(address,uint256)",
	"70a08231": "balanceOf(address)",
	"4f558e79": "exists(uint256)",
	"081812fc": "getApproved(uint256)",
	"e985e9c5": "isApprovedForAll(address,address)",
	"06fdde03": "name()",
	"6352211e": "ownerOf(uint256)",
	"42842e0e": "safeTransferFrom(address,address,uint256)",
	"b88d4fde": "safeTransferFrom(address,address,uint256,bytes)",
	"a22cb465": "setApprovalForAll(address,bool)",
	"95d89b41": "symbol()",
	"4f6ccce7": "tokenByIndex(uint256)",
	"2f745c59": "tokenOfOwnerByIndex(address,uint256)",
	"c87b56dd": "tokenURI(uint256)",
	"18160ddd": "totalSupply()",
	"23b872dd": "transferFrom(address,address,uint256)",
}

// ERC721TokenBin is the compiled bytecode used for deploying new contracts.
var ERC721TokenBin = "0x60806040523480156200001157600080fd5b5060405162001054380380620010548339810160405280516020808301519183018051909392909201916200004d91600491908501906200006c565b508051620000639060059060208401906200006c565b50505062000111565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10620000af57805160ff1916838001178555620000df565b82800160010185558215620000df579182015b82811115620000df578251825591602001919060010190620000c2565b50620000ed929150620000f1565b5090565b6200010e91905b80821115620000ed5760008155600101620000f8565b90565b610f3380620001216000396000f3006080604052600436106100e55763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166306fdde0381146100ea578063081812fc14610174578063095ea7b3146101a857806318160ddd146101ce57806323b872dd146101f55780632f745c591461021f57806342842e0e146102435780634f558e791461026d5780634f6ccce7146102995780636352211e146102b157806370a08231146102c957806395d89b41146102ea578063a22cb465146102ff578063b88d4fde14610325578063c87b56dd14610394578063e985e9c5146103ac575b600080fd5b3480156100f657600080fd5b506100ff6103d3565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610139578181015183820152602001610121565b50505050905090810190601f1680156101665780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561018057600080fd5b5061018c60043561046a565b60408051600160a060020a039092168252519081900360200190f35b3480156101b457600080fd5b506101cc600160a060020a0360043516602435610485565b005b3480156101da57600080fd5b506101e3610577565b60408051918252519081900360200190f35b34801561020157600080fd5b506101cc600160a060020a036004358116906024351660443561057d565b34801561022b57600080fd5b506101e3600160a060020a036004351660243561062c565b34801561024f57600080fd5b506101cc600160a060020a0360043581169060243516604435610679565b34801561027957600080fd5b506102856004356106b1565b604080519115158252519081900360200190f35b3480156102a557600080fd5b506101e36004356106ce565b3480156102bd57600080fd5b5061018c600435610703565b3480156102d557600080fd5b506101e3600160a060020a036004351661072d565b3480156102f657600080fd5b506100ff610760565b34801561030b57600080fd5b506101cc600160a060020a036004351660243515156107c1565b34801561033157600080fd5b50604080516020601f6064356004818101359283018490048402850184019095528184526101cc94600160a060020a0381358116956024803590921695604435953695608494019181908401838280828437509497506108459650505050505050565b3480156103a057600080fd5b506100ff600435610884565b3480156103b857600080fd5b50610285600160a060020a0360043581169060243516610939565b60048054604080516020601f600260001961010060018816150201909516949094049384018190048102820181019092528281526060939092909183018282801561045f5780601f106104345761010080835404028352916020019161045f565b820191906000526020600020905b81548152906001019060200180831161044257829003601f168201915b505050505090505b90565b600090815260016020526040902054600160a060020a031690565b600061049082610703565b9050600160a060020a0383811690821614156104ab57600080fd5b33600160a060020a03821614806104c757506104c78133610939565b15156104d257600080fd5b60006104dd8361046a565b600160a060020a03161415806104fb5750600160a060020a03831615155b1561057257600082815260016020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03878116918217909255835186815293519093918516927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a35b505050565b60085490565b806105883382610967565b151561059357600080fd5b600160a060020a03841615156105a857600080fd5b600160a060020a03831615156105bd57600080fd5b6105c784836109c6565b6105d18483610a74565b6105db8383610bad565b82600160a060020a031684600160a060020a03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a350505050565b60006106378361072d565b821061064257600080fd5b600160a060020a038316600090815260066020526040902080548390811061066657fe5b9060005260206000200154905092915050565b806106843382610967565b151561068f57600080fd5b6106ab8484846020604051908101604052806000815250610845565b50505050565b600090815260208190526040902054600160a060020a0316151590565b60006106d8610577565b82106106e357600080fd5b60088054839081106106f157fe5b90600052602060002001549050919050565b600081815260208190526040812054600160a060020a031680151561072757600080fd5b92915050565b6000600160a060020a038216151561074457600080fd5b50600160a060020a031660009081526002602052604090205490565b60058054604080516020601f600260001961010060018816150201909516949094049384018190048102820181019092528281526060939092909183018282801561045f5780601f106104345761010080835404028352916020019161045f565b600160a060020a0382163314156107d757600080fd5b336000818152600360209081526040808320600160a060020a03871680855290835292819020805460ff1916861515908117909155815190815290519293927f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31929181900390910190a35050565b816108503382610967565b151561085b57600080fd5b61086685858561057d565b61087285858585610bf6565b151561087d57600080fd5b5050505050565b606061088f826106b1565b151561089a57600080fd5b6000828152600a602090815260409182902080548351601f60026000196101006001861615020190931692909204918201849004840281018401909452808452909183018282801561092d5780601f106109025761010080835404028352916020019161092d565b820191906000526020600020905b81548152906001019060200180831161091057829003601f168201915b50505050509050919050565b600160a060020a03918216600090815260036020908152604080832093909416825291909152205460ff1690565b60008061097383610703565b905080600160a060020a031684600160a060020a031614806109ae575083600160a060020a03166109a38461046a565b600160a060020a0316145b806109be57506109be8185610939565b949350505050565b81600160a060020a03166109d982610703565b600160a060020a0316146109ec57600080fd5b600081815260016020526040902054600160a060020a031615610a70576000818152600160209081526040808320805473ffffffffffffffffffffffffffffffffffffffff1916905580518481529051600160a060020a038616927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a35b5050565b6000806000610a838585610d7f565b600084815260076020908152604080832054600160a060020a0389168452600690925290912054909350610abe90600163ffffffff610e1416565b600160a060020a038616600090815260066020526040902080549193509083908110610ae657fe5b90600052602060002001549050806006600087600160a060020a0316600160a060020a0316815260200190815260200160002084815481101515610b2657fe5b6000918252602080832090910192909255600160a060020a0387168152600690915260408120805484908110610b5857fe5b6000918252602080832090910192909255600160a060020a0387168152600690915260409020805490610b8f906000198301610eca565b50600093845260076020526040808520859055908452909220555050565b6000610bb98383610e26565b50600160a060020a039091166000908152600660209081526040808320805460018101825590845282842081018590559383526007909152902055565b600080610c0b85600160a060020a0316610eb5565b1515610c1a5760019150610d76565b84600160a060020a031663f0b9e5ba8786866040518463ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018084600160a060020a0316600160a060020a0316815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b83811015610cb2578181015183820152602001610c9a565b50505050905090810190601f168015610cdf5780820380516001836020036101000a031916815260200191505b50945050505050602060405180830381600087803b158015610d0057600080fd5b505af1158015610d14573d6000803e3d6000fd5b505050506040513d6020811015610d2a57600080fd5b50517fffffffff0000000000000000000000000000000000000000000000000000000081167ff0b9e5ba0000000000000000000000000000000000000000000000000000000014925090505b50949350505050565b81600160a060020a0316610d9282610703565b600160a060020a031614610da557600080fd5b600160a060020a038216600090815260026020526040902054610dcf90600163ffffffff610e1416565b600160a060020a039092166000908152600260209081526040808320949094559181529081905220805473ffffffffffffffffffffffffffffffffffffffff19169055565b600082821115610e2057fe5b50900390565b600081815260208190526040902054600160a060020a031615610e4857600080fd5b600081815260208181526040808320805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03871690811790915583526002909152902054610e95906001610ebd565b600160a060020a0390921660009081526002602052604090209190915550565b6000903b1190565b8181018281101561072757fe5b8154818355818111156105725760008381526020902061057291810190830161046791905b80821115610f035760008155600101610eef565b50905600a165627a7a72305820f2f5e8f53efb0128c4a461774f2054807dfd5078a5d4b5f49f5ae34909413d4a0029"

// DeployERC721Token deploys a new Ethereum contract, binding an instance of ERC721Token to it.
func DeployERC721Token(auth *bind.TransactOpts, backend bind.ContractBackend, _name string, _symbol string) (common.Address, *types.Transaction, *ERC721Token, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721TokenABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ERC721TokenBin), backend, _name, _symbol)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC721Token{ERC721TokenCaller: ERC721TokenCaller{contract: contract}, ERC721TokenTransactor: ERC721TokenTransactor{contract: contract}, ERC721TokenFilterer: ERC721TokenFilterer{contract: contract}}, nil
}

// ERC721Token is an auto generated Go binding around an Ethereum contract.
type ERC721Token struct {
	ERC721TokenCaller     // Read-only binding to the contract
	ERC721TokenTransactor // Write-only binding to the contract
	ERC721TokenFilterer   // Log filterer for contract events
}

// ERC721TokenCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC721TokenCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721TokenTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC721TokenTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721TokenFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC721TokenFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC721TokenSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC721TokenSession struct {
	Contract     *ERC721Token      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC721TokenCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC721TokenCallerSession struct {
	Contract *ERC721TokenCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// ERC721TokenTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC721TokenTransactorSession struct {
	Contract     *ERC721TokenTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// ERC721TokenRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC721TokenRaw struct {
	Contract *ERC721Token // Generic contract binding to access the raw methods on
}

// ERC721TokenCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC721TokenCallerRaw struct {
	Contract *ERC721TokenCaller // Generic read-only contract binding to access the raw methods on
}

// ERC721TokenTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC721TokenTransactorRaw struct {
	Contract *ERC721TokenTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC721Token creates a new instance of ERC721Token, bound to a specific deployed contract.
func NewERC721Token(address common.Address, backend bind.ContractBackend) (*ERC721Token, error) {
	contract, err := bindERC721Token(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC721Token{ERC721TokenCaller: ERC721TokenCaller{contract: contract}, ERC721TokenTransactor: ERC721TokenTransactor{contract: contract}, ERC721TokenFilterer: ERC721TokenFilterer{contract: contract}}, nil
}

// NewERC721TokenCaller creates a new read-only instance of ERC721Token, bound to a specific deployed contract.
func NewERC721TokenCaller(address common.Address, caller bind.ContractCaller) (*ERC721TokenCaller, error) {
	contract, err := bindERC721Token(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721TokenCaller{contract: contract}, nil
}

// NewERC721TokenTransactor creates a new write-only instance of ERC721Token, bound to a specific deployed contract.
func NewERC721TokenTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC721TokenTransactor, error) {
	contract, err := bindERC721Token(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC721TokenTransactor{contract: contract}, nil
}

// NewERC721TokenFilterer creates a new log filterer instance of ERC721Token, bound to a specific deployed contract.
func NewERC721TokenFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC721TokenFilterer, error) {
	contract, err := bindERC721Token(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC721TokenFilterer{contract: contract}, nil
}

// bindERC721Token binds a generic wrapper to an already deployed contract.
func bindERC721Token(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC721TokenABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Token *ERC721TokenRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Token.Contract.ERC721TokenCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Token *ERC721TokenRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Token.Contract.ERC721TokenTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Token *ERC721TokenRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Token.Contract.ERC721TokenTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC721Token *ERC721TokenCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC721Token.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC721Token *ERC721TokenTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC721Token.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC721Token *ERC721TokenTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC721Token.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_ERC721Token *ERC721TokenCaller) BalanceOf(opts *bind.CallOpts, _owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Token.contract.Call(opts, out, "balanceOf", _owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_ERC721Token *ERC721TokenSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721Token.Contract.BalanceOf(&_ERC721Token.CallOpts, _owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256)
func (_ERC721Token *ERC721TokenCallerSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _ERC721Token.Contract.BalanceOf(&_ERC721Token.CallOpts, _owner)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_ERC721Token *ERC721TokenCaller) Exists(opts *bind.CallOpts, _tokenId *big.Int) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Token.contract.Call(opts, out, "exists", _tokenId)
	return *ret0, err
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_ERC721Token *ERC721TokenSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721Token.Contract.Exists(&_ERC721Token.CallOpts, _tokenId)
}

// Exists is a free data retrieval call binding the contract method 0x4f558e79.
//
// Solidity: function exists(uint256 _tokenId) constant returns(bool)
func (_ERC721Token *ERC721TokenCallerSession) Exists(_tokenId *big.Int) (bool, error) {
	return _ERC721Token.Contract.Exists(&_ERC721Token.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_ERC721Token *ERC721TokenCaller) GetApproved(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721Token.contract.Call(opts, out, "getApproved", _tokenId)
	return *ret0, err
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_ERC721Token *ERC721TokenSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Token.Contract.GetApproved(&_ERC721Token.CallOpts, _tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 _tokenId) constant returns(address)
func (_ERC721Token *ERC721TokenCallerSession) GetApproved(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Token.Contract.GetApproved(&_ERC721Token.CallOpts, _tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Token *ERC721TokenCaller) IsApprovedForAll(opts *bind.CallOpts, _owner common.Address, _operator common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ERC721Token.contract.Call(opts, out, "isApprovedForAll", _owner, _operator)
	return *ret0, err
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Token *ERC721TokenSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721Token.Contract.IsApprovedForAll(&_ERC721Token.CallOpts, _owner, _operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address _owner, address _operator) constant returns(bool)
func (_ERC721Token *ERC721TokenCallerSession) IsApprovedForAll(_owner common.Address, _operator common.Address) (bool, error) {
	return _ERC721Token.Contract.IsApprovedForAll(&_ERC721Token.CallOpts, _owner, _operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_ERC721Token *ERC721TokenCaller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721Token.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_ERC721Token *ERC721TokenSession) Name() (string, error) {
	return _ERC721Token.Contract.Name(&_ERC721Token.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_ERC721Token *ERC721TokenCallerSession) Name() (string, error) {
	return _ERC721Token.Contract.Name(&_ERC721Token.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_ERC721Token *ERC721TokenCaller) OwnerOf(opts *bind.CallOpts, _tokenId *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ERC721Token.contract.Call(opts, out, "ownerOf", _tokenId)
	return *ret0, err
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_ERC721Token *ERC721TokenSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Token.Contract.OwnerOf(&_ERC721Token.CallOpts, _tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 _tokenId) constant returns(address)
func (_ERC721Token *ERC721TokenCallerSession) OwnerOf(_tokenId *big.Int) (common.Address, error) {
	return _ERC721Token.Contract.OwnerOf(&_ERC721Token.CallOpts, _tokenId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_ERC721Token *ERC721TokenCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721Token.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_ERC721Token *ERC721TokenSession) Symbol() (string, error) {
	return _ERC721Token.Contract.Symbol(&_ERC721Token.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_ERC721Token *ERC721TokenCallerSession) Symbol() (string, error) {
	return _ERC721Token.Contract.Symbol(&_ERC721Token.CallOpts)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_ERC721Token *ERC721TokenCaller) TokenByIndex(opts *bind.CallOpts, _index *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Token.contract.Call(opts, out, "tokenByIndex", _index)
	return *ret0, err
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_ERC721Token *ERC721TokenSession) TokenByIndex(_index *big.Int) (*big.Int, error) {
	return _ERC721Token.Contract.TokenByIndex(&_ERC721Token.CallOpts, _index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 _index) constant returns(uint256)
func (_ERC721Token *ERC721TokenCallerSession) TokenByIndex(_index *big.Int) (*big.Int, error) {
	return _ERC721Token.Contract.TokenByIndex(&_ERC721Token.CallOpts, _index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256)
func (_ERC721Token *ERC721TokenCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, _owner common.Address, _index *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Token.contract.Call(opts, out, "tokenOfOwnerByIndex", _owner, _index)
	return *ret0, err
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256)
func (_ERC721Token *ERC721TokenSession) TokenOfOwnerByIndex(_owner common.Address, _index *big.Int) (*big.Int, error) {
	return _ERC721Token.Contract.TokenOfOwnerByIndex(&_ERC721Token.CallOpts, _owner, _index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns(uint256)
func (_ERC721Token *ERC721TokenCallerSession) TokenOfOwnerByIndex(_owner common.Address, _index *big.Int) (*big.Int, error) {
	return _ERC721Token.Contract.TokenOfOwnerByIndex(&_ERC721Token.CallOpts, _owner, _index)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_ERC721Token *ERC721TokenCaller) TokenURI(opts *bind.CallOpts, _tokenId *big.Int) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _ERC721Token.contract.Call(opts, out, "tokenURI", _tokenId)
	return *ret0, err
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_ERC721Token *ERC721TokenSession) TokenURI(_tokenId *big.Int) (string, error) {
	return _ERC721Token.Contract.TokenURI(&_ERC721Token.CallOpts, _tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 _tokenId) constant returns(string)
func (_ERC721Token *ERC721TokenCallerSession) TokenURI(_tokenId *big.Int) (string, error) {
	return _ERC721Token.Contract.TokenURI(&_ERC721Token.CallOpts, _tokenId)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC721Token *ERC721TokenCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC721Token.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC721Token *ERC721TokenSession) TotalSupply() (*big.Int, error) {
	return _ERC721Token.Contract.TotalSupply(&_ERC721Token.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC721Token *ERC721TokenCallerSession) TotalSupply() (*big.Int, error) {
	return _ERC721Token.Contract.TotalSupply(&_ERC721Token.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Token *ERC721TokenTransactor) Approve(opts *bind.TransactOpts, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Token.contract.Transact(opts, "approve", _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Token *ERC721TokenSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Token.Contract.Approve(&_ERC721Token.TransactOpts, _to, _tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _to, uint256 _tokenId) returns()
func (_ERC721Token *ERC721TokenTransactorSession) Approve(_to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Token.Contract.Approve(&_ERC721Token.TransactOpts, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Token *ERC721TokenTransactor) SafeTransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Token.contract.Transact(opts, "safeTransferFrom", _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Token *ERC721TokenSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Token.Contract.SafeTransferFrom(&_ERC721Token.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Token *ERC721TokenTransactorSession) SafeTransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Token.Contract.SafeTransferFrom(&_ERC721Token.TransactOpts, _from, _to, _tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Token *ERC721TokenTransactor) SafeTransferFrom0(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Token.contract.Transact(opts, "safeTransferFrom0", _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Token *ERC721TokenSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Token.Contract.SafeTransferFrom0(&_ERC721Token.TransactOpts, _from, _to, _tokenId, _data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) returns()
func (_ERC721Token *ERC721TokenTransactorSession) SafeTransferFrom0(_from common.Address, _to common.Address, _tokenId *big.Int, _data []byte) (*types.Transaction, error) {
	return _ERC721Token.Contract.SafeTransferFrom0(&_ERC721Token.TransactOpts, _from, _to, _tokenId, _data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_ERC721Token *ERC721TokenTransactor) SetApprovalForAll(opts *bind.TransactOpts, _to common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Token.contract.Transact(opts, "setApprovalForAll", _to, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_ERC721Token *ERC721TokenSession) SetApprovalForAll(_to common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Token.Contract.SetApprovalForAll(&_ERC721Token.TransactOpts, _to, _approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address _to, bool _approved) returns()
func (_ERC721Token *ERC721TokenTransactorSession) SetApprovalForAll(_to common.Address, _approved bool) (*types.Transaction, error) {
	return _ERC721Token.Contract.SetApprovalForAll(&_ERC721Token.TransactOpts, _to, _approved)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Token *ERC721TokenTransactor) TransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Token.contract.Transact(opts, "transferFrom", _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Token *ERC721TokenSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Token.Contract.TransferFrom(&_ERC721Token.TransactOpts, _from, _to, _tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _tokenId) returns()
func (_ERC721Token *ERC721TokenTransactorSession) TransferFrom(_from common.Address, _to common.Address, _tokenId *big.Int) (*types.Transaction, error) {
	return _ERC721Token.Contract.TransferFrom(&_ERC721Token.TransactOpts, _from, _to, _tokenId)
}

// ERC721TokenApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC721Token contract.
type ERC721TokenApprovalIterator struct {
	Event *ERC721TokenApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721TokenApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721TokenApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721TokenApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721TokenApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721TokenApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721TokenApproval represents a Approval event raised by the ERC721Token contract.
type ERC721TokenApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Token *ERC721TokenFilterer) FilterApproval(opts *bind.FilterOpts, _owner []common.Address, _approved []common.Address) (*ERC721TokenApprovalIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721Token.contract.FilterLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return &ERC721TokenApprovalIterator{contract: _ERC721Token.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Token *ERC721TokenFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC721TokenApproval, _owner []common.Address, _approved []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _approvedRule []interface{}
	for _, _approvedItem := range _approved {
		_approvedRule = append(_approvedRule, _approvedItem)
	}

	logs, sub, err := _ERC721Token.contract.WatchLogs(opts, "Approval", _ownerRule, _approvedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721TokenApproval)
				if err := _ERC721Token.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId)
func (_ERC721Token *ERC721TokenFilterer) ParseApproval(log types.Log) (*ERC721TokenApproval, error) {
	event := new(ERC721TokenApproval)
	if err := _ERC721Token.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721TokenApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ERC721Token contract.
type ERC721TokenApprovalForAllIterator struct {
	Event *ERC721TokenApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721TokenApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721TokenApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721TokenApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721TokenApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721TokenApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721TokenApprovalForAll represents a ApprovalForAll event raised by the ERC721Token contract.
type ERC721TokenApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Token *ERC721TokenFilterer) FilterApprovalForAll(opts *bind.FilterOpts, _owner []common.Address, _operator []common.Address) (*ERC721TokenApprovalForAllIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721Token.contract.FilterLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return &ERC721TokenApprovalForAllIterator{contract: _ERC721Token.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Token *ERC721TokenFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ERC721TokenApprovalForAll, _owner []common.Address, _operator []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _operatorRule []interface{}
	for _, _operatorItem := range _operator {
		_operatorRule = append(_operatorRule, _operatorItem)
	}

	logs, sub, err := _ERC721Token.contract.WatchLogs(opts, "ApprovalForAll", _ownerRule, _operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721TokenApprovalForAll)
				if err := _ERC721Token.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)
func (_ERC721Token *ERC721TokenFilterer) ParseApprovalForAll(log types.Log) (*ERC721TokenApprovalForAll, error) {
	event := new(ERC721TokenApprovalForAll)
	if err := _ERC721Token.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ERC721TokenTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC721Token contract.
type ERC721TokenTransferIterator struct {
	Event *ERC721TokenTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC721TokenTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC721TokenTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC721TokenTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC721TokenTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC721TokenTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC721TokenTransfer represents a Transfer event raised by the ERC721Token contract.
type ERC721TokenTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Token *ERC721TokenFilterer) FilterTransfer(opts *bind.FilterOpts, _from []common.Address, _to []common.Address) (*ERC721TokenTransferIterator, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721Token.contract.FilterLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return &ERC721TokenTransferIterator{contract: _ERC721Token.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Token *ERC721TokenFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC721TokenTransfer, _from []common.Address, _to []common.Address) (event.Subscription, error) {

	var _fromRule []interface{}
	for _, _fromItem := range _from {
		_fromRule = append(_fromRule, _fromItem)
	}
	var _toRule []interface{}
	for _, _toItem := range _to {
		_toRule = append(_toRule, _toItem)
	}

	logs, sub, err := _ERC721Token.contract.WatchLogs(opts, "Transfer", _fromRule, _toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC721TokenTransfer)
				if err := _ERC721Token.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed _from, address indexed _to, uint256 _tokenId)
func (_ERC721Token *ERC721TokenFilterer) ParseTransfer(log types.Log) (*ERC721TokenTransfer, error) {
	event := new(ERC721TokenTransfer)
	if err := _ERC721Token.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// HelperUtilsABI is the input ABI used to generate the binding from.
const HelperUtilsABI = "[]"

// HelperUtilsBin is the compiled bytecode used for deploying new contracts.
var HelperUtilsBin = "0x6080604052348015600f57600080fd5b50603580601d6000396000f3006080604052600080fd00a165627a7a72305820b0554bed8b79e2256e0852d0e82d8087248ea77e1746506c826cecf6e20d16c20029"

// DeployHelperUtils deploys a new Ethereum contract, binding an instance of HelperUtils to it.
func DeployHelperUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *HelperUtils, error) {
	parsed, err := abi.JSON(strings.NewReader(HelperUtilsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(HelperUtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &HelperUtils{HelperUtilsCaller: HelperUtilsCaller{contract: contract}, HelperUtilsTransactor: HelperUtilsTransactor{contract: contract}, HelperUtilsFilterer: HelperUtilsFilterer{contract: contract}}, nil
}

// HelperUtils is an auto generated Go binding around an Ethereum contract.
type HelperUtils struct {
	HelperUtilsCaller     // Read-only binding to the contract
	HelperUtilsTransactor // Write-only binding to the contract
	HelperUtilsFilterer   // Log filterer for contract events
}

// HelperUtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type HelperUtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HelperUtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type HelperUtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HelperUtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type HelperUtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HelperUtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type HelperUtilsSession struct {
	Contract     *HelperUtils      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// HelperUtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type HelperUtilsCallerSession struct {
	Contract *HelperUtilsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// HelperUtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type HelperUtilsTransactorSession struct {
	Contract     *HelperUtilsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// HelperUtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type HelperUtilsRaw struct {
	Contract *HelperUtils // Generic contract binding to access the raw methods on
}

// HelperUtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type HelperUtilsCallerRaw struct {
	Contract *HelperUtilsCaller // Generic read-only contract binding to access the raw methods on
}

// HelperUtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type HelperUtilsTransactorRaw struct {
	Contract *HelperUtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewHelperUtils creates a new instance of HelperUtils, bound to a specific deployed contract.
func NewHelperUtils(address common.Address, backend bind.ContractBackend) (*HelperUtils, error) {
	contract, err := bindHelperUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &HelperUtils{HelperUtilsCaller: HelperUtilsCaller{contract: contract}, HelperUtilsTransactor: HelperUtilsTransactor{contract: contract}, HelperUtilsFilterer: HelperUtilsFilterer{contract: contract}}, nil
}

// NewHelperUtilsCaller creates a new read-only instance of HelperUtils, bound to a specific deployed contract.
func NewHelperUtilsCaller(address common.Address, caller bind.ContractCaller) (*HelperUtilsCaller, error) {
	contract, err := bindHelperUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &HelperUtilsCaller{contract: contract}, nil
}

// NewHelperUtilsTransactor creates a new write-only instance of HelperUtils, bound to a specific deployed contract.
func NewHelperUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*HelperUtilsTransactor, error) {
	contract, err := bindHelperUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &HelperUtilsTransactor{contract: contract}, nil
}

// NewHelperUtilsFilterer creates a new log filterer instance of HelperUtils, bound to a specific deployed contract.
func NewHelperUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*HelperUtilsFilterer, error) {
	contract, err := bindHelperUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &HelperUtilsFilterer{contract: contract}, nil
}

// bindHelperUtils binds a generic wrapper to an already deployed contract.
func bindHelperUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(HelperUtilsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_HelperUtils *HelperUtilsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _HelperUtils.Contract.HelperUtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_HelperUtils *HelperUtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _HelperUtils.Contract.HelperUtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_HelperUtils *HelperUtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _HelperUtils.Contract.HelperUtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_HelperUtils *HelperUtilsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _HelperUtils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_HelperUtils *HelperUtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _HelperUtils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_HelperUtils *HelperUtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _HelperUtils.Contract.contract.Transact(opts, method, params...)
}

// MediaStoreVersionControlABI is the input ABI used to generate the binding from.
const MediaStoreVersionControlABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"currentStartingDigitalMediaId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentDigitalMediaStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dmsAddress\",\"type\":\"address\"}],\"name\":\"setV1DigitalMediaStoreAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"v1DigitalMediaStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]"

// MediaStoreVersionControlFuncSigs maps the 4-byte function signature to its string representation.
var MediaStoreVersionControlFuncSigs = map[string]string{
	"1b284e75": "currentDigitalMediaStore()",
	"0154788d": "currentStartingDigitalMediaId()",
	"8da5cb5b": "owner()",
	"8456cb59": "pause()",
	"5c975abb": "paused()",
	"91c60788": "setV1DigitalMediaStoreAddress(address)",
	"f2fde38b": "transferOwnership(address)",
	"3f4ba83a": "unpause()",
	"a0f01e08": "v1DigitalMediaStore()",
}

// MediaStoreVersionControlBin is the compiled bytecode used for deploying new contracts.
var MediaStoreVersionControlBin = "0x608060405260008054600160a860020a03191633179055610611806100256000396000f3006080604052600436106100985763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630154788d811461009d5780631b284e75146100c45780633f4ba83a146100f55780635c975abb1461010c5780638456cb59146101355780638da5cb5b1461014a57806391c607881461015f578063a0f01e0814610180578063f2fde38b14610195575b600080fd5b3480156100a957600080fd5b506100b26101b6565b60408051918252519081900360200190f35b3480156100d057600080fd5b506100d96101bc565b60408051600160a060020a039092168252519081900360200190f35b34801561010157600080fd5b5061010a6101cb565b005b34801561011857600080fd5b50610121610252565b604080519115158252519081900360200190f35b34801561014157600080fd5b5061010a610273565b34801561015657600080fd5b506100d9610310565b34801561016b57600080fd5b5061010a600160a060020a036004351661031f565b34801561018c57600080fd5b506100d9610542565b3480156101a157600080fd5b5061010a600160a060020a0360043516610551565b60035481565b600254600160a060020a031681565b600054600160a060020a031633146101e257600080fd5b60005474010000000000000000000000000000000000000000900460ff16151561020b57600080fd5b6000805474ff0000000000000000000000000000000000000000191681556040517f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b339190a1565b60005474010000000000000000000000000000000000000000900460ff1681565b600054600160a060020a0316331461028a57600080fd5b60005474010000000000000000000000000000000000000000900460ff16156102b257600080fd5b6000805474ff00000000000000000000000000000000000000001916740100000000000000000000000000000000000000001781556040517f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff6259190a1565b600054600160a060020a031681565b60008054600160a060020a0316331461033757600080fd5b600154600160a060020a0316156103af57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f5631206d656469612073746f726520616c7265616479207365742e0000000000604482015290519081900360640190fd5b81905080600160a060020a0316636c669f256040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401602060405180830381600087803b15801561040957600080fd5b505af115801561041d573d6000803e3d6000fd5b505050506040513d602081101561043357600080fd5b50516001146104a357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e636f72726563742076657273696f6e2e0000000000000000000000000000604482015290519081900360640190fd5b6001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038381169190911791829055604080517fa60800b80000000000000000000000000000000000000000000000000000000081529051929091169163a60800b89160048082019260009290919082900301818387803b15801561052657600080fd5b505af115801561053a573d6000803e3d6000fd5b505050505050565b600154600160a060020a031681565b600054600160a060020a0316331461056857600080fd5b600160a060020a038116151561057d57600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790555600a165627a7a723058206cea38459d9dc1876db5348d9868c2f607835057cf99fb471e5a1ab59461f4f80029"

// DeployMediaStoreVersionControl deploys a new Ethereum contract, binding an instance of MediaStoreVersionControl to it.
func DeployMediaStoreVersionControl(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MediaStoreVersionControl, error) {
	parsed, err := abi.JSON(strings.NewReader(MediaStoreVersionControlABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(MediaStoreVersionControlBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MediaStoreVersionControl{MediaStoreVersionControlCaller: MediaStoreVersionControlCaller{contract: contract}, MediaStoreVersionControlTransactor: MediaStoreVersionControlTransactor{contract: contract}, MediaStoreVersionControlFilterer: MediaStoreVersionControlFilterer{contract: contract}}, nil
}

// MediaStoreVersionControl is an auto generated Go binding around an Ethereum contract.
type MediaStoreVersionControl struct {
	MediaStoreVersionControlCaller     // Read-only binding to the contract
	MediaStoreVersionControlTransactor // Write-only binding to the contract
	MediaStoreVersionControlFilterer   // Log filterer for contract events
}

// MediaStoreVersionControlCaller is an auto generated read-only Go binding around an Ethereum contract.
type MediaStoreVersionControlCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MediaStoreVersionControlTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MediaStoreVersionControlTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MediaStoreVersionControlFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MediaStoreVersionControlFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MediaStoreVersionControlSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MediaStoreVersionControlSession struct {
	Contract     *MediaStoreVersionControl // Generic contract binding to set the session for
	CallOpts     bind.CallOpts             // Call options to use throughout this session
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// MediaStoreVersionControlCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MediaStoreVersionControlCallerSession struct {
	Contract *MediaStoreVersionControlCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                   // Call options to use throughout this session
}

// MediaStoreVersionControlTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MediaStoreVersionControlTransactorSession struct {
	Contract     *MediaStoreVersionControlTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                   // Transaction auth options to use throughout this session
}

// MediaStoreVersionControlRaw is an auto generated low-level Go binding around an Ethereum contract.
type MediaStoreVersionControlRaw struct {
	Contract *MediaStoreVersionControl // Generic contract binding to access the raw methods on
}

// MediaStoreVersionControlCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MediaStoreVersionControlCallerRaw struct {
	Contract *MediaStoreVersionControlCaller // Generic read-only contract binding to access the raw methods on
}

// MediaStoreVersionControlTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MediaStoreVersionControlTransactorRaw struct {
	Contract *MediaStoreVersionControlTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMediaStoreVersionControl creates a new instance of MediaStoreVersionControl, bound to a specific deployed contract.
func NewMediaStoreVersionControl(address common.Address, backend bind.ContractBackend) (*MediaStoreVersionControl, error) {
	contract, err := bindMediaStoreVersionControl(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MediaStoreVersionControl{MediaStoreVersionControlCaller: MediaStoreVersionControlCaller{contract: contract}, MediaStoreVersionControlTransactor: MediaStoreVersionControlTransactor{contract: contract}, MediaStoreVersionControlFilterer: MediaStoreVersionControlFilterer{contract: contract}}, nil
}

// NewMediaStoreVersionControlCaller creates a new read-only instance of MediaStoreVersionControl, bound to a specific deployed contract.
func NewMediaStoreVersionControlCaller(address common.Address, caller bind.ContractCaller) (*MediaStoreVersionControlCaller, error) {
	contract, err := bindMediaStoreVersionControl(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MediaStoreVersionControlCaller{contract: contract}, nil
}

// NewMediaStoreVersionControlTransactor creates a new write-only instance of MediaStoreVersionControl, bound to a specific deployed contract.
func NewMediaStoreVersionControlTransactor(address common.Address, transactor bind.ContractTransactor) (*MediaStoreVersionControlTransactor, error) {
	contract, err := bindMediaStoreVersionControl(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MediaStoreVersionControlTransactor{contract: contract}, nil
}

// NewMediaStoreVersionControlFilterer creates a new log filterer instance of MediaStoreVersionControl, bound to a specific deployed contract.
func NewMediaStoreVersionControlFilterer(address common.Address, filterer bind.ContractFilterer) (*MediaStoreVersionControlFilterer, error) {
	contract, err := bindMediaStoreVersionControl(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MediaStoreVersionControlFilterer{contract: contract}, nil
}

// bindMediaStoreVersionControl binds a generic wrapper to an already deployed contract.
func bindMediaStoreVersionControl(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(MediaStoreVersionControlABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MediaStoreVersionControl *MediaStoreVersionControlRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _MediaStoreVersionControl.Contract.MediaStoreVersionControlCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MediaStoreVersionControl *MediaStoreVersionControlRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MediaStoreVersionControl.Contract.MediaStoreVersionControlTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MediaStoreVersionControl *MediaStoreVersionControlRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MediaStoreVersionControl.Contract.MediaStoreVersionControlTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MediaStoreVersionControl *MediaStoreVersionControlCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _MediaStoreVersionControl.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MediaStoreVersionControl *MediaStoreVersionControlTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MediaStoreVersionControl.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MediaStoreVersionControl *MediaStoreVersionControlTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MediaStoreVersionControl.Contract.contract.Transact(opts, method, params...)
}

// CurrentDigitalMediaStore is a free data retrieval call binding the contract method 0x1b284e75.
//
// Solidity: function currentDigitalMediaStore() constant returns(address)
func (_MediaStoreVersionControl *MediaStoreVersionControlCaller) CurrentDigitalMediaStore(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _MediaStoreVersionControl.contract.Call(opts, out, "currentDigitalMediaStore")
	return *ret0, err
}

// CurrentDigitalMediaStore is a free data retrieval call binding the contract method 0x1b284e75.
//
// Solidity: function currentDigitalMediaStore() constant returns(address)
func (_MediaStoreVersionControl *MediaStoreVersionControlSession) CurrentDigitalMediaStore() (common.Address, error) {
	return _MediaStoreVersionControl.Contract.CurrentDigitalMediaStore(&_MediaStoreVersionControl.CallOpts)
}

// CurrentDigitalMediaStore is a free data retrieval call binding the contract method 0x1b284e75.
//
// Solidity: function currentDigitalMediaStore() constant returns(address)
func (_MediaStoreVersionControl *MediaStoreVersionControlCallerSession) CurrentDigitalMediaStore() (common.Address, error) {
	return _MediaStoreVersionControl.Contract.CurrentDigitalMediaStore(&_MediaStoreVersionControl.CallOpts)
}

// CurrentStartingDigitalMediaId is a free data retrieval call binding the contract method 0x0154788d.
//
// Solidity: function currentStartingDigitalMediaId() constant returns(uint256)
func (_MediaStoreVersionControl *MediaStoreVersionControlCaller) CurrentStartingDigitalMediaId(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _MediaStoreVersionControl.contract.Call(opts, out, "currentStartingDigitalMediaId")
	return *ret0, err
}

// CurrentStartingDigitalMediaId is a free data retrieval call binding the contract method 0x0154788d.
//
// Solidity: function currentStartingDigitalMediaId() constant returns(uint256)
func (_MediaStoreVersionControl *MediaStoreVersionControlSession) CurrentStartingDigitalMediaId() (*big.Int, error) {
	return _MediaStoreVersionControl.Contract.CurrentStartingDigitalMediaId(&_MediaStoreVersionControl.CallOpts)
}

// CurrentStartingDigitalMediaId is a free data retrieval call binding the contract method 0x0154788d.
//
// Solidity: function currentStartingDigitalMediaId() constant returns(uint256)
func (_MediaStoreVersionControl *MediaStoreVersionControlCallerSession) CurrentStartingDigitalMediaId() (*big.Int, error) {
	return _MediaStoreVersionControl.Contract.CurrentStartingDigitalMediaId(&_MediaStoreVersionControl.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_MediaStoreVersionControl *MediaStoreVersionControlCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _MediaStoreVersionControl.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_MediaStoreVersionControl *MediaStoreVersionControlSession) Owner() (common.Address, error) {
	return _MediaStoreVersionControl.Contract.Owner(&_MediaStoreVersionControl.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_MediaStoreVersionControl *MediaStoreVersionControlCallerSession) Owner() (common.Address, error) {
	return _MediaStoreVersionControl.Contract.Owner(&_MediaStoreVersionControl.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_MediaStoreVersionControl *MediaStoreVersionControlCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _MediaStoreVersionControl.contract.Call(opts, out, "paused")
	return *ret0, err
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_MediaStoreVersionControl *MediaStoreVersionControlSession) Paused() (bool, error) {
	return _MediaStoreVersionControl.Contract.Paused(&_MediaStoreVersionControl.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_MediaStoreVersionControl *MediaStoreVersionControlCallerSession) Paused() (bool, error) {
	return _MediaStoreVersionControl.Contract.Paused(&_MediaStoreVersionControl.CallOpts)
}

// V1DigitalMediaStore is a free data retrieval call binding the contract method 0xa0f01e08.
//
// Solidity: function v1DigitalMediaStore() constant returns(address)
func (_MediaStoreVersionControl *MediaStoreVersionControlCaller) V1DigitalMediaStore(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _MediaStoreVersionControl.contract.Call(opts, out, "v1DigitalMediaStore")
	return *ret0, err
}

// V1DigitalMediaStore is a free data retrieval call binding the contract method 0xa0f01e08.
//
// Solidity: function v1DigitalMediaStore() constant returns(address)
func (_MediaStoreVersionControl *MediaStoreVersionControlSession) V1DigitalMediaStore() (common.Address, error) {
	return _MediaStoreVersionControl.Contract.V1DigitalMediaStore(&_MediaStoreVersionControl.CallOpts)
}

// V1DigitalMediaStore is a free data retrieval call binding the contract method 0xa0f01e08.
//
// Solidity: function v1DigitalMediaStore() constant returns(address)
func (_MediaStoreVersionControl *MediaStoreVersionControlCallerSession) V1DigitalMediaStore() (common.Address, error) {
	return _MediaStoreVersionControl.Contract.V1DigitalMediaStore(&_MediaStoreVersionControl.CallOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_MediaStoreVersionControl *MediaStoreVersionControlTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MediaStoreVersionControl.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_MediaStoreVersionControl *MediaStoreVersionControlSession) Pause() (*types.Transaction, error) {
	return _MediaStoreVersionControl.Contract.Pause(&_MediaStoreVersionControl.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_MediaStoreVersionControl *MediaStoreVersionControlTransactorSession) Pause() (*types.Transaction, error) {
	return _MediaStoreVersionControl.Contract.Pause(&_MediaStoreVersionControl.TransactOpts)
}

// SetV1DigitalMediaStoreAddress is a paid mutator transaction binding the contract method 0x91c60788.
//
// Solidity: function setV1DigitalMediaStoreAddress(address _dmsAddress) returns()
func (_MediaStoreVersionControl *MediaStoreVersionControlTransactor) SetV1DigitalMediaStoreAddress(opts *bind.TransactOpts, _dmsAddress common.Address) (*types.Transaction, error) {
	return _MediaStoreVersionControl.contract.Transact(opts, "setV1DigitalMediaStoreAddress", _dmsAddress)
}

// SetV1DigitalMediaStoreAddress is a paid mutator transaction binding the contract method 0x91c60788.
//
// Solidity: function setV1DigitalMediaStoreAddress(address _dmsAddress) returns()
func (_MediaStoreVersionControl *MediaStoreVersionControlSession) SetV1DigitalMediaStoreAddress(_dmsAddress common.Address) (*types.Transaction, error) {
	return _MediaStoreVersionControl.Contract.SetV1DigitalMediaStoreAddress(&_MediaStoreVersionControl.TransactOpts, _dmsAddress)
}

// SetV1DigitalMediaStoreAddress is a paid mutator transaction binding the contract method 0x91c60788.
//
// Solidity: function setV1DigitalMediaStoreAddress(address _dmsAddress) returns()
func (_MediaStoreVersionControl *MediaStoreVersionControlTransactorSession) SetV1DigitalMediaStoreAddress(_dmsAddress common.Address) (*types.Transaction, error) {
	return _MediaStoreVersionControl.Contract.SetV1DigitalMediaStoreAddress(&_MediaStoreVersionControl.TransactOpts, _dmsAddress)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MediaStoreVersionControl *MediaStoreVersionControlTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _MediaStoreVersionControl.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MediaStoreVersionControl *MediaStoreVersionControlSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _MediaStoreVersionControl.Contract.TransferOwnership(&_MediaStoreVersionControl.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MediaStoreVersionControl *MediaStoreVersionControlTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _MediaStoreVersionControl.Contract.TransferOwnership(&_MediaStoreVersionControl.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_MediaStoreVersionControl *MediaStoreVersionControlTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MediaStoreVersionControl.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_MediaStoreVersionControl *MediaStoreVersionControlSession) Unpause() (*types.Transaction, error) {
	return _MediaStoreVersionControl.Contract.Unpause(&_MediaStoreVersionControl.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_MediaStoreVersionControl *MediaStoreVersionControlTransactorSession) Unpause() (*types.Transaction, error) {
	return _MediaStoreVersionControl.Contract.Unpause(&_MediaStoreVersionControl.TransactOpts)
}

// MediaStoreVersionControlOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the MediaStoreVersionControl contract.
type MediaStoreVersionControlOwnershipTransferredIterator struct {
	Event *MediaStoreVersionControlOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MediaStoreVersionControlOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MediaStoreVersionControlOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MediaStoreVersionControlOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MediaStoreVersionControlOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MediaStoreVersionControlOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MediaStoreVersionControlOwnershipTransferred represents a OwnershipTransferred event raised by the MediaStoreVersionControl contract.
type MediaStoreVersionControlOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MediaStoreVersionControl *MediaStoreVersionControlFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*MediaStoreVersionControlOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _MediaStoreVersionControl.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &MediaStoreVersionControlOwnershipTransferredIterator{contract: _MediaStoreVersionControl.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MediaStoreVersionControl *MediaStoreVersionControlFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *MediaStoreVersionControlOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _MediaStoreVersionControl.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MediaStoreVersionControlOwnershipTransferred)
				if err := _MediaStoreVersionControl.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MediaStoreVersionControl *MediaStoreVersionControlFilterer) ParseOwnershipTransferred(log types.Log) (*MediaStoreVersionControlOwnershipTransferred, error) {
	event := new(MediaStoreVersionControlOwnershipTransferred)
	if err := _MediaStoreVersionControl.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// MediaStoreVersionControlPauseIterator is returned from FilterPause and is used to iterate over the raw logs and unpacked data for Pause events raised by the MediaStoreVersionControl contract.
type MediaStoreVersionControlPauseIterator struct {
	Event *MediaStoreVersionControlPause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MediaStoreVersionControlPauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MediaStoreVersionControlPause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MediaStoreVersionControlPause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MediaStoreVersionControlPauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MediaStoreVersionControlPauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MediaStoreVersionControlPause represents a Pause event raised by the MediaStoreVersionControl contract.
type MediaStoreVersionControlPause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPause is a free log retrieval operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_MediaStoreVersionControl *MediaStoreVersionControlFilterer) FilterPause(opts *bind.FilterOpts) (*MediaStoreVersionControlPauseIterator, error) {

	logs, sub, err := _MediaStoreVersionControl.contract.FilterLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return &MediaStoreVersionControlPauseIterator{contract: _MediaStoreVersionControl.contract, event: "Pause", logs: logs, sub: sub}, nil
}

// WatchPause is a free log subscription operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_MediaStoreVersionControl *MediaStoreVersionControlFilterer) WatchPause(opts *bind.WatchOpts, sink chan<- *MediaStoreVersionControlPause) (event.Subscription, error) {

	logs, sub, err := _MediaStoreVersionControl.contract.WatchLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MediaStoreVersionControlPause)
				if err := _MediaStoreVersionControl.contract.UnpackLog(event, "Pause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePause is a log parse operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_MediaStoreVersionControl *MediaStoreVersionControlFilterer) ParsePause(log types.Log) (*MediaStoreVersionControlPause, error) {
	event := new(MediaStoreVersionControlPause)
	if err := _MediaStoreVersionControl.contract.UnpackLog(event, "Pause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// MediaStoreVersionControlUnpauseIterator is returned from FilterUnpause and is used to iterate over the raw logs and unpacked data for Unpause events raised by the MediaStoreVersionControl contract.
type MediaStoreVersionControlUnpauseIterator struct {
	Event *MediaStoreVersionControlUnpause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MediaStoreVersionControlUnpauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MediaStoreVersionControlUnpause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MediaStoreVersionControlUnpause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MediaStoreVersionControlUnpauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MediaStoreVersionControlUnpauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MediaStoreVersionControlUnpause represents a Unpause event raised by the MediaStoreVersionControl contract.
type MediaStoreVersionControlUnpause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUnpause is a free log retrieval operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_MediaStoreVersionControl *MediaStoreVersionControlFilterer) FilterUnpause(opts *bind.FilterOpts) (*MediaStoreVersionControlUnpauseIterator, error) {

	logs, sub, err := _MediaStoreVersionControl.contract.FilterLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return &MediaStoreVersionControlUnpauseIterator{contract: _MediaStoreVersionControl.contract, event: "Unpause", logs: logs, sub: sub}, nil
}

// WatchUnpause is a free log subscription operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_MediaStoreVersionControl *MediaStoreVersionControlFilterer) WatchUnpause(opts *bind.WatchOpts, sink chan<- *MediaStoreVersionControlUnpause) (event.Subscription, error) {

	logs, sub, err := _MediaStoreVersionControl.contract.WatchLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MediaStoreVersionControlUnpause)
				if err := _MediaStoreVersionControl.contract.UnpackLog(event, "Unpause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpause is a log parse operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_MediaStoreVersionControl *MediaStoreVersionControlFilterer) ParseUnpause(log types.Log) (*MediaStoreVersionControlUnpause, error) {
	event := new(MediaStoreVersionControlUnpause)
	if err := _MediaStoreVersionControl.contract.UnpackLog(event, "Unpause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// MemoryABI is the input ABI used to generate the binding from.
const MemoryABI = "[]"

// MemoryBin is the compiled bytecode used for deploying new contracts.
var MemoryBin = "0x604c602c600b82828239805160001a60731460008114601c57601e565bfe5b5030600052607381538281f30073000000000000000000000000000000000000000030146080604052600080fd00a165627a7a723058207d7ab7bbaf3cf5a72a93af44221b9bbf4f0690804ada30ee7a6d552b66c3e8500029"

// DeployMemory deploys a new Ethereum contract, binding an instance of Memory to it.
func DeployMemory(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Memory, error) {
	parsed, err := abi.JSON(strings.NewReader(MemoryABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(MemoryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Memory{MemoryCaller: MemoryCaller{contract: contract}, MemoryTransactor: MemoryTransactor{contract: contract}, MemoryFilterer: MemoryFilterer{contract: contract}}, nil
}

// Memory is an auto generated Go binding around an Ethereum contract.
type Memory struct {
	MemoryCaller     // Read-only binding to the contract
	MemoryTransactor // Write-only binding to the contract
	MemoryFilterer   // Log filterer for contract events
}

// MemoryCaller is an auto generated read-only Go binding around an Ethereum contract.
type MemoryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MemoryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MemoryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MemoryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MemoryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MemorySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MemorySession struct {
	Contract     *Memory           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MemoryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MemoryCallerSession struct {
	Contract *MemoryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// MemoryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MemoryTransactorSession struct {
	Contract     *MemoryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MemoryRaw is an auto generated low-level Go binding around an Ethereum contract.
type MemoryRaw struct {
	Contract *Memory // Generic contract binding to access the raw methods on
}

// MemoryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MemoryCallerRaw struct {
	Contract *MemoryCaller // Generic read-only contract binding to access the raw methods on
}

// MemoryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MemoryTransactorRaw struct {
	Contract *MemoryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMemory creates a new instance of Memory, bound to a specific deployed contract.
func NewMemory(address common.Address, backend bind.ContractBackend) (*Memory, error) {
	contract, err := bindMemory(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Memory{MemoryCaller: MemoryCaller{contract: contract}, MemoryTransactor: MemoryTransactor{contract: contract}, MemoryFilterer: MemoryFilterer{contract: contract}}, nil
}

// NewMemoryCaller creates a new read-only instance of Memory, bound to a specific deployed contract.
func NewMemoryCaller(address common.Address, caller bind.ContractCaller) (*MemoryCaller, error) {
	contract, err := bindMemory(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MemoryCaller{contract: contract}, nil
}

// NewMemoryTransactor creates a new write-only instance of Memory, bound to a specific deployed contract.
func NewMemoryTransactor(address common.Address, transactor bind.ContractTransactor) (*MemoryTransactor, error) {
	contract, err := bindMemory(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MemoryTransactor{contract: contract}, nil
}

// NewMemoryFilterer creates a new log filterer instance of Memory, bound to a specific deployed contract.
func NewMemoryFilterer(address common.Address, filterer bind.ContractFilterer) (*MemoryFilterer, error) {
	contract, err := bindMemory(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MemoryFilterer{contract: contract}, nil
}

// bindMemory binds a generic wrapper to an already deployed contract.
func bindMemory(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(MemoryABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Memory *MemoryRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Memory.Contract.MemoryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Memory *MemoryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Memory.Contract.MemoryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Memory *MemoryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Memory.Contract.MemoryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Memory *MemoryCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Memory.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Memory *MemoryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Memory.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Memory *MemoryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Memory.Contract.contract.Transact(opts, method, params...)
}

// OBOControlABI is the input ABI used to generate the binding from.
const OBOControlABI = "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedOBOs\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oboAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedOBO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oboAddress\",\"type\":\"address\"}],\"name\":\"addApprovedOBO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]"

// OBOControlFuncSigs maps the 4-byte function signature to its string representation.
var OBOControlFuncSigs = map[string]string{
	"cd161d2e": "addApprovedOBO(address)",
	"1ad32562": "approvedOBOs(address)",
	"8da5cb5b": "owner()",
	"8456cb59": "pause()",
	"5c975abb": "paused()",
	"7ff9f614": "removeApprovedOBO(address)",
	"f2fde38b": "transferOwnership(address)",
	"3f4ba83a": "unpause()",
}

// OBOControlBin is the compiled bytecode used for deploying new contracts.
var OBOControlBin = "0x608060405260008054600160a860020a0319163317905561043b806100256000396000f30060806040526004361061008d5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416631ad3256281146100925780633f4ba83a146100c75780635c975abb146100de5780637ff9f614146100f35780638456cb59146101145780638da5cb5b14610129578063cd161d2e1461015a578063f2fde38b1461017b575b600080fd5b34801561009e57600080fd5b506100b3600160a060020a036004351661019c565b604080519115158252519081900360200190f35b3480156100d357600080fd5b506100dc6101b1565b005b3480156100ea57600080fd5b506100b3610238565b3480156100ff57600080fd5b506100dc600160a060020a0360043516610259565b34801561012057600080fd5b506100dc610291565b34801561013557600080fd5b5061013e61032e565b60408051600160a060020a039092168252519081900360200190f35b34801561016657600080fd5b506100dc600160a060020a036004351661033d565b34801561018757600080fd5b506100dc600160a060020a036004351661037b565b60016020526000908152604090205460ff1681565b600054600160a060020a031633146101c857600080fd5b60005474010000000000000000000000000000000000000000900460ff1615156101f157600080fd5b6000805474ff0000000000000000000000000000000000000000191681556040517f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b339190a1565b60005474010000000000000000000000000000000000000000900460ff1681565b600054600160a060020a0316331461027057600080fd5b600160a060020a03166000908152600160205260409020805460ff19169055565b600054600160a060020a031633146102a857600080fd5b60005474010000000000000000000000000000000000000000900460ff16156102d057600080fd5b6000805474ff00000000000000000000000000000000000000001916740100000000000000000000000000000000000000001781556040517f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff6259190a1565b600054600160a060020a031681565b600054600160a060020a0316331461035457600080fd5b600160a060020a03166000908152600160208190526040909120805460ff19169091179055565b600054600160a060020a0316331461039257600080fd5b600160a060020a03811615156103a757600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790555600a165627a7a7230582046b0e39f293f913a5018ed6fc73b5c7fa5312e7140668e52710d2bec5f22f5de0029"

// DeployOBOControl deploys a new Ethereum contract, binding an instance of OBOControl to it.
func DeployOBOControl(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *OBOControl, error) {
	parsed, err := abi.JSON(strings.NewReader(OBOControlABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(OBOControlBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &OBOControl{OBOControlCaller: OBOControlCaller{contract: contract}, OBOControlTransactor: OBOControlTransactor{contract: contract}, OBOControlFilterer: OBOControlFilterer{contract: contract}}, nil
}

// OBOControl is an auto generated Go binding around an Ethereum contract.
type OBOControl struct {
	OBOControlCaller     // Read-only binding to the contract
	OBOControlTransactor // Write-only binding to the contract
	OBOControlFilterer   // Log filterer for contract events
}

// OBOControlCaller is an auto generated read-only Go binding around an Ethereum contract.
type OBOControlCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OBOControlTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OBOControlTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OBOControlFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OBOControlFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OBOControlSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OBOControlSession struct {
	Contract     *OBOControl       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OBOControlCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OBOControlCallerSession struct {
	Contract *OBOControlCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// OBOControlTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OBOControlTransactorSession struct {
	Contract     *OBOControlTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// OBOControlRaw is an auto generated low-level Go binding around an Ethereum contract.
type OBOControlRaw struct {
	Contract *OBOControl // Generic contract binding to access the raw methods on
}

// OBOControlCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OBOControlCallerRaw struct {
	Contract *OBOControlCaller // Generic read-only contract binding to access the raw methods on
}

// OBOControlTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OBOControlTransactorRaw struct {
	Contract *OBOControlTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOBOControl creates a new instance of OBOControl, bound to a specific deployed contract.
func NewOBOControl(address common.Address, backend bind.ContractBackend) (*OBOControl, error) {
	contract, err := bindOBOControl(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &OBOControl{OBOControlCaller: OBOControlCaller{contract: contract}, OBOControlTransactor: OBOControlTransactor{contract: contract}, OBOControlFilterer: OBOControlFilterer{contract: contract}}, nil
}

// NewOBOControlCaller creates a new read-only instance of OBOControl, bound to a specific deployed contract.
func NewOBOControlCaller(address common.Address, caller bind.ContractCaller) (*OBOControlCaller, error) {
	contract, err := bindOBOControl(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OBOControlCaller{contract: contract}, nil
}

// NewOBOControlTransactor creates a new write-only instance of OBOControl, bound to a specific deployed contract.
func NewOBOControlTransactor(address common.Address, transactor bind.ContractTransactor) (*OBOControlTransactor, error) {
	contract, err := bindOBOControl(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OBOControlTransactor{contract: contract}, nil
}

// NewOBOControlFilterer creates a new log filterer instance of OBOControl, bound to a specific deployed contract.
func NewOBOControlFilterer(address common.Address, filterer bind.ContractFilterer) (*OBOControlFilterer, error) {
	contract, err := bindOBOControl(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OBOControlFilterer{contract: contract}, nil
}

// bindOBOControl binds a generic wrapper to an already deployed contract.
func bindOBOControl(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(OBOControlABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_OBOControl *OBOControlRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _OBOControl.Contract.OBOControlCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_OBOControl *OBOControlRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OBOControl.Contract.OBOControlTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_OBOControl *OBOControlRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _OBOControl.Contract.OBOControlTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_OBOControl *OBOControlCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _OBOControl.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_OBOControl *OBOControlTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OBOControl.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_OBOControl *OBOControlTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _OBOControl.Contract.contract.Transact(opts, method, params...)
}

// ApprovedOBOs is a free data retrieval call binding the contract method 0x1ad32562.
//
// Solidity: function approvedOBOs(address ) constant returns(bool)
func (_OBOControl *OBOControlCaller) ApprovedOBOs(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _OBOControl.contract.Call(opts, out, "approvedOBOs", arg0)
	return *ret0, err
}

// ApprovedOBOs is a free data retrieval call binding the contract method 0x1ad32562.
//
// Solidity: function approvedOBOs(address ) constant returns(bool)
func (_OBOControl *OBOControlSession) ApprovedOBOs(arg0 common.Address) (bool, error) {
	return _OBOControl.Contract.ApprovedOBOs(&_OBOControl.CallOpts, arg0)
}

// ApprovedOBOs is a free data retrieval call binding the contract method 0x1ad32562.
//
// Solidity: function approvedOBOs(address ) constant returns(bool)
func (_OBOControl *OBOControlCallerSession) ApprovedOBOs(arg0 common.Address) (bool, error) {
	return _OBOControl.Contract.ApprovedOBOs(&_OBOControl.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_OBOControl *OBOControlCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _OBOControl.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_OBOControl *OBOControlSession) Owner() (common.Address, error) {
	return _OBOControl.Contract.Owner(&_OBOControl.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_OBOControl *OBOControlCallerSession) Owner() (common.Address, error) {
	return _OBOControl.Contract.Owner(&_OBOControl.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_OBOControl *OBOControlCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _OBOControl.contract.Call(opts, out, "paused")
	return *ret0, err
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_OBOControl *OBOControlSession) Paused() (bool, error) {
	return _OBOControl.Contract.Paused(&_OBOControl.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_OBOControl *OBOControlCallerSession) Paused() (bool, error) {
	return _OBOControl.Contract.Paused(&_OBOControl.CallOpts)
}

// AddApprovedOBO is a paid mutator transaction binding the contract method 0xcd161d2e.
//
// Solidity: function addApprovedOBO(address _oboAddress) returns()
func (_OBOControl *OBOControlTransactor) AddApprovedOBO(opts *bind.TransactOpts, _oboAddress common.Address) (*types.Transaction, error) {
	return _OBOControl.contract.Transact(opts, "addApprovedOBO", _oboAddress)
}

// AddApprovedOBO is a paid mutator transaction binding the contract method 0xcd161d2e.
//
// Solidity: function addApprovedOBO(address _oboAddress) returns()
func (_OBOControl *OBOControlSession) AddApprovedOBO(_oboAddress common.Address) (*types.Transaction, error) {
	return _OBOControl.Contract.AddApprovedOBO(&_OBOControl.TransactOpts, _oboAddress)
}

// AddApprovedOBO is a paid mutator transaction binding the contract method 0xcd161d2e.
//
// Solidity: function addApprovedOBO(address _oboAddress) returns()
func (_OBOControl *OBOControlTransactorSession) AddApprovedOBO(_oboAddress common.Address) (*types.Transaction, error) {
	return _OBOControl.Contract.AddApprovedOBO(&_OBOControl.TransactOpts, _oboAddress)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OBOControl *OBOControlTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OBOControl.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OBOControl *OBOControlSession) Pause() (*types.Transaction, error) {
	return _OBOControl.Contract.Pause(&_OBOControl.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OBOControl *OBOControlTransactorSession) Pause() (*types.Transaction, error) {
	return _OBOControl.Contract.Pause(&_OBOControl.TransactOpts)
}

// RemoveApprovedOBO is a paid mutator transaction binding the contract method 0x7ff9f614.
//
// Solidity: function removeApprovedOBO(address _oboAddress) returns()
func (_OBOControl *OBOControlTransactor) RemoveApprovedOBO(opts *bind.TransactOpts, _oboAddress common.Address) (*types.Transaction, error) {
	return _OBOControl.contract.Transact(opts, "removeApprovedOBO", _oboAddress)
}

// RemoveApprovedOBO is a paid mutator transaction binding the contract method 0x7ff9f614.
//
// Solidity: function removeApprovedOBO(address _oboAddress) returns()
func (_OBOControl *OBOControlSession) RemoveApprovedOBO(_oboAddress common.Address) (*types.Transaction, error) {
	return _OBOControl.Contract.RemoveApprovedOBO(&_OBOControl.TransactOpts, _oboAddress)
}

// RemoveApprovedOBO is a paid mutator transaction binding the contract method 0x7ff9f614.
//
// Solidity: function removeApprovedOBO(address _oboAddress) returns()
func (_OBOControl *OBOControlTransactorSession) RemoveApprovedOBO(_oboAddress common.Address) (*types.Transaction, error) {
	return _OBOControl.Contract.RemoveApprovedOBO(&_OBOControl.TransactOpts, _oboAddress)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OBOControl *OBOControlTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _OBOControl.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OBOControl *OBOControlSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _OBOControl.Contract.TransferOwnership(&_OBOControl.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OBOControl *OBOControlTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _OBOControl.Contract.TransferOwnership(&_OBOControl.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OBOControl *OBOControlTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OBOControl.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OBOControl *OBOControlSession) Unpause() (*types.Transaction, error) {
	return _OBOControl.Contract.Unpause(&_OBOControl.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OBOControl *OBOControlTransactorSession) Unpause() (*types.Transaction, error) {
	return _OBOControl.Contract.Unpause(&_OBOControl.TransactOpts)
}

// OBOControlOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the OBOControl contract.
type OBOControlOwnershipTransferredIterator struct {
	Event *OBOControlOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OBOControlOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OBOControlOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OBOControlOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OBOControlOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OBOControlOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OBOControlOwnershipTransferred represents a OwnershipTransferred event raised by the OBOControl contract.
type OBOControlOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OBOControl *OBOControlFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OBOControlOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _OBOControl.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OBOControlOwnershipTransferredIterator{contract: _OBOControl.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OBOControl *OBOControlFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OBOControlOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _OBOControl.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OBOControlOwnershipTransferred)
				if err := _OBOControl.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OBOControl *OBOControlFilterer) ParseOwnershipTransferred(log types.Log) (*OBOControlOwnershipTransferred, error) {
	event := new(OBOControlOwnershipTransferred)
	if err := _OBOControl.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// OBOControlPauseIterator is returned from FilterPause and is used to iterate over the raw logs and unpacked data for Pause events raised by the OBOControl contract.
type OBOControlPauseIterator struct {
	Event *OBOControlPause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OBOControlPauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OBOControlPause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OBOControlPause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OBOControlPauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OBOControlPauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OBOControlPause represents a Pause event raised by the OBOControl contract.
type OBOControlPause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPause is a free log retrieval operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_OBOControl *OBOControlFilterer) FilterPause(opts *bind.FilterOpts) (*OBOControlPauseIterator, error) {

	logs, sub, err := _OBOControl.contract.FilterLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return &OBOControlPauseIterator{contract: _OBOControl.contract, event: "Pause", logs: logs, sub: sub}, nil
}

// WatchPause is a free log subscription operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_OBOControl *OBOControlFilterer) WatchPause(opts *bind.WatchOpts, sink chan<- *OBOControlPause) (event.Subscription, error) {

	logs, sub, err := _OBOControl.contract.WatchLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OBOControlPause)
				if err := _OBOControl.contract.UnpackLog(event, "Pause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePause is a log parse operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_OBOControl *OBOControlFilterer) ParsePause(log types.Log) (*OBOControlPause, error) {
	event := new(OBOControlPause)
	if err := _OBOControl.contract.UnpackLog(event, "Pause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// OBOControlUnpauseIterator is returned from FilterUnpause and is used to iterate over the raw logs and unpacked data for Unpause events raised by the OBOControl contract.
type OBOControlUnpauseIterator struct {
	Event *OBOControlUnpause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OBOControlUnpauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OBOControlUnpause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OBOControlUnpause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OBOControlUnpauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OBOControlUnpauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OBOControlUnpause represents a Unpause event raised by the OBOControl contract.
type OBOControlUnpause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUnpause is a free log retrieval operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_OBOControl *OBOControlFilterer) FilterUnpause(opts *bind.FilterOpts) (*OBOControlUnpauseIterator, error) {

	logs, sub, err := _OBOControl.contract.FilterLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return &OBOControlUnpauseIterator{contract: _OBOControl.contract, event: "Unpause", logs: logs, sub: sub}, nil
}

// WatchUnpause is a free log subscription operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_OBOControl *OBOControlFilterer) WatchUnpause(opts *bind.WatchOpts, sink chan<- *OBOControlUnpause) (event.Subscription, error) {

	logs, sub, err := _OBOControl.contract.WatchLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OBOControlUnpause)
				if err := _OBOControl.contract.UnpackLog(event, "Unpause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpause is a log parse operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_OBOControl *OBOControlFilterer) ParseUnpause(log types.Log) (*OBOControlUnpause, error) {
	event := new(OBOControlUnpause)
	if err := _OBOControl.contract.UnpackLog(event, "Unpause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// OwnableABI is the input ABI used to generate the binding from.
const OwnableABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]"

// OwnableFuncSigs maps the 4-byte function signature to its string representation.
var OwnableFuncSigs = map[string]string{
	"8da5cb5b": "owner()",
	"f2fde38b": "transferOwnership(address)",
}

// OwnableBin is the compiled bytecode used for deploying new contracts.
var OwnableBin = "0x608060405234801561001057600080fd5b5060008054600160a060020a03191633179055610173806100326000396000f30060806040526004361061004b5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416638da5cb5b8114610050578063f2fde38b14610081575b600080fd5b34801561005c57600080fd5b506100656100a4565b60408051600160a060020a039092168252519081900360200190f35b34801561008d57600080fd5b506100a2600160a060020a03600435166100b3565b005b600054600160a060020a031681565b600054600160a060020a031633146100ca57600080fd5b600160a060020a03811615156100df57600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790555600a165627a7a72305820600808923d000e746ac902ee844a4fc6ad8c6fa1e52c14db9d460b6d7121d99b0029"

// DeployOwnable deploys a new Ethereum contract, binding an instance of Ownable to it.
func DeployOwnable(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Ownable, error) {
	parsed, err := abi.JSON(strings.NewReader(OwnableABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(OwnableBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Ownable{OwnableCaller: OwnableCaller{contract: contract}, OwnableTransactor: OwnableTransactor{contract: contract}, OwnableFilterer: OwnableFilterer{contract: contract}}, nil
}

// Ownable is an auto generated Go binding around an Ethereum contract.
type Ownable struct {
	OwnableCaller     // Read-only binding to the contract
	OwnableTransactor // Write-only binding to the contract
	OwnableFilterer   // Log filterer for contract events
}

// OwnableCaller is an auto generated read-only Go binding around an Ethereum contract.
type OwnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OwnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OwnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OwnableSession struct {
	Contract     *Ownable          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OwnableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OwnableCallerSession struct {
	Contract *OwnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// OwnableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OwnableTransactorSession struct {
	Contract     *OwnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// OwnableRaw is an auto generated low-level Go binding around an Ethereum contract.
type OwnableRaw struct {
	Contract *Ownable // Generic contract binding to access the raw methods on
}

// OwnableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OwnableCallerRaw struct {
	Contract *OwnableCaller // Generic read-only contract binding to access the raw methods on
}

// OwnableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OwnableTransactorRaw struct {
	Contract *OwnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOwnable creates a new instance of Ownable, bound to a specific deployed contract.
func NewOwnable(address common.Address, backend bind.ContractBackend) (*Ownable, error) {
	contract, err := bindOwnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Ownable{OwnableCaller: OwnableCaller{contract: contract}, OwnableTransactor: OwnableTransactor{contract: contract}, OwnableFilterer: OwnableFilterer{contract: contract}}, nil
}

// NewOwnableCaller creates a new read-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableCaller(address common.Address, caller bind.ContractCaller) (*OwnableCaller, error) {
	contract, err := bindOwnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableCaller{contract: contract}, nil
}

// NewOwnableTransactor creates a new write-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableTransactor(address common.Address, transactor bind.ContractTransactor) (*OwnableTransactor, error) {
	contract, err := bindOwnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableTransactor{contract: contract}, nil
}

// NewOwnableFilterer creates a new log filterer instance of Ownable, bound to a specific deployed contract.
func NewOwnableFilterer(address common.Address, filterer bind.ContractFilterer) (*OwnableFilterer, error) {
	contract, err := bindOwnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OwnableFilterer{contract: contract}, nil
}

// bindOwnable binds a generic wrapper to an already deployed contract.
func bindOwnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(OwnableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.OwnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transact(opts, method, params...)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Ownable *OwnableCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Ownable.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Ownable *OwnableSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Ownable *OwnableCallerSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// OwnableOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Ownable contract.
type OwnableOwnershipTransferredIterator struct {
	Event *OwnableOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OwnableOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OwnableOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OwnableOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OwnableOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OwnableOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OwnableOwnershipTransferred represents a OwnershipTransferred event raised by the Ownable contract.
type OwnableOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OwnableOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OwnableOwnershipTransferredIterator{contract: _Ownable.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OwnableOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OwnableOwnershipTransferred)
				if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) ParseOwnershipTransferred(log types.Log) (*OwnableOwnershipTransferred, error) {
	event := new(OwnableOwnershipTransferred)
	if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// PausableABI is the input ABI used to generate the binding from.
const PausableABI = "[{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]"

// PausableFuncSigs maps the 4-byte function signature to its string representation.
var PausableFuncSigs = map[string]string{
	"8da5cb5b": "owner()",
	"8456cb59": "pause()",
	"5c975abb": "paused()",
	"f2fde38b": "transferOwnership(address)",
	"3f4ba83a": "unpause()",
}

// PausableBin is the compiled bytecode used for deploying new contracts.
var PausableBin = "0x608060405260008054600160a860020a0319163317905561032c806100256000396000f30060806040526004361061006c5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416633f4ba83a81146100715780635c975abb146100885780638456cb59146100b15780638da5cb5b146100c6578063f2fde38b146100f7575b600080fd5b34801561007d57600080fd5b50610086610118565b005b34801561009457600080fd5b5061009d61019f565b604080519115158252519081900360200190f35b3480156100bd57600080fd5b506100866101c0565b3480156100d257600080fd5b506100db61025d565b60408051600160a060020a039092168252519081900360200190f35b34801561010357600080fd5b50610086600160a060020a036004351661026c565b600054600160a060020a0316331461012f57600080fd5b60005474010000000000000000000000000000000000000000900460ff16151561015857600080fd5b6000805474ff0000000000000000000000000000000000000000191681556040517f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b339190a1565b60005474010000000000000000000000000000000000000000900460ff1681565b600054600160a060020a031633146101d757600080fd5b60005474010000000000000000000000000000000000000000900460ff16156101ff57600080fd5b6000805474ff00000000000000000000000000000000000000001916740100000000000000000000000000000000000000001781556040517f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff6259190a1565b600054600160a060020a031681565b600054600160a060020a0316331461028357600080fd5b600160a060020a038116151561029857600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790555600a165627a7a723058205cc0c51fab55d924e58a4ae77475425c80206e81ae084e00ad9047a2cafe847f0029"

// DeployPausable deploys a new Ethereum contract, binding an instance of Pausable to it.
func DeployPausable(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Pausable, error) {
	parsed, err := abi.JSON(strings.NewReader(PausableABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(PausableBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Pausable{PausableCaller: PausableCaller{contract: contract}, PausableTransactor: PausableTransactor{contract: contract}, PausableFilterer: PausableFilterer{contract: contract}}, nil
}

// Pausable is an auto generated Go binding around an Ethereum contract.
type Pausable struct {
	PausableCaller     // Read-only binding to the contract
	PausableTransactor // Write-only binding to the contract
	PausableFilterer   // Log filterer for contract events
}

// PausableCaller is an auto generated read-only Go binding around an Ethereum contract.
type PausableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PausableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PausableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PausableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PausableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PausableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PausableSession struct {
	Contract     *Pausable         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PausableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PausableCallerSession struct {
	Contract *PausableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// PausableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PausableTransactorSession struct {
	Contract     *PausableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// PausableRaw is an auto generated low-level Go binding around an Ethereum contract.
type PausableRaw struct {
	Contract *Pausable // Generic contract binding to access the raw methods on
}

// PausableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PausableCallerRaw struct {
	Contract *PausableCaller // Generic read-only contract binding to access the raw methods on
}

// PausableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PausableTransactorRaw struct {
	Contract *PausableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPausable creates a new instance of Pausable, bound to a specific deployed contract.
func NewPausable(address common.Address, backend bind.ContractBackend) (*Pausable, error) {
	contract, err := bindPausable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Pausable{PausableCaller: PausableCaller{contract: contract}, PausableTransactor: PausableTransactor{contract: contract}, PausableFilterer: PausableFilterer{contract: contract}}, nil
}

// NewPausableCaller creates a new read-only instance of Pausable, bound to a specific deployed contract.
func NewPausableCaller(address common.Address, caller bind.ContractCaller) (*PausableCaller, error) {
	contract, err := bindPausable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PausableCaller{contract: contract}, nil
}

// NewPausableTransactor creates a new write-only instance of Pausable, bound to a specific deployed contract.
func NewPausableTransactor(address common.Address, transactor bind.ContractTransactor) (*PausableTransactor, error) {
	contract, err := bindPausable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PausableTransactor{contract: contract}, nil
}

// NewPausableFilterer creates a new log filterer instance of Pausable, bound to a specific deployed contract.
func NewPausableFilterer(address common.Address, filterer bind.ContractFilterer) (*PausableFilterer, error) {
	contract, err := bindPausable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PausableFilterer{contract: contract}, nil
}

// bindPausable binds a generic wrapper to an already deployed contract.
func bindPausable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(PausableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pausable *PausableRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Pausable.Contract.PausableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pausable *PausableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pausable.Contract.PausableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pausable *PausableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pausable.Contract.PausableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pausable *PausableCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Pausable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pausable *PausableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pausable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pausable *PausableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pausable.Contract.contract.Transact(opts, method, params...)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Pausable *PausableCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Pausable.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Pausable *PausableSession) Owner() (common.Address, error) {
	return _Pausable.Contract.Owner(&_Pausable.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Pausable *PausableCallerSession) Owner() (common.Address, error) {
	return _Pausable.Contract.Owner(&_Pausable.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_Pausable *PausableCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Pausable.contract.Call(opts, out, "paused")
	return *ret0, err
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_Pausable *PausableSession) Paused() (bool, error) {
	return _Pausable.Contract.Paused(&_Pausable.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_Pausable *PausableCallerSession) Paused() (bool, error) {
	return _Pausable.Contract.Paused(&_Pausable.CallOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_Pausable *PausableTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pausable.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_Pausable *PausableSession) Pause() (*types.Transaction, error) {
	return _Pausable.Contract.Pause(&_Pausable.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_Pausable *PausableTransactorSession) Pause() (*types.Transaction, error) {
	return _Pausable.Contract.Pause(&_Pausable.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Pausable *PausableTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Pausable.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Pausable *PausableSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Pausable.Contract.TransferOwnership(&_Pausable.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Pausable *PausableTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Pausable.Contract.TransferOwnership(&_Pausable.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_Pausable *PausableTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pausable.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_Pausable *PausableSession) Unpause() (*types.Transaction, error) {
	return _Pausable.Contract.Unpause(&_Pausable.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_Pausable *PausableTransactorSession) Unpause() (*types.Transaction, error) {
	return _Pausable.Contract.Unpause(&_Pausable.TransactOpts)
}

// PausableOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Pausable contract.
type PausableOwnershipTransferredIterator struct {
	Event *PausableOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PausableOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PausableOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PausableOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PausableOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PausableOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PausableOwnershipTransferred represents a OwnershipTransferred event raised by the Pausable contract.
type PausableOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Pausable *PausableFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*PausableOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Pausable.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PausableOwnershipTransferredIterator{contract: _Pausable.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Pausable *PausableFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *PausableOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Pausable.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PausableOwnershipTransferred)
				if err := _Pausable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Pausable *PausableFilterer) ParseOwnershipTransferred(log types.Log) (*PausableOwnershipTransferred, error) {
	event := new(PausableOwnershipTransferred)
	if err := _Pausable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// PausablePauseIterator is returned from FilterPause and is used to iterate over the raw logs and unpacked data for Pause events raised by the Pausable contract.
type PausablePauseIterator struct {
	Event *PausablePause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PausablePauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PausablePause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PausablePause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PausablePauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PausablePauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PausablePause represents a Pause event raised by the Pausable contract.
type PausablePause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPause is a free log retrieval operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_Pausable *PausableFilterer) FilterPause(opts *bind.FilterOpts) (*PausablePauseIterator, error) {

	logs, sub, err := _Pausable.contract.FilterLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return &PausablePauseIterator{contract: _Pausable.contract, event: "Pause", logs: logs, sub: sub}, nil
}

// WatchPause is a free log subscription operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_Pausable *PausableFilterer) WatchPause(opts *bind.WatchOpts, sink chan<- *PausablePause) (event.Subscription, error) {

	logs, sub, err := _Pausable.contract.WatchLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PausablePause)
				if err := _Pausable.contract.UnpackLog(event, "Pause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePause is a log parse operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_Pausable *PausableFilterer) ParsePause(log types.Log) (*PausablePause, error) {
	event := new(PausablePause)
	if err := _Pausable.contract.UnpackLog(event, "Pause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// PausableUnpauseIterator is returned from FilterUnpause and is used to iterate over the raw logs and unpacked data for Unpause events raised by the Pausable contract.
type PausableUnpauseIterator struct {
	Event *PausableUnpause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PausableUnpauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PausableUnpause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PausableUnpause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PausableUnpauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PausableUnpauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PausableUnpause represents a Unpause event raised by the Pausable contract.
type PausableUnpause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUnpause is a free log retrieval operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_Pausable *PausableFilterer) FilterUnpause(opts *bind.FilterOpts) (*PausableUnpauseIterator, error) {

	logs, sub, err := _Pausable.contract.FilterLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return &PausableUnpauseIterator{contract: _Pausable.contract, event: "Unpause", logs: logs, sub: sub}, nil
}

// WatchUnpause is a free log subscription operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_Pausable *PausableFilterer) WatchUnpause(opts *bind.WatchOpts, sink chan<- *PausableUnpause) (event.Subscription, error) {

	logs, sub, err := _Pausable.contract.WatchLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PausableUnpause)
				if err := _Pausable.contract.UnpackLog(event, "Unpause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpause is a log parse operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_Pausable *PausableFilterer) ParseUnpause(log types.Log) (*PausableUnpause, error) {
	event := new(PausableUnpause)
	if err := _Pausable.contract.UnpackLog(event, "Unpause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SafeMathABI is the input ABI used to generate the binding from.
const SafeMathABI = "[]"

// SafeMathBin is the compiled bytecode used for deploying new contracts.
var SafeMathBin = "0x604c602c600b82828239805160001a60731460008114601c57601e565bfe5b5030600052607381538281f30073000000000000000000000000000000000000000030146080604052600080fd00a165627a7a7230582068dabf7c998d306dbeb74afc96bbfaed1d69490899c201ce63c6c3ff90d6c8190029"

// DeploySafeMath deploys a new Ethereum contract, binding an instance of SafeMath to it.
func DeploySafeMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SafeMath, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeMathABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SafeMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SafeMath{SafeMathCaller: SafeMathCaller{contract: contract}, SafeMathTransactor: SafeMathTransactor{contract: contract}, SafeMathFilterer: SafeMathFilterer{contract: contract}}, nil
}

// SafeMath is an auto generated Go binding around an Ethereum contract.
type SafeMath struct {
	SafeMathCaller     // Read-only binding to the contract
	SafeMathTransactor // Write-only binding to the contract
	SafeMathFilterer   // Log filterer for contract events
}

// SafeMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type SafeMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SafeMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SafeMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SafeMathSession struct {
	Contract     *SafeMath         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SafeMathCallerSession struct {
	Contract *SafeMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// SafeMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SafeMathTransactorSession struct {
	Contract     *SafeMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// SafeMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type SafeMathRaw struct {
	Contract *SafeMath // Generic contract binding to access the raw methods on
}

// SafeMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SafeMathCallerRaw struct {
	Contract *SafeMathCaller // Generic read-only contract binding to access the raw methods on
}

// SafeMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SafeMathTransactorRaw struct {
	Contract *SafeMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSafeMath creates a new instance of SafeMath, bound to a specific deployed contract.
func NewSafeMath(address common.Address, backend bind.ContractBackend) (*SafeMath, error) {
	contract, err := bindSafeMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SafeMath{SafeMathCaller: SafeMathCaller{contract: contract}, SafeMathTransactor: SafeMathTransactor{contract: contract}, SafeMathFilterer: SafeMathFilterer{contract: contract}}, nil
}

// NewSafeMathCaller creates a new read-only instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathCaller(address common.Address, caller bind.ContractCaller) (*SafeMathCaller, error) {
	contract, err := bindSafeMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SafeMathCaller{contract: contract}, nil
}

// NewSafeMathTransactor creates a new write-only instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathTransactor(address common.Address, transactor bind.ContractTransactor) (*SafeMathTransactor, error) {
	contract, err := bindSafeMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SafeMathTransactor{contract: contract}, nil
}

// NewSafeMathFilterer creates a new log filterer instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathFilterer(address common.Address, filterer bind.ContractFilterer) (*SafeMathFilterer, error) {
	contract, err := bindSafeMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SafeMathFilterer{contract: contract}, nil
}

// bindSafeMath binds a generic wrapper to an already deployed contract.
func bindSafeMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeMathABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeMath *SafeMathRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SafeMath.Contract.SafeMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeMath *SafeMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeMath.Contract.SafeMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeMath *SafeMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeMath.Contract.SafeMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeMath *SafeMathCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SafeMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeMath *SafeMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeMath *SafeMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeMath.Contract.contract.Transact(opts, method, params...)
}

// SingleCreatorControlABI is the input ABI used to generate the binding from.
const SingleCreatorControlABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"singleCreatorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCreatorAddress\",\"type\":\"address\"}],\"name\":\"changeSingleCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousCreatorAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newCreatorAddress\",\"type\":\"address\"}],\"name\":\"SingleCreatorChanged\",\"type\":\"event\"}]"

// SingleCreatorControlFuncSigs maps the 4-byte function signature to its string representation.
var SingleCreatorControlFuncSigs = map[string]string{
	"a7df572c": "changeSingleCreator(address)",
	"147ca2af": "singleCreatorAddress()",
}

// SingleCreatorControlBin is the compiled bytecode used for deploying new contracts.
var SingleCreatorControlBin = "0x608060405234801561001057600080fd5b5061023c806100206000396000f30060806040526004361061004b5763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663147ca2af8114610050578063a7df572c1461008e575b600080fd5b34801561005c57600080fd5b506100656100be565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b34801561009a57600080fd5b506100bc73ffffffffffffffffffffffffffffffffffffffff600435166100da565b005b60005473ffffffffffffffffffffffffffffffffffffffff1681565b73ffffffffffffffffffffffffffffffffffffffff811615156100fc57600080fd5b60005473ffffffffffffffffffffffffffffffffffffffff1633146101a857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4e6f7420617070726f76656420746f206368616e67652073696e676c6520637260448201527f6561746f722e0000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b6000805473ffffffffffffffffffffffffffffffffffffffff191673ffffffffffffffffffffffffffffffffffffffff83811691821780845560405192939116917f384c948063df3740539b4b000658c1a22348e7f18c87f808085662e461e48e719190a3505600a165627a7a7230582071d079b9c48c9e92a9480f6d3581d1b5caecb41b670605a904ce654e28f032a10029"

// DeploySingleCreatorControl deploys a new Ethereum contract, binding an instance of SingleCreatorControl to it.
func DeploySingleCreatorControl(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SingleCreatorControl, error) {
	parsed, err := abi.JSON(strings.NewReader(SingleCreatorControlABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SingleCreatorControlBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SingleCreatorControl{SingleCreatorControlCaller: SingleCreatorControlCaller{contract: contract}, SingleCreatorControlTransactor: SingleCreatorControlTransactor{contract: contract}, SingleCreatorControlFilterer: SingleCreatorControlFilterer{contract: contract}}, nil
}

// SingleCreatorControl is an auto generated Go binding around an Ethereum contract.
type SingleCreatorControl struct {
	SingleCreatorControlCaller     // Read-only binding to the contract
	SingleCreatorControlTransactor // Write-only binding to the contract
	SingleCreatorControlFilterer   // Log filterer for contract events
}

// SingleCreatorControlCaller is an auto generated read-only Go binding around an Ethereum contract.
type SingleCreatorControlCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SingleCreatorControlTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SingleCreatorControlTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SingleCreatorControlFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SingleCreatorControlFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SingleCreatorControlSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SingleCreatorControlSession struct {
	Contract     *SingleCreatorControl // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// SingleCreatorControlCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SingleCreatorControlCallerSession struct {
	Contract *SingleCreatorControlCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// SingleCreatorControlTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SingleCreatorControlTransactorSession struct {
	Contract     *SingleCreatorControlTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// SingleCreatorControlRaw is an auto generated low-level Go binding around an Ethereum contract.
type SingleCreatorControlRaw struct {
	Contract *SingleCreatorControl // Generic contract binding to access the raw methods on
}

// SingleCreatorControlCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SingleCreatorControlCallerRaw struct {
	Contract *SingleCreatorControlCaller // Generic read-only contract binding to access the raw methods on
}

// SingleCreatorControlTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SingleCreatorControlTransactorRaw struct {
	Contract *SingleCreatorControlTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSingleCreatorControl creates a new instance of SingleCreatorControl, bound to a specific deployed contract.
func NewSingleCreatorControl(address common.Address, backend bind.ContractBackend) (*SingleCreatorControl, error) {
	contract, err := bindSingleCreatorControl(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SingleCreatorControl{SingleCreatorControlCaller: SingleCreatorControlCaller{contract: contract}, SingleCreatorControlTransactor: SingleCreatorControlTransactor{contract: contract}, SingleCreatorControlFilterer: SingleCreatorControlFilterer{contract: contract}}, nil
}

// NewSingleCreatorControlCaller creates a new read-only instance of SingleCreatorControl, bound to a specific deployed contract.
func NewSingleCreatorControlCaller(address common.Address, caller bind.ContractCaller) (*SingleCreatorControlCaller, error) {
	contract, err := bindSingleCreatorControl(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SingleCreatorControlCaller{contract: contract}, nil
}

// NewSingleCreatorControlTransactor creates a new write-only instance of SingleCreatorControl, bound to a specific deployed contract.
func NewSingleCreatorControlTransactor(address common.Address, transactor bind.ContractTransactor) (*SingleCreatorControlTransactor, error) {
	contract, err := bindSingleCreatorControl(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SingleCreatorControlTransactor{contract: contract}, nil
}

// NewSingleCreatorControlFilterer creates a new log filterer instance of SingleCreatorControl, bound to a specific deployed contract.
func NewSingleCreatorControlFilterer(address common.Address, filterer bind.ContractFilterer) (*SingleCreatorControlFilterer, error) {
	contract, err := bindSingleCreatorControl(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SingleCreatorControlFilterer{contract: contract}, nil
}

// bindSingleCreatorControl binds a generic wrapper to an already deployed contract.
func bindSingleCreatorControl(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SingleCreatorControlABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SingleCreatorControl *SingleCreatorControlRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SingleCreatorControl.Contract.SingleCreatorControlCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SingleCreatorControl *SingleCreatorControlRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SingleCreatorControl.Contract.SingleCreatorControlTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SingleCreatorControl *SingleCreatorControlRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SingleCreatorControl.Contract.SingleCreatorControlTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SingleCreatorControl *SingleCreatorControlCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SingleCreatorControl.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SingleCreatorControl *SingleCreatorControlTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SingleCreatorControl.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SingleCreatorControl *SingleCreatorControlTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SingleCreatorControl.Contract.contract.Transact(opts, method, params...)
}

// SingleCreatorAddress is a free data retrieval call binding the contract method 0x147ca2af.
//
// Solidity: function singleCreatorAddress() constant returns(address)
func (_SingleCreatorControl *SingleCreatorControlCaller) SingleCreatorAddress(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _SingleCreatorControl.contract.Call(opts, out, "singleCreatorAddress")
	return *ret0, err
}

// SingleCreatorAddress is a free data retrieval call binding the contract method 0x147ca2af.
//
// Solidity: function singleCreatorAddress() constant returns(address)
func (_SingleCreatorControl *SingleCreatorControlSession) SingleCreatorAddress() (common.Address, error) {
	return _SingleCreatorControl.Contract.SingleCreatorAddress(&_SingleCreatorControl.CallOpts)
}

// SingleCreatorAddress is a free data retrieval call binding the contract method 0x147ca2af.
//
// Solidity: function singleCreatorAddress() constant returns(address)
func (_SingleCreatorControl *SingleCreatorControlCallerSession) SingleCreatorAddress() (common.Address, error) {
	return _SingleCreatorControl.Contract.SingleCreatorAddress(&_SingleCreatorControl.CallOpts)
}

// ChangeSingleCreator is a paid mutator transaction binding the contract method 0xa7df572c.
//
// Solidity: function changeSingleCreator(address _newCreatorAddress) returns()
func (_SingleCreatorControl *SingleCreatorControlTransactor) ChangeSingleCreator(opts *bind.TransactOpts, _newCreatorAddress common.Address) (*types.Transaction, error) {
	return _SingleCreatorControl.contract.Transact(opts, "changeSingleCreator", _newCreatorAddress)
}

// ChangeSingleCreator is a paid mutator transaction binding the contract method 0xa7df572c.
//
// Solidity: function changeSingleCreator(address _newCreatorAddress) returns()
func (_SingleCreatorControl *SingleCreatorControlSession) ChangeSingleCreator(_newCreatorAddress common.Address) (*types.Transaction, error) {
	return _SingleCreatorControl.Contract.ChangeSingleCreator(&_SingleCreatorControl.TransactOpts, _newCreatorAddress)
}

// ChangeSingleCreator is a paid mutator transaction binding the contract method 0xa7df572c.
//
// Solidity: function changeSingleCreator(address _newCreatorAddress) returns()
func (_SingleCreatorControl *SingleCreatorControlTransactorSession) ChangeSingleCreator(_newCreatorAddress common.Address) (*types.Transaction, error) {
	return _SingleCreatorControl.Contract.ChangeSingleCreator(&_SingleCreatorControl.TransactOpts, _newCreatorAddress)
}

// SingleCreatorControlSingleCreatorChangedIterator is returned from FilterSingleCreatorChanged and is used to iterate over the raw logs and unpacked data for SingleCreatorChanged events raised by the SingleCreatorControl contract.
type SingleCreatorControlSingleCreatorChangedIterator struct {
	Event *SingleCreatorControlSingleCreatorChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SingleCreatorControlSingleCreatorChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SingleCreatorControlSingleCreatorChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SingleCreatorControlSingleCreatorChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SingleCreatorControlSingleCreatorChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SingleCreatorControlSingleCreatorChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SingleCreatorControlSingleCreatorChanged represents a SingleCreatorChanged event raised by the SingleCreatorControl contract.
type SingleCreatorControlSingleCreatorChanged struct {
	PreviousCreatorAddress common.Address
	NewCreatorAddress      common.Address
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterSingleCreatorChanged is a free log retrieval operation binding the contract event 0x384c948063df3740539b4b000658c1a22348e7f18c87f808085662e461e48e71.
//
// Solidity: event SingleCreatorChanged(address indexed previousCreatorAddress, address indexed newCreatorAddress)
func (_SingleCreatorControl *SingleCreatorControlFilterer) FilterSingleCreatorChanged(opts *bind.FilterOpts, previousCreatorAddress []common.Address, newCreatorAddress []common.Address) (*SingleCreatorControlSingleCreatorChangedIterator, error) {

	var previousCreatorAddressRule []interface{}
	for _, previousCreatorAddressItem := range previousCreatorAddress {
		previousCreatorAddressRule = append(previousCreatorAddressRule, previousCreatorAddressItem)
	}
	var newCreatorAddressRule []interface{}
	for _, newCreatorAddressItem := range newCreatorAddress {
		newCreatorAddressRule = append(newCreatorAddressRule, newCreatorAddressItem)
	}

	logs, sub, err := _SingleCreatorControl.contract.FilterLogs(opts, "SingleCreatorChanged", previousCreatorAddressRule, newCreatorAddressRule)
	if err != nil {
		return nil, err
	}
	return &SingleCreatorControlSingleCreatorChangedIterator{contract: _SingleCreatorControl.contract, event: "SingleCreatorChanged", logs: logs, sub: sub}, nil
}

// WatchSingleCreatorChanged is a free log subscription operation binding the contract event 0x384c948063df3740539b4b000658c1a22348e7f18c87f808085662e461e48e71.
//
// Solidity: event SingleCreatorChanged(address indexed previousCreatorAddress, address indexed newCreatorAddress)
func (_SingleCreatorControl *SingleCreatorControlFilterer) WatchSingleCreatorChanged(opts *bind.WatchOpts, sink chan<- *SingleCreatorControlSingleCreatorChanged, previousCreatorAddress []common.Address, newCreatorAddress []common.Address) (event.Subscription, error) {

	var previousCreatorAddressRule []interface{}
	for _, previousCreatorAddressItem := range previousCreatorAddress {
		previousCreatorAddressRule = append(previousCreatorAddressRule, previousCreatorAddressItem)
	}
	var newCreatorAddressRule []interface{}
	for _, newCreatorAddressItem := range newCreatorAddress {
		newCreatorAddressRule = append(newCreatorAddressRule, newCreatorAddressItem)
	}

	logs, sub, err := _SingleCreatorControl.contract.WatchLogs(opts, "SingleCreatorChanged", previousCreatorAddressRule, newCreatorAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SingleCreatorControlSingleCreatorChanged)
				if err := _SingleCreatorControl.contract.UnpackLog(event, "SingleCreatorChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSingleCreatorChanged is a log parse operation binding the contract event 0x384c948063df3740539b4b000658c1a22348e7f18c87f808085662e461e48e71.
//
// Solidity: event SingleCreatorChanged(address indexed previousCreatorAddress, address indexed newCreatorAddress)
func (_SingleCreatorControl *SingleCreatorControlFilterer) ParseSingleCreatorChanged(log types.Log) (*SingleCreatorControlSingleCreatorChanged, error) {
	event := new(SingleCreatorControlSingleCreatorChanged)
	if err := _SingleCreatorControl.contract.UnpackLog(event, "SingleCreatorChanged", log); err != nil {
		return nil, err
	}
	return event, nil
}

// WithdrawFundsControlABI is the input ABI used to generate the binding from.
const WithdrawFundsControlABI = "[{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawAddress\",\"type\":\"address\"}],\"name\":\"addApprovedWithdrawAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedWithdrawAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedWithdrawAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"withdrawAddress\",\"type\":\"address\"}],\"name\":\"WithdrawAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"widthdrawAddress\",\"type\":\"address\"}],\"name\":\"WithdrawAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]"

// WithdrawFundsControlFuncSigs maps the 4-byte function signature to its string representation.
var WithdrawFundsControlFuncSigs = map[string]string{
	"1a32de49": "addApprovedWithdrawAddress(address)",
	"ce2d29ac": "approvedWithdrawAddresses(address)",
	"8da5cb5b": "owner()",
	"8456cb59": "pause()",
	"5c975abb": "paused()",
	"e6ccc9bd": "removeApprovedWithdrawAddress(address)",
	"f2fde38b": "transferOwnership(address)",
	"3f4ba83a": "unpause()",
}

// WithdrawFundsControlBin is the compiled bytecode used for deploying new contracts.
var WithdrawFundsControlBin = "0x608060405260008054600160a860020a031916331790556104a8806100256000396000f30060806040526004361061008d5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416631a32de4981146100925780633f4ba83a146100b55780635c975abb146100ca5780638456cb59146100f35780638da5cb5b14610108578063ce2d29ac14610139578063e6ccc9bd1461016c578063f2fde38b1461018d575b600080fd5b34801561009e57600080fd5b506100b3600160a060020a03600435166101ae565b005b3480156100c157600080fd5b506100b3610218565b3480156100d657600080fd5b506100df61029f565b604080519115158252519081900360200190f35b3480156100ff57600080fd5b506100b36102c0565b34801561011457600080fd5b5061011d61035d565b60408051600160a060020a039092168252519081900360200190f35b34801561014557600080fd5b5061015a600160a060020a036004351661036c565b60408051918252519081900360200190f35b34801561017857600080fd5b506100b3600160a060020a036004351661037e565b34801561019957600080fd5b506100b3600160a060020a03600435166103e8565b600054600160a060020a031633146101c557600080fd5b600160a060020a038116600081815260016020908152604091829020429055815192835290517fd3d6d317b22983ab294dbfe93460137c732b9644d637bfbb3258735daf17da899281900390910190a150565b600054600160a060020a0316331461022f57600080fd5b60005474010000000000000000000000000000000000000000900460ff16151561025857600080fd5b6000805474ff0000000000000000000000000000000000000000191681556040517f7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b339190a1565b60005474010000000000000000000000000000000000000000900460ff1681565b600054600160a060020a031633146102d757600080fd5b60005474010000000000000000000000000000000000000000900460ff16156102ff57600080fd5b6000805474ff00000000000000000000000000000000000000001916740100000000000000000000000000000000000000001781556040517f6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff6259190a1565b600054600160a060020a031681565b60016020526000908152604090205481565b600054600160a060020a0316331461039557600080fd5b600160a060020a038116600081815260016020908152604080832092909255815192835290517fffdbac6a703f8c063588b1b434bac15231b40f4c20b16f797a989d47a56ae8b29281900390910190a150565b600054600160a060020a031633146103ff57600080fd5b600160a060020a038116151561041457600080fd5b60008054604051600160a060020a03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790555600a165627a7a72305820f5adb9c72cd2ea70b528102891f24c6bae3b723392cd16b1afcf8d651ec9cd600029"

// DeployWithdrawFundsControl deploys a new Ethereum contract, binding an instance of WithdrawFundsControl to it.
func DeployWithdrawFundsControl(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *WithdrawFundsControl, error) {
	parsed, err := abi.JSON(strings.NewReader(WithdrawFundsControlABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(WithdrawFundsControlBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &WithdrawFundsControl{WithdrawFundsControlCaller: WithdrawFundsControlCaller{contract: contract}, WithdrawFundsControlTransactor: WithdrawFundsControlTransactor{contract: contract}, WithdrawFundsControlFilterer: WithdrawFundsControlFilterer{contract: contract}}, nil
}

// WithdrawFundsControl is an auto generated Go binding around an Ethereum contract.
type WithdrawFundsControl struct {
	WithdrawFundsControlCaller     // Read-only binding to the contract
	WithdrawFundsControlTransactor // Write-only binding to the contract
	WithdrawFundsControlFilterer   // Log filterer for contract events
}

// WithdrawFundsControlCaller is an auto generated read-only Go binding around an Ethereum contract.
type WithdrawFundsControlCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// WithdrawFundsControlTransactor is an auto generated write-only Go binding around an Ethereum contract.
type WithdrawFundsControlTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// WithdrawFundsControlFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type WithdrawFundsControlFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// WithdrawFundsControlSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type WithdrawFundsControlSession struct {
	Contract     *WithdrawFundsControl // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// WithdrawFundsControlCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type WithdrawFundsControlCallerSession struct {
	Contract *WithdrawFundsControlCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// WithdrawFundsControlTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type WithdrawFundsControlTransactorSession struct {
	Contract     *WithdrawFundsControlTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// WithdrawFundsControlRaw is an auto generated low-level Go binding around an Ethereum contract.
type WithdrawFundsControlRaw struct {
	Contract *WithdrawFundsControl // Generic contract binding to access the raw methods on
}

// WithdrawFundsControlCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type WithdrawFundsControlCallerRaw struct {
	Contract *WithdrawFundsControlCaller // Generic read-only contract binding to access the raw methods on
}

// WithdrawFundsControlTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type WithdrawFundsControlTransactorRaw struct {
	Contract *WithdrawFundsControlTransactor // Generic write-only contract binding to access the raw methods on
}

// NewWithdrawFundsControl creates a new instance of WithdrawFundsControl, bound to a specific deployed contract.
func NewWithdrawFundsControl(address common.Address, backend bind.ContractBackend) (*WithdrawFundsControl, error) {
	contract, err := bindWithdrawFundsControl(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &WithdrawFundsControl{WithdrawFundsControlCaller: WithdrawFundsControlCaller{contract: contract}, WithdrawFundsControlTransactor: WithdrawFundsControlTransactor{contract: contract}, WithdrawFundsControlFilterer: WithdrawFundsControlFilterer{contract: contract}}, nil
}

// NewWithdrawFundsControlCaller creates a new read-only instance of WithdrawFundsControl, bound to a specific deployed contract.
func NewWithdrawFundsControlCaller(address common.Address, caller bind.ContractCaller) (*WithdrawFundsControlCaller, error) {
	contract, err := bindWithdrawFundsControl(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &WithdrawFundsControlCaller{contract: contract}, nil
}

// NewWithdrawFundsControlTransactor creates a new write-only instance of WithdrawFundsControl, bound to a specific deployed contract.
func NewWithdrawFundsControlTransactor(address common.Address, transactor bind.ContractTransactor) (*WithdrawFundsControlTransactor, error) {
	contract, err := bindWithdrawFundsControl(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &WithdrawFundsControlTransactor{contract: contract}, nil
}

// NewWithdrawFundsControlFilterer creates a new log filterer instance of WithdrawFundsControl, bound to a specific deployed contract.
func NewWithdrawFundsControlFilterer(address common.Address, filterer bind.ContractFilterer) (*WithdrawFundsControlFilterer, error) {
	contract, err := bindWithdrawFundsControl(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &WithdrawFundsControlFilterer{contract: contract}, nil
}

// bindWithdrawFundsControl binds a generic wrapper to an already deployed contract.
func bindWithdrawFundsControl(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(WithdrawFundsControlABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_WithdrawFundsControl *WithdrawFundsControlRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _WithdrawFundsControl.Contract.WithdrawFundsControlCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_WithdrawFundsControl *WithdrawFundsControlRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.WithdrawFundsControlTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_WithdrawFundsControl *WithdrawFundsControlRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.WithdrawFundsControlTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_WithdrawFundsControl *WithdrawFundsControlCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _WithdrawFundsControl.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_WithdrawFundsControl *WithdrawFundsControlTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_WithdrawFundsControl *WithdrawFundsControlTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.contract.Transact(opts, method, params...)
}

// ApprovedWithdrawAddresses is a free data retrieval call binding the contract method 0xce2d29ac.
//
// Solidity: function approvedWithdrawAddresses(address ) constant returns(uint256)
func (_WithdrawFundsControl *WithdrawFundsControlCaller) ApprovedWithdrawAddresses(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _WithdrawFundsControl.contract.Call(opts, out, "approvedWithdrawAddresses", arg0)
	return *ret0, err
}

// ApprovedWithdrawAddresses is a free data retrieval call binding the contract method 0xce2d29ac.
//
// Solidity: function approvedWithdrawAddresses(address ) constant returns(uint256)
func (_WithdrawFundsControl *WithdrawFundsControlSession) ApprovedWithdrawAddresses(arg0 common.Address) (*big.Int, error) {
	return _WithdrawFundsControl.Contract.ApprovedWithdrawAddresses(&_WithdrawFundsControl.CallOpts, arg0)
}

// ApprovedWithdrawAddresses is a free data retrieval call binding the contract method 0xce2d29ac.
//
// Solidity: function approvedWithdrawAddresses(address ) constant returns(uint256)
func (_WithdrawFundsControl *WithdrawFundsControlCallerSession) ApprovedWithdrawAddresses(arg0 common.Address) (*big.Int, error) {
	return _WithdrawFundsControl.Contract.ApprovedWithdrawAddresses(&_WithdrawFundsControl.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_WithdrawFundsControl *WithdrawFundsControlCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _WithdrawFundsControl.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_WithdrawFundsControl *WithdrawFundsControlSession) Owner() (common.Address, error) {
	return _WithdrawFundsControl.Contract.Owner(&_WithdrawFundsControl.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_WithdrawFundsControl *WithdrawFundsControlCallerSession) Owner() (common.Address, error) {
	return _WithdrawFundsControl.Contract.Owner(&_WithdrawFundsControl.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_WithdrawFundsControl *WithdrawFundsControlCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _WithdrawFundsControl.contract.Call(opts, out, "paused")
	return *ret0, err
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_WithdrawFundsControl *WithdrawFundsControlSession) Paused() (bool, error) {
	return _WithdrawFundsControl.Contract.Paused(&_WithdrawFundsControl.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() constant returns(bool)
func (_WithdrawFundsControl *WithdrawFundsControlCallerSession) Paused() (bool, error) {
	return _WithdrawFundsControl.Contract.Paused(&_WithdrawFundsControl.CallOpts)
}

// AddApprovedWithdrawAddress is a paid mutator transaction binding the contract method 0x1a32de49.
//
// Solidity: function addApprovedWithdrawAddress(address _withdrawAddress) returns()
func (_WithdrawFundsControl *WithdrawFundsControlTransactor) AddApprovedWithdrawAddress(opts *bind.TransactOpts, _withdrawAddress common.Address) (*types.Transaction, error) {
	return _WithdrawFundsControl.contract.Transact(opts, "addApprovedWithdrawAddress", _withdrawAddress)
}

// AddApprovedWithdrawAddress is a paid mutator transaction binding the contract method 0x1a32de49.
//
// Solidity: function addApprovedWithdrawAddress(address _withdrawAddress) returns()
func (_WithdrawFundsControl *WithdrawFundsControlSession) AddApprovedWithdrawAddress(_withdrawAddress common.Address) (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.AddApprovedWithdrawAddress(&_WithdrawFundsControl.TransactOpts, _withdrawAddress)
}

// AddApprovedWithdrawAddress is a paid mutator transaction binding the contract method 0x1a32de49.
//
// Solidity: function addApprovedWithdrawAddress(address _withdrawAddress) returns()
func (_WithdrawFundsControl *WithdrawFundsControlTransactorSession) AddApprovedWithdrawAddress(_withdrawAddress common.Address) (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.AddApprovedWithdrawAddress(&_WithdrawFundsControl.TransactOpts, _withdrawAddress)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_WithdrawFundsControl *WithdrawFundsControlTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _WithdrawFundsControl.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_WithdrawFundsControl *WithdrawFundsControlSession) Pause() (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.Pause(&_WithdrawFundsControl.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_WithdrawFundsControl *WithdrawFundsControlTransactorSession) Pause() (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.Pause(&_WithdrawFundsControl.TransactOpts)
}

// RemoveApprovedWithdrawAddress is a paid mutator transaction binding the contract method 0xe6ccc9bd.
//
// Solidity: function removeApprovedWithdrawAddress(address _withdrawAddress) returns()
func (_WithdrawFundsControl *WithdrawFundsControlTransactor) RemoveApprovedWithdrawAddress(opts *bind.TransactOpts, _withdrawAddress common.Address) (*types.Transaction, error) {
	return _WithdrawFundsControl.contract.Transact(opts, "removeApprovedWithdrawAddress", _withdrawAddress)
}

// RemoveApprovedWithdrawAddress is a paid mutator transaction binding the contract method 0xe6ccc9bd.
//
// Solidity: function removeApprovedWithdrawAddress(address _withdrawAddress) returns()
func (_WithdrawFundsControl *WithdrawFundsControlSession) RemoveApprovedWithdrawAddress(_withdrawAddress common.Address) (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.RemoveApprovedWithdrawAddress(&_WithdrawFundsControl.TransactOpts, _withdrawAddress)
}

// RemoveApprovedWithdrawAddress is a paid mutator transaction binding the contract method 0xe6ccc9bd.
//
// Solidity: function removeApprovedWithdrawAddress(address _withdrawAddress) returns()
func (_WithdrawFundsControl *WithdrawFundsControlTransactorSession) RemoveApprovedWithdrawAddress(_withdrawAddress common.Address) (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.RemoveApprovedWithdrawAddress(&_WithdrawFundsControl.TransactOpts, _withdrawAddress)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_WithdrawFundsControl *WithdrawFundsControlTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _WithdrawFundsControl.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_WithdrawFundsControl *WithdrawFundsControlSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.TransferOwnership(&_WithdrawFundsControl.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_WithdrawFundsControl *WithdrawFundsControlTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.TransferOwnership(&_WithdrawFundsControl.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_WithdrawFundsControl *WithdrawFundsControlTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _WithdrawFundsControl.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_WithdrawFundsControl *WithdrawFundsControlSession) Unpause() (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.Unpause(&_WithdrawFundsControl.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_WithdrawFundsControl *WithdrawFundsControlTransactorSession) Unpause() (*types.Transaction, error) {
	return _WithdrawFundsControl.Contract.Unpause(&_WithdrawFundsControl.TransactOpts)
}

// WithdrawFundsControlOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the WithdrawFundsControl contract.
type WithdrawFundsControlOwnershipTransferredIterator struct {
	Event *WithdrawFundsControlOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *WithdrawFundsControlOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(WithdrawFundsControlOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(WithdrawFundsControlOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *WithdrawFundsControlOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *WithdrawFundsControlOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// WithdrawFundsControlOwnershipTransferred represents a OwnershipTransferred event raised by the WithdrawFundsControl contract.
type WithdrawFundsControlOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*WithdrawFundsControlOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _WithdrawFundsControl.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &WithdrawFundsControlOwnershipTransferredIterator{contract: _WithdrawFundsControl.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *WithdrawFundsControlOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _WithdrawFundsControl.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(WithdrawFundsControlOwnershipTransferred)
				if err := _WithdrawFundsControl.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) ParseOwnershipTransferred(log types.Log) (*WithdrawFundsControlOwnershipTransferred, error) {
	event := new(WithdrawFundsControlOwnershipTransferred)
	if err := _WithdrawFundsControl.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// WithdrawFundsControlPauseIterator is returned from FilterPause and is used to iterate over the raw logs and unpacked data for Pause events raised by the WithdrawFundsControl contract.
type WithdrawFundsControlPauseIterator struct {
	Event *WithdrawFundsControlPause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *WithdrawFundsControlPauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(WithdrawFundsControlPause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(WithdrawFundsControlPause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *WithdrawFundsControlPauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *WithdrawFundsControlPauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// WithdrawFundsControlPause represents a Pause event raised by the WithdrawFundsControl contract.
type WithdrawFundsControlPause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPause is a free log retrieval operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) FilterPause(opts *bind.FilterOpts) (*WithdrawFundsControlPauseIterator, error) {

	logs, sub, err := _WithdrawFundsControl.contract.FilterLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return &WithdrawFundsControlPauseIterator{contract: _WithdrawFundsControl.contract, event: "Pause", logs: logs, sub: sub}, nil
}

// WatchPause is a free log subscription operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) WatchPause(opts *bind.WatchOpts, sink chan<- *WithdrawFundsControlPause) (event.Subscription, error) {

	logs, sub, err := _WithdrawFundsControl.contract.WatchLogs(opts, "Pause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(WithdrawFundsControlPause)
				if err := _WithdrawFundsControl.contract.UnpackLog(event, "Pause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePause is a log parse operation binding the contract event 0x6985a02210a168e66602d3235cb6db0e70f92b3ba4d376a33c0f3d9434bff625.
//
// Solidity: event Pause()
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) ParsePause(log types.Log) (*WithdrawFundsControlPause, error) {
	event := new(WithdrawFundsControlPause)
	if err := _WithdrawFundsControl.contract.UnpackLog(event, "Pause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// WithdrawFundsControlUnpauseIterator is returned from FilterUnpause and is used to iterate over the raw logs and unpacked data for Unpause events raised by the WithdrawFundsControl contract.
type WithdrawFundsControlUnpauseIterator struct {
	Event *WithdrawFundsControlUnpause // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *WithdrawFundsControlUnpauseIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(WithdrawFundsControlUnpause)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(WithdrawFundsControlUnpause)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *WithdrawFundsControlUnpauseIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *WithdrawFundsControlUnpauseIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// WithdrawFundsControlUnpause represents a Unpause event raised by the WithdrawFundsControl contract.
type WithdrawFundsControlUnpause struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUnpause is a free log retrieval operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) FilterUnpause(opts *bind.FilterOpts) (*WithdrawFundsControlUnpauseIterator, error) {

	logs, sub, err := _WithdrawFundsControl.contract.FilterLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return &WithdrawFundsControlUnpauseIterator{contract: _WithdrawFundsControl.contract, event: "Unpause", logs: logs, sub: sub}, nil
}

// WatchUnpause is a free log subscription operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) WatchUnpause(opts *bind.WatchOpts, sink chan<- *WithdrawFundsControlUnpause) (event.Subscription, error) {

	logs, sub, err := _WithdrawFundsControl.contract.WatchLogs(opts, "Unpause")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(WithdrawFundsControlUnpause)
				if err := _WithdrawFundsControl.contract.UnpackLog(event, "Unpause", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpause is a log parse operation binding the contract event 0x7805862f689e2f13df9f062ff482ad3ad112aca9e0847911ed832e158c525b33.
//
// Solidity: event Unpause()
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) ParseUnpause(log types.Log) (*WithdrawFundsControlUnpause, error) {
	event := new(WithdrawFundsControlUnpause)
	if err := _WithdrawFundsControl.contract.UnpackLog(event, "Unpause", log); err != nil {
		return nil, err
	}
	return event, nil
}

// WithdrawFundsControlWithdrawAddressAddedIterator is returned from FilterWithdrawAddressAdded and is used to iterate over the raw logs and unpacked data for WithdrawAddressAdded events raised by the WithdrawFundsControl contract.
type WithdrawFundsControlWithdrawAddressAddedIterator struct {
	Event *WithdrawFundsControlWithdrawAddressAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *WithdrawFundsControlWithdrawAddressAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(WithdrawFundsControlWithdrawAddressAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(WithdrawFundsControlWithdrawAddressAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *WithdrawFundsControlWithdrawAddressAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *WithdrawFundsControlWithdrawAddressAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// WithdrawFundsControlWithdrawAddressAdded represents a WithdrawAddressAdded event raised by the WithdrawFundsControl contract.
type WithdrawFundsControlWithdrawAddressAdded struct {
	WithdrawAddress common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterWithdrawAddressAdded is a free log retrieval operation binding the contract event 0xd3d6d317b22983ab294dbfe93460137c732b9644d637bfbb3258735daf17da89.
//
// Solidity: event WithdrawAddressAdded(address withdrawAddress)
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) FilterWithdrawAddressAdded(opts *bind.FilterOpts) (*WithdrawFundsControlWithdrawAddressAddedIterator, error) {

	logs, sub, err := _WithdrawFundsControl.contract.FilterLogs(opts, "WithdrawAddressAdded")
	if err != nil {
		return nil, err
	}
	return &WithdrawFundsControlWithdrawAddressAddedIterator{contract: _WithdrawFundsControl.contract, event: "WithdrawAddressAdded", logs: logs, sub: sub}, nil
}

// WatchWithdrawAddressAdded is a free log subscription operation binding the contract event 0xd3d6d317b22983ab294dbfe93460137c732b9644d637bfbb3258735daf17da89.
//
// Solidity: event WithdrawAddressAdded(address withdrawAddress)
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) WatchWithdrawAddressAdded(opts *bind.WatchOpts, sink chan<- *WithdrawFundsControlWithdrawAddressAdded) (event.Subscription, error) {

	logs, sub, err := _WithdrawFundsControl.contract.WatchLogs(opts, "WithdrawAddressAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(WithdrawFundsControlWithdrawAddressAdded)
				if err := _WithdrawFundsControl.contract.UnpackLog(event, "WithdrawAddressAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawAddressAdded is a log parse operation binding the contract event 0xd3d6d317b22983ab294dbfe93460137c732b9644d637bfbb3258735daf17da89.
//
// Solidity: event WithdrawAddressAdded(address withdrawAddress)
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) ParseWithdrawAddressAdded(log types.Log) (*WithdrawFundsControlWithdrawAddressAdded, error) {
	event := new(WithdrawFundsControlWithdrawAddressAdded)
	if err := _WithdrawFundsControl.contract.UnpackLog(event, "WithdrawAddressAdded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// WithdrawFundsControlWithdrawAddressRemovedIterator is returned from FilterWithdrawAddressRemoved and is used to iterate over the raw logs and unpacked data for WithdrawAddressRemoved events raised by the WithdrawFundsControl contract.
type WithdrawFundsControlWithdrawAddressRemovedIterator struct {
	Event *WithdrawFundsControlWithdrawAddressRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *WithdrawFundsControlWithdrawAddressRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(WithdrawFundsControlWithdrawAddressRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(WithdrawFundsControlWithdrawAddressRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *WithdrawFundsControlWithdrawAddressRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *WithdrawFundsControlWithdrawAddressRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// WithdrawFundsControlWithdrawAddressRemoved represents a WithdrawAddressRemoved event raised by the WithdrawFundsControl contract.
type WithdrawFundsControlWithdrawAddressRemoved struct {
	WidthdrawAddress common.Address
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterWithdrawAddressRemoved is a free log retrieval operation binding the contract event 0xffdbac6a703f8c063588b1b434bac15231b40f4c20b16f797a989d47a56ae8b2.
//
// Solidity: event WithdrawAddressRemoved(address widthdrawAddress)
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) FilterWithdrawAddressRemoved(opts *bind.FilterOpts) (*WithdrawFundsControlWithdrawAddressRemovedIterator, error) {

	logs, sub, err := _WithdrawFundsControl.contract.FilterLogs(opts, "WithdrawAddressRemoved")
	if err != nil {
		return nil, err
	}
	return &WithdrawFundsControlWithdrawAddressRemovedIterator{contract: _WithdrawFundsControl.contract, event: "WithdrawAddressRemoved", logs: logs, sub: sub}, nil
}

// WatchWithdrawAddressRemoved is a free log subscription operation binding the contract event 0xffdbac6a703f8c063588b1b434bac15231b40f4c20b16f797a989d47a56ae8b2.
//
// Solidity: event WithdrawAddressRemoved(address widthdrawAddress)
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) WatchWithdrawAddressRemoved(opts *bind.WatchOpts, sink chan<- *WithdrawFundsControlWithdrawAddressRemoved) (event.Subscription, error) {

	logs, sub, err := _WithdrawFundsControl.contract.WatchLogs(opts, "WithdrawAddressRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(WithdrawFundsControlWithdrawAddressRemoved)
				if err := _WithdrawFundsControl.contract.UnpackLog(event, "WithdrawAddressRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawAddressRemoved is a log parse operation binding the contract event 0xffdbac6a703f8c063588b1b434bac15231b40f4c20b16f797a989d47a56ae8b2.
//
// Solidity: event WithdrawAddressRemoved(address widthdrawAddress)
func (_WithdrawFundsControl *WithdrawFundsControlFilterer) ParseWithdrawAddressRemoved(log types.Log) (*WithdrawFundsControlWithdrawAddressRemoved, error) {
	event := new(WithdrawFundsControlWithdrawAddressRemoved)
	if err := _WithdrawFundsControl.contract.UnpackLog(event, "WithdrawAddressRemoved", log); err != nil {
		return nil, err
	}
	return event, nil
}
